// 2023-10-19

* 依赖注入，依赖注入可以解决父子组件之间的数据通信的问题，不需要在全局声明一个pinia状态对象进行管理报错
* 在使用依赖注入的时候如果声明的组件值不想被使用者修改那么就需要readonly进行包装
```ts
import { ref, provide, readonly } from 'vue'
const count = ref(0)
provide('read-only-count', readonly(count))
```

* 使用 Symbol 作注入名，这样可以保持唯一的名称

```ts
1. // keys.js
export const myInjectionKey = Symbol()
```
```ts
2. // 在供给方组件中
import { provide } from 'vue'
import { myInjectionKey } from './keys.js'

provide(myInjectionKey, { /*
  要提供的数据
*/ });
```
```ts
3. // 注入方组件
import { inject } from 'vue'
import { myInjectionKey } from './keys.js'

const injected = inject(myInjectionKey)
```

* ts的Pick<Type, Keys>使用技巧
> type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
}
> 从Type中选取一系列的属性，这些属性来自于Keys（字符串字面量或字符串字面量的联合类型），用这些属性构成新的type。

* ts的Omit<Type, Keys>使用技巧
> type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
> 从Type中选取所有的属性值，然后移除属性名在Keys中的属性值


* ts的Partial<Type>使用技巧


```ts
type Partial<T> = {
    [P in keyof T]?: T[P];}
```

> Partial【将类型中所有的项都调整为可选属性（即加上?）】

* ts的Required<type>使用技巧
>  type Required<T> = {
    [P in keyof T]-?: T[P];
}
> Required【将类型中所有的项都调整为必选属性（即去掉?）】

* ts的AddId的使用技巧
> export type AddId<T, P = string> = T & {id: P};


// 2023-11-01

路由多层嵌套：https://router.vuejs.org/zh/guide/essentials/nested-routes.html

路由跳转：


```js
const username = 'eduardo'
// 我们可以手动建立 url，但我们必须自己处理编码
router.push(`/user/${username}`) // -> /user/eduardo
// 同样
router.push({ path: `/user/${username}` }) // -> /user/eduardo
// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益
router.push({ name: 'user', params: { username } }) // -> /user/eduardo
// `params` 不能与 `path` 一起使用
router.push({ path: '/user', params: { username } }) // -> /user
```


如果是用createWebHistory这个方法，具体的使用方法请参考：https://router.vuejs.org/zh/guide/essentials/history-mode.html


路由钩子函数解析流程如下：

```md
完整的导航解析流程
导航被触发。
在失活的组件里调用 beforeRouteLeave 守卫。
调用全局的 beforeEach 守卫。
在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。
在路由配置里调用 beforeEnter。
解析异步路由组件。
在被激活的组件里调用 beforeRouteEnter。
调用全局的 beforeResolve 守卫(2.5+)。
导航被确认。
调用全局的 afterEach 钩子。
触发 DOM 更新。
调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。
```


在vue3中的setup中访问当前路由用法是：
```ts
在 setup 中访问路由和当前路由
因为我们在 setup 里面没有访问 this，所以我们不能再直接访问 this.$router 或 this.$route。作为替代，我们使用 useRouter 和 useRoute 函数：
```


[https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html](vuerouter路由滚动逻辑实现：)


h5与ios调整时遇到的问题，h5滑动的时候app底部会有一小块留白：

1.  解决方案1: 原生ios开发可以使用:
 const webview= new WKWebView();
webview.scrollView.contentInsetAdjustmentBehavior=UIScrollViewContentInsetAdjustmentNever
contentInsetAdjustmentBehavior这是iosapp中内嵌的浏览器的属性，如果设置成了UIScrollViewContentInsetAdjustmentNever，那么ios就不会给底部一个默认的安全边距；但如果设置的是UIScrollViewContentInsetAdjustmentAuto，这时候就会给其设置一个安全边距，这样用户在滑动过程中就会出现底部的白块的问题
2. 解决方案2:app这边环境需要head里的meta标签添加一个配置viewport-fit=cover；同时要注意每个页面div元素需要充满当前页面，也就是height:100vh



















