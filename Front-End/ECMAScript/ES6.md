
- [ES6](#es6)
    - [1 let命令](#1-let命令)
    - [1.1 不存在变量提升](#11-不存在变量提升)
    - [1.2 暂时性死区](#12-暂时性死区)
    - [1.3 不允许重复声明](#13-不允许重复声明)
    - [1.4 为什么需要块级作用域](#14-为什么需要块级作用域)
    - [1.5 块级作用域与函数声明](#15-块级作用域与函数声明)
    - [2 const命令](#2-const命令)
    - [3 typeof操作符](#3-typeof操作符)
    - [3.1 undefined类型](#31-undefined类型)
    - [3.2  Boolean 类型](#32--boolean-类型)
    - [3.3  Number 类型](#33--number-类型)
    - [3.4  类型](#34--类型)

# ES6

### 1 let命令

ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效(这很像java的局部变量与全局变量)。

```javascript
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}   // 输出三次abc
```

```javascript
{
    let a = 10;
    var b = 1;
}
      
a // ReferenceError: a is not defined.
b // 1
```

### 1.1 不存在变量提升

var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。

为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

```javascript
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。

### 1.2 暂时性死区
+ 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
+ ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
+ 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”
```javascript
function bar(x = y, y = 2) {
  return [x, y];
}
bar(); // 报错
// 调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。
```

### 1.3 不允许重复声明
+ let不允许在相同作用域内，重复声明同一个变量。

### 1.4 为什么需要块级作用域

+ ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。
1. 内层变量可能会覆盖外层变量。
2. 用来计数的循环变量泄露为全局变量。
+ 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

### 1.5 块级作用域与函数声明

+ ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
+ 
+ 允许在块级作用域内声明函数。
+ 
+ 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
+ 
+ 同时，函数声明还会提升到所在的块级作用域的头部。

### 2 const命令

+ const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且如果尝试修改const声明的变量会导致运行错误。

+ const声明的限制只适用于它指向的变量引用，如果const声明的是一个对象，那么对象内部的属性修改并不违反const的限制。
  
+ const声明一个不会被修改的for循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对for-of和for-in循环有特别意义。

      声明风格与最佳实践：

    1.不使用var：有了let与const，限制自己只用let和const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。

    2.const优先，let次之，在声明前提前明确有哪些变量的值永远不会变化。

### 3 typeof操作符

由于ES6以来其类型系统是松散的，用typeof操作符来确定任意变量的数据类型。例如

```javascript
let message = "some string";
console.log(typeof message); // "string"
console.log(typeof(message)); // "string"
console.log(typeof 95); // "number"
```

### 3.1 undefined类型

注意 一般来说，永远不用显式地给某个变量设置 undefined
值。字面值 undefined 主要用于比较，而且在ECMA-262第3版
之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象
指针（ null ）和未初始化变量的区别。




### 3.2  Boolean 类型

+ Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值： true 和 false 。这两个布尔值不同于数值，因此 true 不等于1， false 不等于0。下面是给变量赋布尔值的例子：


```javascript
let found = true;
let lost = false;
```

### 3.3  Number 类型

ECMAScript中最有意思的数据类型或许就是 Number 了。Number 类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。最基本的数值字面量格式是十进制整数，直接写出来即可：

### 3.4  类型
