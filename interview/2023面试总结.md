##  （一）滴滴打车

### 1. 聊聊你的项目吧，有做过哪些数据上报的内容，有做过什么性能优化吗

性能优化：减少http请求
图片类型修改由png/jpg修改成webp
设置合理的缓存
资源合并或者压缩，这一般是webpack做的事情

页面加载时间的方法
1. 压缩css/js文件
2. 合并js/css文件，减少http请求
3. 外部js/css放在底部
4. 减少dom操作，尽可能用变量替代不必要的dom操作

<!-- https://developer.mozilla.org/zh-CN/docs/Web/API/Performance_API/Navigation_timing -->

### 2. 你对webpack有什么了解，你知道webpack与vite有什么区别吗


1.开发模式不同

Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。

2.打包效率不同

Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。

3.插件生态不同

Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。

4.配置复杂度不同

Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。

5.热更新机制不同

Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度。

### 3.你对node有什么了解？，说说node
### 4.微前端是什么，介绍一下微前端呗

我了解的微前端技术有：
iframe
single-spa
qiankun 基于 single-spa 方案实现, 更强大更易上手
webpack5 ModuleFederationPlugin（EMP）
microApp

### 5. [{ key: 'x', value: '2' }, { key: 'x', value: '2' }, { key: 'x', value: '3' }]如何去重

使用es6的Set
```js
const useMap=(arr)=>{
    const arrSet=new Set();
    const result=[];
    arr.forEach(item=>{
        arrSet.add(item.value);
    })
    console.log(arrSet,'arrSet')
    arrSet.forEach(value=>{
        console.log(value,'value')
        result.push({key:'x',value})
    })
    console.log(result,'result')
    return result;
}
```

### 6. abcd，aba，adbd，如何判断他是不是回文

### 6.请找出abdcdasd这里面的最长不重复的字符串，请返回他的长度

```ts
[{ key: 'x', value: '2' }, { key: 'x', value: '2' }, { key: 'x', value: '3' }]

const fun = (arr) => {
    let obj = {}
    let newSet = new Set();
    let arr = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr.has(i)) {

        } else {

        }
    }
    for () {
        //下次循环就拿到对应的新的arr
    }
}

const fun = (sting) => {
    const stringArray = string.split('');
    const center = Math.ceil(stringArray.length / 2);
    if (let i = 0; i < center; i++) {
        if (stringArray[i].toLocaleUpperCase() !== stringArray[stringArray.length - i].toLocaleUpperCase()) {
            return false;
        }
    }
    return true;
}

const fun1=(string)=>{

}
```
express
koa


### 博研智通

### 1. 高阶函数用过吗？了解过arguments对象吗？

* 函数柯里化，使用场景比如有固定参数你需要动态化，这时候写一个最最基础的方法，然后使用柯里化声明一个新的对象这时候就可以解决这些问题了

### 2. HTTP状态码与304状态码介绍一下

301:永久重定向
302:临时重定向

304:状态码详解（协商缓存）

### 3. pinia和vuex区别介绍一下

Vuex的优点

支持调试功能，如时间旅行和编辑
适用于大型、高复杂度的Vue.js项目

Vuex的缺点

从 Vue 3 开始，getter 的结果不会像计算属性那样缓存
Vuex 4有一些与类型安全相关的问题

Pinia的优点

完整的 TypeScript 支持：与在 Vuex 中添加 TypeScript 相比，添加 TypeScript 更容易
极其轻巧（体积约 1KB）
store 的 action 被调度为常规的函数调用，而不是使用 dispatch 方法或 MapAction 辅助函数，这在 Vuex 中很常见
支持多个Store
支持 Vue devtools、SSR 和 webpack 代码拆分

Pinia的缺点

不支持时间旅行和编辑等调试功能


### 4. vue中$set用法详细讲解

### 5. 详解require和import有什么区别介绍一下

> 其中require是commonjs的规范，而import是esmodule

> require 是运行时调用，import 是编译时调用
> require 是 AMD 规范引入方式;import 是 es6 的一个语法标准，如果要兼容浏览器的话必须转化成 es5 的语法
> require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用

### 6. forEach方法如何跳出循环？

抛出异常，但是实际上forEach无法正常跳出循环

使用try catch抛出异常

### 7. rpc框架了解么？问问你们app是如何通信的

### 8. app的登陆是如何做的，介绍一下？如何判断当前环境是否是app的环境呢？

这里是app那边会在本地store添加一个唯一标识，判断当前环境是否是app，比如epandian这个唯一标识

### 9. 中间件有了解吗，做过中间件吗？

### 10. 如何使用链式进行父子组件传入参数

## （二）百度基础建设平台一面

### 1. 请讲讲盒子模型有哪几种，他的区别是什么

有两种盒模型，分别是IE盒模型（border-box） 和 W3C标准盒模型（content-box）。
答：IE盒模型，它的元素width、height的值的计算方式包含了content、border和padding等属性的数值，也就是说它的基本宽高大小等于 content + padding + border。

再来说W3C标准盒模型，它的元素width，height的计算方式只包含内容了content 这一个属性的数值，不包含 border 和 padding 元素

### 2. 请问package.json 与package.lock.json版本不一致在安装过程中应该以那个依赖为主
还是以package.lock.json为主，除非你把这个配置文件删除了否则安装的依赖版本还是package.lock.json上的版本

### 3. 请说说vue的生命周期，并讲讲父子组件的生命周期是什么样的

1.vue生命周期
每个vue实例都有一个生命周期 一共分为八个阶段
创建前后： beforeCreate/created 渲染前后： beforeMount/mounted
更新前后： beforeUpdate/updated 销毁前后： beforeDestroy/destroyed

在created周期的时候 就可以访问到this了 也可以调用异步的方法去获取后台的数据
在mounted周期的时候 就能够访问到DOM结构 对dom结构进行一些增删改查的操作 因为在这个时候 dom结构已经渲染完成并挂载在vue实例上面了
当data变化时，会触发beforeUpdate和updated方法
在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。
2.父子组件的生命周期顺序
加载渲染过程：
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
子组件更新过程：父beforeUpdate->子beforeUpdate->子updated->父updated
父组件更新过程：父beforeUpdate->父updated
销毁过程：父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

### 4. 请说说promise对象与async await的区别

1.Promise是ES6，而async是ES7

2.Promise原来有规范的意义，Promise a，b，c，d 等规范，最终确定的是Promise a+ 规范

3.Promise链式操作，自己catch异常。async则要在函数内catch，好在现在catch成本较低

4.Promise有很多并行神器，比如Promise.all\Promise.race等。这些是async没法搞定的

5.Promise是显式的异步，而 Async/await 让你的代码看起来是同步的，你依然需要注意异步

6.Promise即使不支持es6，你依然可以用promise的库或polyfil，而async就很难做，当然也不是不能，成本会高很多

7.async functions 和Array.forEach等结合，很多tc39提案都在路上或者已经实现，处于上升期，而promise也就那样了


### 5. 请说说vue的双向绑定是什么样的（响应式）

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。
> vue3.0使用的是proxy拦截器实现的数据双向绑定

### 6. 请说说vue的响应式？？

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。
> vue3.0使用的是proxy拦截器实现的数据双向绑定


### 7. 如果你有一段代码发现推到远程了，你想重置掉远程代码，但是要保留本地代码，有哪些方法？

面试的时候我说的是，在你的开发分支拉出来一个分支，作为备份分支，

然后git reset --hard
git push origin dev


```
git pull 拉最新代码，提交之类，保证本地代码最新且无修改

git log  查看提交日志

git reset --hard  2ea5c6b311d8c45d62acdd6061a038950ea81b19  回退到要修改这个, --hard 会删除本地未提交的代码，回退回某一个版本，之间的代码不会在暂存区有记录

git reset 6df0437277dd01c29362c690b9448a3f0e72b1ce   再回退到它的上一次提交 ，暂存区会有这次回退之间的内容

git diff  可查看这些内容，可能需要去项目中解决冲突之类

git add . 有修改的话add下

git stash save 权限框     保存2ea5c6b311d8c45d62acdd6061a038950ea81b19提交的内容，至此需要修改的内容就存了下来。

 
git pull  拉下远端代码

git revert 6df0437277dd01c29362c690b9448a3f0e72b1ce 重置要修改的此次提交

git status 查看当前状态

git add .   修改错误后提交

git commit

git push 

git stash list    查看之前存下来的内容。

git stash apply stash@{0}  本地应用保存起来的修改，这样，重置的修改就在本地了
```


### 7. 请介绍一下你的项目吧，有哪些你觉得好的点

### 8. 项目重构为了什么，为什么要项目重构

> 因为之前的项目如果开发业务需求需要在多套代码上修改，重构之后就可以只在一套代码上修改就可以了

### 9. 请介绍一下回流重绘吧，有哪些注意的点

> 重绘（repaint）：比如元素的颜色，

> 回流（reflow）：回流一定会引起重绘，但是重绘不一定会引起回流，比如元素的高度宽度发生了变化，导致元素在文档流里发生了变化，导致整体布局进行了变化进行的元素重新绘制的问题

### 10. 请说明一下如何隐藏一个元素，有哪些方式，并且他们的差异点有哪些

方法有三个：
display:none; 这个属性用于定义建立布局时元素生成的显示框类型,而none属性可以让元素隐藏

visibility:hidden；这个属性是能见度的意思，使用hidden属性值后可以让元素“隐藏”

opacity:0; 这个属性是透明度的意思，为零即透明度为0，也可以做到隐藏元素的作用


虽然上面三个属性都可以让元素实现“隐藏”的效果但是有的是真的让元素隐藏起来了，但有的只是假的让元素元素“隐藏”起来了，
display:none; 可以直接让元素“消失”而且在页面中不会占元素隐藏前该占的位置

visibility:hidden；和 opacity:0; 虽然也能让元素实现“隐藏”效果，但是他们让元素隐藏后在页面上该占的位置是不会变的，

打个比喻display可以做到让一个元素真真正正的消失，不管他之前占了什么位置有多大，而另外两个更像是让元素隐身起来了，该有的属性是一点不变，只是看不见而已，

那么他们都能用于什么场景呢，比如你想在一个元素上面做一个按钮，让点击这个元素的时候实现按钮一样的效果，但是这个按钮很丑，而且影响客户视觉效果，这时候就可以使用opacity，visibility两个属性了，这样虽然按钮是隐藏的但是功能并不会消失


把[1,2,3,4,5,6,7,8,9,0]变成三个三个的二维数组

1. loadsh的chunk方法
2. 手写一个方法
```js
const convertTo =(arr,size)=>{
    let result=[];
    for(let i=0;i<arr.length;i+=size){
        result.push(arr.slice(i,i+size));
    }
    return result;
}
```


实现一个斐波那契数列
```js
const fib=(n)=>{
    if(n===0||n===1){
        return 1;
    }
    return fib(n-1)+fib(n-2);
}
```

算法优化：dp[i]=dp[i-1]+dp[i-2]
```js
const fib=(n){
    if(n<=1)return n;
    let fib=[0,1];
    for(let i=2;i<=n;i++){
        fib[i]=fib[i-1]+fib[i-2];
    }
    return fib[n];
}
```


## （三）美团一面

### 1. 请说说点击小程序到底发生了什么

> https://blog.csdn.net/W_yichenyang/article/details/119330999


### 2. 请说说小程序的线程会发生哪些操作

* 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View层用来渲染页面结构，App Service层用来逻辑处理、数据请求、接口调用，它们在两个线程（Webview）里运行。
* 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。

### 3. 如何判断一个链表是否有环


```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function detectCycle(head: ListNode | null): ListNode | null {
    if(!head) return null;
        // method: double pointer
    let fast = head;
    let slow = head;
    // fast step moves by two steps,slow moves by one
    while(fast && fast.next!=null && fast.next.next!=null){
        fast = fast.next.next
        slow = slow.next
        if(fast === slow){
            let index1 = fast
            let index2 = head
            while(index1!=index2){
                index1=index1.next
                index2=index2.next
            }
            return index1
        }
    }
    return null

};
```
### 4. 手写promise.all

```js
const PromiseAll = (iterator) => {
  const promises = Array.from(iterator); // 对传入的数据进行浅拷贝，确保有遍历器
  const len = promises.length; // 长度
  let resultLength = 0; // 每次执行成功+1,当等于长度时，说明所有数据都返回，则可以resolve
  let data = []; // 用来存放返回的数据数组
  return new Promise((resolve, reject) => {
    try{
    for (let i in promises) {
        Promise.resolve(promises[i]).then(res => {
          data[key] = res
          resultLength++
          if (len === resultLength){
            resolve(data)
          }
        },err=>{
            reject(err)
        })
    }
    }catch(e){
        reject(e)
    }
  });
};

const promise1 = Promise.resolve('promise1');
const promise2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 2000, 'promise2');
});
const promise3 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 1000, 'promise3');
});

PromiseAll([promise1, promise2, promise3]).then(function(values) {
    console.log(values);
});
```
## （四）推想医疗一面

### 手写promise.all
```ts
const PromiseAll = (iterator) => {
  const promises = Array.from(iterator); // 对传入的数据进行浅拷贝，确保有遍历器
  const len = promises.length; // 长度
  let resultLength = 0; // 每次执行成功+1,当等于长度时，说明所有数据都返回，则可以resolve
  let data = []; // 用来存放返回的数据数组
  return new Promise((resolve, reject) => {
    try{
    for (let i in promises) {
        Promise.resolve(promises[i]).then(res => {
          data[key] = res
          resultLength++
          if (len === resultLength){
            resolve(data)
          }
        },err=>{
            reject(err)
        })
    }
    }catch(e){
        reject(e)
    }
  });
};
```

### 1. 介绍一下type和interface的区别

> type 可以使用联合类型（|）和交叉类型（&）进行类型组合;而 interface 不支持联合类型和交叉类型。

> type 和 interface 是 TypeScript 中用于定义类型的关键字。
它们在定义对象类型、函数类型和类型组合等方面有一些区别。
type 更灵活，支持联合类型和交叉类型，并且可以使用类型别名来简化复杂的类型定义；
而 interface 支持继承和类的实现。你可以根据具体的使用场景选择合适的方式。

> 

### 2. 介绍一下你的项目

### 3. 请说说以下打印是什么样的
```ts
for(const i=0; i<6; i++){
    console.log(i);
}

for(let i=0; i<6; i++){
    console.log(i);
}

for(var i=0; i<6; i++){
    console.log(i);
}

for(var i=0; i<6; i++){
    setTimeout(()=>{
        console.log(i);
    },0)
}

// 如果想要打印0-5我应该如何修改
```

### 4. 请介绍一下settimeout与promise的打印顺序

* 由于settimeout进入的是宏任务队列，但是promise进入的是微任务队列，

* 执行顺序应该是先执行微任务队列中的方法，再执行宏任务队列中的方法

### 5. 请说说png和webp的区别吧

 
WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。


结论：建议原创表情尽量控制颜色数在 256 色以内，采用无损压缩性价比最高。
小于 256 色：以图标，图形，剪贴画为代表，最适合采用 WebP 无损压缩，精细度完美，体积大幅减少；
大于 256 色：以多数表情图，广告图为代表，最适合采用 WebP 有损压缩，选择较高压缩比（建议压缩质量为 100% ~ 75%）
远大于 256 色：以风景照，视频截图为代表，最适合采用 WebP 有损压缩，选择适中压缩比（建议压缩质量为 75% 以下）

### 6. 请介绍一下你在项目中做过哪些优化点呢

### 7. 介绍一下虚拟列表的实现思路吧

### 8. 聊聊你参与的项目的基础构建做了哪些吧？

### 9. 如果现在的需求是需要实现一个鼠标滚轮滚动的时候需要让页面左右滚动，应该如何实现

```html
<!DECTYPEhtml>
<html>
    <head><metacharset=‘utf-8’><title>onwheel-test</title></head>
    <body>
        <div id='out'style='width:500px;height:500px;overflow:auto'>
        <div id='inside'style='width:1000px;height:1000px;background-color:gray;overflow:auto'></div>
        </div>
        <script type='application/javascript'>
        var outDiv= document.getElementById('out');  
        outDiv.onwheel=function(event)
        {//禁止事件默认行为（此处禁止鼠标滚轮行为关联到"屏幕滚动条上下移动"行为）
            event.preventDefault();
            //设置鼠标滚轮滚动时屏幕滚动条的移动步长var step=50;
            if(event.deltaY<0){
                //向上滚动鼠标滚轮，屏幕滚动条左移
                this.scrollLeft-= step;
                }else{
                    //向下滚动鼠标滚轮，屏幕滚动条右移
                    this.scrollLeft+= step;
                }
        }
                    /**
            // 如果要手动设置滚动条在Y轴方向的位置可以直接设置scrollTop,例如：
            outDiv.scrollTop = 500;
            // 如果要手动设置滚动条在X、Y轴方向的位置可以使用函数scrollTo,例如设置X轴滚动100，Y轴滚动400：
            outDiv.scrollTo(100,400);
        **/
        </script>
    </body>
</html>
```

## （五）滴滴网约车小程序一面

### 1. 手写代码：
```js
// 数组打平
// arr = [1,2,3,[4,5,[6,[7]]]]
// level: 1
// [1,2,3,4,5,[6,[7]]]
// level: 2
// [1,2,3,4,5,6,[7]]
// level: >= 3
// [1,2,3,4,5,6,7]
let currentLevel = 1;
const resultArr = [];

function flat(arr, level) {
    let isPush = false;
    if (currentLevel <= level) {
        arr.forEach(arrItem => {
            if (Array.isArray(arrItem)) {
                isPush = true;
                flat(arrItem, level)
            } else {
                resultArr.push(arrItem)
            }
        });
    }
    if (isPush) {
        currentLevel++;
    }
    return resultArr
}
```
### 2. 正则匹配,邮箱匹配
```js
// reg
da@gmail.com

^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9_-]+\.[a-zA-Z]{2,}$

// ^ 匹配字符串的开头
// [a-zA-Z0-9._%+-]+ 匹配用户名，包括大小写字母、数字和一些特殊字符，例如 .、_、%、+、-
// @ 匹配 @ 符号
// [a-zA-Z0-9.-]+ 匹配域名，包括大小写字母、数字和一些特殊字符，例如 .、-
// \. 匹配 . 符号的转义字符
// [a-zA-Z]{2,} 匹配顶级域名，包括大小写字母，至少匹配两个字母
// $ 匹配字符串的结尾

string
"[{a,a},{b,b}]
string
a,a b,b

[[]
JSON.parse("string")
```
### 1. 请说说你了解的排序算法（介绍一下快速排序吧）

### 2. 请说说你了解的你认为不错的技术点

介绍了一下虚拟列表

### 3. 请说说ts你用了哪些，你怎么用的

### 4. 请说说js的array你用过哪些方法有什么用

> array的map，foreach，filiter，find

### 5. 请说说slice方法与splice方法有什么区别干什么的

* slice() 方法返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变

* splice() 方法通过移除或者替换已存在的元素和/或添加新元素就地改变一个数组的内容。其中该方法接收三个参数，分别是start，deleteCount：（一个整数，表示数组中要从 start 开始删除的元素数量。），item1, …, itemN：（从 start 开始要加入到数组中的元素。如果不指定任何元素，splice() 将只从数组中删除元素。）

* 要创建一个删除和/或替换部分内容而不改变原数组的新数组，请使用 toSpliced()。要访问数组的一部分而不修改它，参见 slice()。

### 6. 请介绍一下浏览器缓存有哪些，并且是什么（强制缓存，协商缓存）


浏览器有强制缓存与协商缓存两种方式，
关于协商缓存的标识code有：https://blog.csdn.net/testcs_dn/article/details/84833920

* 强制缓存
  
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)：

不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：

![强制缓存](../img/JavaScript/强制缓存.jpg)

控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

Cache-Control、Expires都是缓存到期时间，Cache-Control是相对值，Expires是绝对值，即再次发送请求时，如果时间没到期，强制缓存生效。

注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。

缺点：
缓存过期以后，服务器不管资源有没有变化，都会再次读取资源文件，并返给浏览器。

* 协商缓存
  
当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。

控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，
其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

* Last-Modified / If-Modified-Since
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件;

缺点：
如果资源被修改了，最后修改时间变了，但是内容没有变，会重新请求资源文件。

* Etag / If-None-Match
If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下


缺点：
实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源。


![1](https://img-blog.csdnimg.cn/20210328152529389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTAzNTY3,size_16,color_FFFFFF,t_70)

同时在浏览器取缓存的过程中，有两种取的逻辑，一种是从内存中取缓存，还有一种是从硬盘中取缓存；
> 浏览器读取缓存的顺序为memory –> disk –> 服务器请求。  
> 内存缓存(from memory cache)：内存缓存具有两个特点，分别是速度快和时间限制。

> 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。

### 7. 请说说taro与uniapp的区别和异同

* 底层实现不同，taro底层使用的是react而uniapp则是使用的是vue

### 8. 你能介绍一下taro最近几个版本有什么差别吗

### 9. js有几种类型分别是什么

* 基本类型： string，number，boolean，undefined，

* 引用类型：array，function，object

### 10. 介绍一下symbol吧，你在ts中怎么使用的

> 用于声明哪些不可变化的值

### 11. 介绍一下箭头函数和普通函数的区别

* 箭头函数不是匿名函数，不能使用new关键字
* 箭头函数不绑定arguments，取而代之用rest参数...解决
* 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
    箭头函数根本就没有this指针，是最外层代码块的this：也就是继承父执行的上下文中的this
* 箭头函数没有原型属性
* 箭头函数不能当做Generator函数,不能使用yield关键字

### 12. 那箭头函数可否使用apply，bind，call方法吗

可以，但是：由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this）
```js
// demo 代码
let obj={
    name:'lee',
    num:1,
    newObjFun(str,otherStr){
        if(otherStr){
            str=str+otherStr;
        }
        console.log(str+this.name);
    },
    arrowObjFun:(...b)=>{
        console.log('b',b);
        console.log('this',this)
    },
    commonFunc:function(b){
        console.log('arguments',arguments);
        console.log('this',this);
    },
    arrowAddNumFunc(n){
        let func=(n)=>{
            n+this.num;
        }
        let m={
            num:20
        }
        return func.call(m,n);
    }
}

// 箭头函数是匿名函数，不能作为构造函数，不能使用new
// let a=new obj.commonFuc([1,2,3,4,5],"zhangsan");// 普通函数可以

// this指向
obj.commonFunc([1,2,3,4,5],'zhangsan');
obj.arrowObjFun([1,2,3,4,5],"zhangsan");
let newPerson={
    name:'list'
}
let applyFunc=obj.newObjFun;
// apply和call绑定后会立刻执行
// apply只能穿入数组，但是call可以穿入任何类型的数据
applyFunc.apply(newPerson,['我是'])
applyFunc.call(newPerson,'我是**')
// 而bind不是绑定之后会立刻执行
let newApplyFunc=applyFunc.bind(obj,'我不是');
newApplyFunc('你猜猜');


// 如果是箭头函数
let arrowFunc=obj.arrowObjFun;
arrowFunc.apply(newPerson,['我是箭头函数','箭头函数'])
arrowFunc.call(newPerson,'我是**箭头函数','jiantou')
// 而bind不是绑定之后会立刻执行
let newarrowFunc=arrowFunc.bind(obj,'我不是*箭头函数');
newarrowFunc('你猜猜');

console.log(obj.arrowAddNumFunc(10));
console.log(obj.arrowObjFun.prototype)
console.log(obj.commonFunc.prototype)

```



### 13. 请说说小程序的底层设计是什么

https://blog.csdn.net/weixin_45658814/article/details/125655025

* 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View层用来渲染页面结构，App Service层用来逻辑处理、数据请求、接口调用，它们在两个线程（Webview）里运行。
* 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。
[小程序流程](./pic/xcx.png)
* 小程序的渲染层和逻辑层分别由2个线程管理：
```
（1）视图层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。

（2）逻辑层：采用 JsCore 线程运行JS脚本。

视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。
```
* 渲染流程
```
把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。
逻辑层和试图层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。

这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现。

Virtual DOM 大概是这么个过程：用 JS 对象模拟 DOM 树 -> 比较两棵虚拟 DOM 树的差异 -> 把差异应用到真正的 DOM 树上。

页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。

（1）在渲染层把 WXML 转化成对应的 JS 对象。
（2）在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。
（3）经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。

我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。
```

* 双线程模型设计的好处
```
双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。

为什么要这样设计呢，前面也提到了管控和安全，为了解决这些问题，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。

我们可以使用客户端系统的 JavaScript 引擎（iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境），这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口，这就是小程序双线程模型的由来。
```

* 性能优化
主要的优化策略可以归纳为三方面：

启动小程序方面：
> 分包加载
性能优化方式一：分包加载
采用分包加载时，小程序的代码包有两种：
一个“主包”，包含小程序启动时会马上打开的页面代码和相关资源。
多个“分包”，包含其余的代码和资源。
这样，小程序启动时，只需要先将主包下载完成，就可以立刻启动小程序，从而降低小程序代码包的下载时间。

> 控制代码包大小
性能优化方式二：控制代码包大小
精简代码，去掉不必要的WXML结构和未使用的WXSS。
减少在代码包中直接嵌入的资源文件。不是必须的可以放在服务器上。
压缩图片，使用适当的图片格式。


页面及页面层级方面
>合理使用setData调用，减少setData次数和数据量
性能优化方式三：合理使用setData调用，减少setData次数和数据量；

1、setData 工作原理

小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。

在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。

当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。

而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。


2、常见的 setData 操作错误

（1）频繁的去 setData

在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；

（2）每次 setData 都传递大量新数据

由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程

（3）后台态页面进行setData

当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。

数据通信方面：精简代码，降低WXML结构和JS代码的复杂性。
> js中提高数据更新速度
性能优化方式四：js中提高数据更新速度
多次setData合并成一次setData调用，不要过于频繁调用setData。
数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示，且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据。
与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其它字段下。
```js
onShow: function() {
    // 不要频繁调用setData
    this.setData({ a: 1 })
    this.setData({ b: 2 })
    // 绝大多数时候可优化为
    this.setData({ a: 1, b: 2 })
    // 将与界面无关的数据放在data外
    this.setData({myData: {a: '这个字符串在WXML中用到了',b: '这个字符串未在WXML中用到，且很长…’ }})
    // 可以优化为
    this.setData({'myData:{a': '这个字符串在WXML中用到了'})
    this._myData = {b: '这个字符串未在WXML中用到，且很长…'}
}
```
> wxml 中提高数据更新速度
性能优化方式五：wxml 中提高数据更新速度
去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数。
不要在节点的data前缀属性中放置过大的数据，因为事件绑定时需要传输target和currentTarget的dataset


### 14. 说说浏览器缓存吧，有哪些

浏览器有强制缓存与协商缓存两种方式，
关于协商缓存的标识code有：https://blog.csdn.net/testcs_dn/article/details/84833920

* 强制缓存
  
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)：

不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：

![强制缓存](../img/JavaScript/强制缓存.jpg)

控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

Cache-Control、Expires都是缓存到期时间，Cache-Control是相对值，Expires是绝对值，即再次发送请求时，如果时间没到期，强制缓存生效。

注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。

缺点：
缓存过期以后，服务器不管资源有没有变化，都会再次读取资源文件，并返给浏览器。

* 协商缓存
  
当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。

控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，
其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

* Last-Modified / If-Modified-Since
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件;

缺点：
如果资源被修改了，最后修改时间变了，但是内容没有变，会重新请求资源文件。

* Etag / If-None-Match
If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下


缺点：
实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源。


![1](https://img-blog.csdnimg.cn/20210328152529389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTAzNTY3,size_16,color_FFFFFF,t_70)

同时在浏览器取缓存的过程中，有两种取的逻辑，一种是从内存中取缓存，还有一种是从硬盘中取缓存；
> 浏览器读取缓存的顺序为memory –> disk –> 服务器请求。  
> 内存缓存(from memory cache)：内存缓存具有两个特点，分别是速度快和时间限制。

> 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。


## （六）去哪网一面

### 1.看看这个如何打印
```js
A{
    // 新的a的对象
}
A.prototype.x=10;
const a1=new A();
A.prototype={x:20,y:30};
const a2=new A();
console.log(a1.x);
console.log(a1.y);
console.log(a2.x);
console.log(a2.y);
```

### 2.看看这个css样式是什么样的

```html
<div class="lightblue">
    <div class="drakblue">
        <p>drakblue</p>
    </div>
</div>

<div class="drakblue">
    <div class="lightblue">
        <p>drakblue</p>
    </div>
</div>

	<style>

/** 这里的颜色就是那个标签是那个颜色 */
.lightblue{
    background-color:lightblue;
}
.drakblue{
    background-color:blue;
}


/** 但是一旦出现了标签选择器，那么就会是使用最近（最后声明的）的这个标签属性，也就是drakblue p这个属性 */
.lightblue p{
    background-color:lightblue;
}
.drakblue p{
    background-color:blue;
}
	</style>
```

### 3.看看下列代码那里有问题
```js
const axios = require('@qnpm/qaxios');
const URL = 'http://xxxx.xx.com/getList';

module.exports = function (req, res, next) {
    axios(URL, {
        // 接口请求的过期时间太短了只有60毫秒
        timeout: 60,
        data: Object.assign({}, {
            extInfo: req.extInfo || ''
        }),
        responseDataType: 'string'
    }).then(function (res) {
        const { data } = res;
        // {
        //     code:,
        //     data:"134",
        // }
        // 问题：JSON.parse校验入参数string，“asd”
        // “[{}]”,"[]","dasd"
        // 1:String
        // 2:[]
        // 
        data = JSON.parse(data);
        const resultNo = data.codeNo + 32;
        res.send('200', resultNo)
    }).catch(function (err) {
        res.send(500, 'error')
    });
};


const axios = require('@qnpm/qaxios');
const URL = 'http://xxxx.xx.com/getList';

module.exports = function (req, res, next) {
    axios(URL, {
        timeout: 60,
        data: Object.assign({}, {
            extInfo: req.extInfo || ''
        }),
        responseDataType: 'string'
    }).then(function (res) {
        const { data } = res;
        data = JSON.parse(data);
        const resultNo = data.codeNo + 32;
        res.send('200', resultNo)
    }).catch(function (err) {
        res.send(500, 'error')
    });
};
```

## （七）百度文库一面

### 1.说一下eventloop事件循环


事件循环JavaScript中所有的任务分为同步任务与异步任务，同步任务，顾名思义就是立即执行的任务，它一般是直接进入到主线程中执行。而我们的异步任务则是进入任务队列等待主线程中的任务执行完再执行。
任务队列是一个事件的队列，表示相关的异步任务可以进入执行栈了。
主线程读取任务队列就是读取里面有哪些事件。队列是一种「先进先出」的数据结构。上面我们说到异步任务又可以分为宏任务与微任务，所以任务队列也可以分为「宏任务队列」与「微任务队列」

> Macrotask Queue：进行比较大型的工作，常见的有「setTimeout，setInterval」，用户交互操作，UI渲染等； 
> Microtask Queue：进行较小的工作，常见的有Promise，Process.nextTick； 

执行顺序：
1. 同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。
2. 系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列，并且每个任务会对应一个回调函数进行处理。
3. 这里异步任务分为宏任务与微任务，宏任务进入到宏任务队列，微任务进入到微任务队列。
4. 执行任务队列中的任务具体是在执行栈中完成的，当主线程中的任务全部执行完毕后，去读取微任务队列，如果有微任务就会全部执行，然后再去读取宏任务队列
5. 上述过程会不断的重复进行，也就是我们常说的「事件循环（Event-Loop）」。

事件循环，包含调用栈，微任务队列，宏任务队列

微任务队列与宏任务队列同时出现的时候，先执行微任务再执行宏任务


### 2.说一下这个代码的打印

```js
// 先是执行微任务，再是宏任务
var r=new Promise(function(resolve,reject){
    var begin=Date.now();
    while(Date.now()-begin<1000){
        console.log("a");
        resolve(); // 这里执行应该会打印一个undefined
    }
})

setTimeout(()=>{
    console.log("b")
},0);

r.then(()=>{
    console.log("c");
})

console.log("d");

// 打印a,d,c,b

// 正确答案：a,d,c,undefined,b
// 因为在new Promise体中代码执行和调用堆栈顺序一致
// 然后setTimeout会慢于Promise，因为宏任务慢于微任务所以b在c的后面，但是
// 
```

### 3.说一下promiseall你的使用场景有哪些，简单介绍一下

* 同时请求多个接口，然后等所有接口拿到对应的数据，再去请求对应的接口

* 同时请求多个接口然后，将这些接口返回进行本地缓存

### 4.实现一个promiseMyall
```js
// 手动实现一个promiseMyrace
Promise.race = (promises)=> {
  return new Promise((resolve, reject)=> {
    for (let i = 0; i < promises.length; i++) {
      promises[i].then(resolve, reject);
    }
  });
};

// 手动实现一个promiseMyall
const romiseMyall = (arr) => {
    const tempArr = Array.from(arr);
    const resultArr = [];
    let sumIndex = 0;
    return new Promise((resolve, reject) => {
        tempArr.forEach((item, index) => {
            if (item) {
                // 解析的操作
                Promise.resolve(item).then(res => {
                    result[i] = res;
                    sumIndex++;
                    if (sumIndex === tempArr.length) {
                        resolve(result);
                    }
                }, err => {
                    reject(err);
                })
                };

            }
        })
    });
}
```
### 5.模块化commonjs 和esmodle介绍一下吧

* commonjs--(require/export)
> commonjs也叫cjs,在node中每一个js文件都是一个单独的模块,这个模块中包含CommonJS的规范的核心变量: exports， module.exports, require,exports和module.exports可以负责对模块中的内容进行导出。require函数可以帮助我们导入其他模块（自定义模块，系统模块，第三方库）。
```ts
// exports和module.exports之间的区别
1、每一个模块都是一个module模块，也就是module。
2、node中导出的不是exports,而是module.exports。
3、也就是说exports和module.exports本来指向的是同一个引
用地址，但是真正导入的是module.exports,所以当我们手动更改
exports = {},这样就会报错，我们只能改属性。
```

```ts
// require的引入规则
1、如果存在核心模块（path, url）等，可以直接引入即可。
2、如果使用./x或者../x以及/x等来引入的话，首先会先找到相应目录下面的x文件，没有找x.js,x.json,x.node,还没有找到就去找./x/index.js, ./x/index.json,./x/index.node文件，如果都不存在，则报错。
3、如果为第三方库，则按照类似于这种规则进行查找。
/*
[
  'D:\\web前端开发\\javascript高级\\二十五\\一、require的查找规则\\node_modules',
  'D:\\web前端开发\\javascript高级\\二十五\\node_modules',
  'D:\\web前端开发\\javascript高级\\node_modules',
  'D:\\web前端开发\\node_modules',
  'D:\\node_modules'
]
*/
4、require在进行加载模块的时候，后执行一遍里面的代码，但是当该模块中多次引入该模块，则require只会执行一次，因为存在缓存(module中存在loaded函数)。

```

```ts
// commonjs的缺点
1、commonjs加载是同步的，所以必须等到相应的模块加载完毕，
在会执行后续代码，在node环境中使用，没有什么问题，因为node
的js文件都是本地的。
2、如果要是在浏览器中执行，因为浏览器中都是从远程服务器上请
求到的，同步势必会引起一些卡顿。
3、但是在webpack中可以使用commonjs是因为webpack可以对其
进行打包处理。

```


* esmodule--（import/export）


```js
// 基本使用
1、在浏览器上使用esmodule必须加上type = 'module'
2、必须需要开启服务器(live server)
3、在js中引入文件的时候，必须要加上'.js'.
```


```js
// 三种导出方式
//1、第一种导出方式
export const name = 'dl'
export const age = 20
//2、第二种导出方式（集体导出）
const name = '董礼'
const age = 20
function sum(num1, num2) {
	return num1 + num2
}
export {  //注意：这里不是对象，这里必须这样写
  name, 
  age,
  sum
}
//三、第三种导出方式，起别名
const name = 'dl'
const age = 20
export {
	name as FName,
	age as FAge
}

//三种导入方式
//第一种导入方式
import {
	name,
	age,
	sum
} from './foo.js'
//二、第二种导入方式，起别名
import { name as Fname, age as FAage } from './foo.js'
//三、第三种导入方式
import * as foo from './foo.js'


//default默认导出
const foo = 'foo value'
export default foo

//默认导出二
export {
  name,
  age,
  foo as default
} 


//import函数
//为什么要有import函数
因为在使用import xx from 'xx'的时候，不能将其写在逻辑代码中。
if(true) {
	import xx from 'xxx'
}
esmodule在被js引擎解析的时候，就必须知道他的依赖关系，但是
一些请款下，我们确确实实希望动态来加载一个模块。所以我们可以
使用import()函数来实现异步加载，浏览器调用另一个线程进行下
载，然后不会阻塞js线程。import()函数返回的是一个promise
函数，所以在拿到结果的时候需要使用.then来获取相应的值，
import.meta:es11中新增的一个属性，可以拿到当前文件的url
地址。

```

* 其他总结
> require 是运行时调用，import 是编译时调用
> require 是 AMD 规范引入方式;import 是 es6 的一个语法标准，如果要兼容浏览器的话必须转化成 es5 的语法
> require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用

cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用
cjs 模块是运行时加载，esm 是编译时加载


* 两种的区别
```js
4.1、commonjs是对模块的浅拷贝，esmodule是对模块的引用。
4.2、import的接口是read-only（只读状态），不能修改其变量
值。即不能修改变量的指针指向，但是可以改变变量内部的指针指
向，可以对commonjs对重新赋值，但是esmodule赋值会编译报错。
```



// 
### 6.链表翻转
```js
//1 ，2，3，4，5
//arr数组去储存当前value，利用数组方法
// {
//     value:1,
//     next:{
//         value:2,
//         next:{

//         }
//     }
// }

function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val)
    this.next = (next === undefined ? null : next)
}


function reverseList(head) {
    // 翻转
    if (head === null) {
        return '';
    }
    let result=null;
    let current=head;
    while (current) {
        const nextResult = current.next;
        current.next=result;
        console.log(head,'head')
        result = current;
        current=nextResult;
    }
    return result;
}

function main() {
    let head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    let result = reverseList(head);
    let list = '';
    while (result != null) {
        list += result.val + (result.next ? "->" : "");
        result = result.next;
    }
    console.log(list);
}
main();
```

### 7.百度的性能监控与报表

mdn:https://developer.mozilla.org/zh-CN/docs/Web/API/Performance_API/Navigation_timing

有三种方法：
> 1. PerformanceTiming
> 底层使用的是：window.performance.timing这里面的参数,但是这里的时间参数精度是毫秒级别

> 2. PerformformanceNavigationTiming
> 如果想要更加精准的时间级别，需要使用到PerformformanceNavigationTiming这个参数，其中时间参数的精度是微秒，拿到这个对象的方法是window.performance.getEntries();

> 3. PerformanceObserver
> 获取更多性能指标：PerformanceObserver

```js
connectEnd
: 
1690786434604
connectStart
: 
1690786434325
domComplete
: 
1690786438335
domContentLoadedEventEnd
: 
1690786436693
domContentLoadedEventStart
: 
1690786436683
domInteractive
: 
1690786435792
domLoading
: 
1690786435432
domainLookupEnd
: 
1690786434320
domainLookupStart
: 
1690786434320
fetchStart
: 
1690786434320
loadEventEnd
: 
1690786438339
loadEventStart
: 
1690786438335
navigationStart
: 
1690786434316
redirectEnd
: 
0
redirectStart
: 
0
requestStart
: 
1690786434604
responseEnd
: 
1690786435674
responseStart
: 
1690786435429
secureConnectionStart
: 
1690786434325
unloadEventEnd
: 
0
unloadEventStart
: 
0
```


### 8.百度小程序使用的底层

<!-- okam这个框架，基于原生使用的是vue底层进行封装的 -->


## （八）高途教育-高中在线教育
### 1.介绍一下你的项目吧，

### 2.说一下浏览器的缓存有哪些

* 强制缓存/协商缓存


### 3.介绍一下强制缓存的cache-control的no-catch与no-store

* no-store
永远都不要在客户端存储资源，永远都去原始服务器去获取资源。

* no-cache
可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的协商缓存。

### 4.说一下你的项目如果是存在登陆出错与弱网的时候应该如何解决



### 5.介绍一下px/rem/em的区别和差异

对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。

1. em
是一个相对单位。相对于当前对象内文本的font-size，如果当前文本的字体尺寸没有设置，则相对于浏览器的默认字体尺寸。即1em=16px

2. rem
是一个相对单位。是相对HTML根元素。

像素（px）：用于元素的边框或定位。

em/rem：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰


### 6.说说script标签的differ和sync有什么用

> differ:推迟执行脚本 HTML4.01为script标签提供了一个defer属性，这个脚本表示该脚本在执行的时候不会改变页面结构，因此，这个脚本会在整个页面解析完成之后再执行，再script上加上defer属性会告诉浏览器，当遇到这个脚本的时候立即去下载这个脚本，但是执行会在页面解析完成后进行。


> 在上面的例子中，虽然script在head标签中，但是只会下载，不会执行，在解析完之后才会执行，并且会根据他们出现的顺序依次执行，并且两者会在DOMContentloaded事件之前执行。

> async:异步执行脚本 HTML5为script标签提供了async属性，梳理方式与defer大致相同，都不会导致页面渲染时间延迟。

```js
 <html>
     <head>
         <title>...</title>
         <script async src="example1"></script>
         <script async src="example2"></script>
     </head>
     <body>
         ....
     </body>
 </html>
```

> 当解析到有async的script标签的时候，会通知浏览器立即下载该脚本，但是执行是异步的（个人理解的异步执行是在js引擎空闲的时候执行，宏观上是跟页面渲染同步的，微观上是异步交替执行的），而且执行的时候也不会根据它们的的出现顺序来执行，例如上面的例子，可能example2先于example1执行，也可能example1先于example2执行。但是脚本都会在页面的load事件前执行，但可能会在DOMContentloaded之前或之后。

总结：defer和async都不会延迟页面的渲染时间，在浏览器解析到有defer或者async的script标签时候都会立即下载，但是有defer的script标签会在解析结束后执行，async会异步执行。



### 7.说说浏览器攻击的csrf与依赖注入攻击如何防范


一、XSS(Cross Site Scripting)跨站JS脚本攻击，如何防范？

* 针对接口进行 XSS攻击，即把js脚本或者带恶意js脚本的html标签，作为GET或者POST参数提交到服务器，然后服务器解释并响应
* 防范方式：
* 1）提交数据前前端要做数据校验，对用户输入的信息(js代码及dom节点)进行过滤。
* 2）对重要的cookie设置为httponly（服务器端可设置此字段），客户端就没有操作此cookie的权限。
* 3）服务器端也要数据合法性校验
针对DOM本身进行 XSS攻击，如果本身页面代码中使用了window.eval来执行代码。eval本身会把一段字符串变成可执行的js代码，这是非常危险的。还有拼接html字符串后直接显示DOM时也会遇到同样的问题。防范方式：尽量避免使用eval，拼接html字符串时应校验字符串的合法性，过滤非法元素节点与属性节点,如iframe,script标签，onerror事件, style, src, href等。
 
* 可能产生危害：泄露了个人的cookie信息，身份认证被套取后，被用作非法用途

* 非法字符过滤可以使用第三方的过滤库如：HTMLParser.js及he.js

二、CSRF(Cross-site request forgery)跨站请求(GET和POST)伪造攻击，如何防范？ 

* 由于浏览器一般都是可同时打开多标签的。举个例了，现浏览器同时打开了两个标签，一个是已被合法登录并保持登录状态的网站A，另外一个是已被欺骗打开的含恶意代码的网站B（不一定是来源于非法网站，也可能藏在各大合法论坛上的一些非法链接被你打开了），则可以通过在恶意网站B上静态或者动态创建img,script等标签发起GET或者POST请求，发出的恶意请求是身份认证后的，这就构成CSRF攻击了。将其src属性指向发起对A网站的接口请求（如一个GET请求：api.a.com/blog/del?id=1）。通过标签的方式发起的请求不受同源策略的限制。

* 可能产生危害：模拟表单提交盗取用户资金，篡改目标网站上的用户数据，盗取用户隐私数据

* 防范方式：
* 1）后端接口要对接口请求来源如（* Referer:）字段进行合法校验。
* 2）添加token，带token请求。


三、SQL注入，攻击如何防范？

1. 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双"-"进行转换等。

2. 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。

3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

4. 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。

5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装

6. sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky,网站平台就有亿思网站安全平台检测工具。


四、接口访刷问题，前端如何与后端配合？

* 在IT行业混得有一点资历的人估计都会遇到过接口被刷的情况了。如：听说搞某某活动，大奖瞬间被刷走。某某营销活动，奖品瞬间被抢光了。某某平台，短信验证码几天被刷到欠费。

认真去查查记录，发现这些行为都是人家用机器写程序自动刷你接口的。现在还有卡商有各种短信接码平台，专业批量接发验证码的。

如何能更好的做接口防刷：

1. 发送请求之前前端这边要做人机识别。（如微信的静默授权返回一次唯一码，小程序的wx.login接口返回的code，可供后端二次验证，还有发送短信验证码前要手动先输入验证码，或者使用拖动方块填充缺块那种人机识明系统）

2. 接口传参要带加密签名。


### 8.你对cookie的http-only有什么了解吗

> http-only能够有效地防止XSS攻击。

> httpOnly是包含在http返回头Set-Cookie里面的一个附加的flag，所以它是后端服务器对cookie设置的一个附加的属性，在生成cookie时使用HttpOnly标志有助于减轻客户端脚本访问受保护cookie的风险（如果浏览器支持的话）,通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。

> 


### 9.说说map和weakmap吧

WeakMap
1:什么是WeakMap
WeakMap是ES6中新增的一种集合类型，叫做'弱映射'。它和Map是兄弟关系，与Map的区别在于这个弱字，API还是Map那套API

什么是弱引用
是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问的，并因此可能在任何时刻被回收。


Map和WeakMap区别
Map的键可以是任意类型，WeakMap只接受对象作为键，不接受其它类型的值作为键
Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键；WeakMap的键是弱引用，键所指向的对象是可以被垃圾回收，此时键是无效的。
Map可以被遍历，WeakMap不能被遍历


强引用和弱引用
1 .强引用：将对象保留在内存中的引用
```js
let cat={name:"cat"}
 const pets=[cat]
// cat=null:对原来没影响，值还是原来的
//cat.name="mouse" 原来数组的值变了,变为mosue
同理 cat.name=null也是会变得

let cat={name:"cat",likes:{name:"123",age:10}}
const pets=[cat]
cat.likes=null
//里面嵌套的就是会变成null，有改变了
console.log(pets)
```
6 .垃圾回收机制将不会考虑这个引用。只要所引用的对象的其他引用被清除，垃圾回收机制就会释放改对象所占用的内存。一旦不需要，weakMap里面的键名对象和所对应的键值对会自动消失，不需要手动删除引用
7 .如果你想要往一个对象上添加数据，又不像干扰垃圾回收机制，就可以使用weakMap

WeakMap使用场景-他的键对应的对象，可能会在未来消失，weakMap有助于防止内存泄漏
1 .在DOM对象上保存相关数据.当dom删除的时候，相关联的对象会自动删除，不需要自己管理
2 .数据缓存：当我们需要关联对象和数据。在不修改原有对象的情况下存储某些属性或者根据对象存储一些计算值。又不想管这些对象的死活，非常适合使用这个。
3 .实现私有变量


### 10.说说useEffect的几种情况吧


### 11.说说Webpack文件指纹和JS文件采用[chunkhash]文件指纹策略，CSS文件采用[contenthash]文件指纹策略

> Hash

和整个项目的构建相关，只要项目文件有修改，整个项目构建的hash值就会更改，并且全部文件都共用相同的hash值

> Chunkhash

和webpack打包的chunk有关，不同的entyr会生成不同的Chunkhash值（一个页面的值改变了并不会影响另一个页面，js文件一般采用此方法），chunkhash和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。

> Contenthash

根据文件内容来定义hash，文件内容不变，则contenthash不变（css文件一般采用此方法）。

比如文件index.css被index.js引用了，所以共用相同的chunkhash值。但是这样子有个问题，如果index.js更改了代码，css文件就算内容没有任何改变，由于是该模块发生了改变，导致css文件会重复构建。
这个时候，我们可以使用extra-text-webpack-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建。


### 12.说说computed与watch还有metod有什么区别和差异

一、 计算属性（computed）

1.变量不在 data中定义，而是定义在computed中，写法跟写方法一样，有返回值。函数名直接在页面模板中渲染，不加小括号 。

2.根据传入的变量的变化 进行结果的更新。

3.计算属性基于响应式依赖进行缓存。如其中的任意一个值未发生变化，它调用的就是上一次 计算缓存的数据，因此提高了程序的性能。而methods中每调用一次就会重新计算　一次，为了进行不必要的资源消耗，选择用计算属性。

二、监听属性（watch）

计算属性 和属性监听的区别：

1.计算属性变量在computed中定义，属性监听在data中定义。

2.计算属性是声明式的描述一个值依赖了其他值，依赖的值改变后重新计算结果更新DOM。属性监听的是定义的变量，当定义的值发生变化时，执行相对应的函数。

三、方法（metod）

在方法中调用时机和computed与watch不一样，方法中是主动触发调起而在监听和计算属性则不是

### 13.说说你觉得一个产品的数据分析应该如何做，你了解过你的产品的收益是多少吗？比如pv/uv


### 14.聊聊你知道的垃圾回收吧

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

### 15.你提到了标记的垃圾回收，说说什么是标记法的垃圾回收呢？


1）标记清除

标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

2）引用计数

另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。
这种方法会引起循环引用的问题：例如：obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。


### 16.聊聊你觉得如果要学习一个你没有接触过的框架，你应该如何学习呢？

1. 看github，看油管的教学视频
2. 自己写一个小demo，
3. 遇到问题及时去查


### 17.看你之前喜欢可视化，你现在如果还是去做可视化相关的内容吗


### 18.你知道srcipt标签的defer和async吗

```js
<script>标签

阻塞html parsing
脚本将会立即被请求和执行
脚本执行完毕后, 继续进行html parsing
<script async>标签

脚本的请求将会和html parsing 并行执行
脚本请求完成后将会立即执行(此时可能html parsing并未完成)
当此脚本与其他脚本无关时使用
<script defer>标签

脚本的请求将会和html parsing 并行执行
当html parsing 结束后才会执行脚本
如果有多个<script defer>标签, 它们将按照它们出现的顺序依次执行
注意

如果<script>标签中没有src属性, async和defer将会被忽略
```

### 19.说说vue的响应式如何实现的，优势是什么？

vue2:是使用的object.defineProperty(),
vue3:proxy拦截器

proxy拦截器可以实现vue2不能监听数组变化的逻辑，同时不需要深度监听对象变化


### 20.vue2如何实现的数组变化进行的监听？

由 Vue2监测数据变化原理 这篇文章可知，Object.defineProperty 有两个缺陷：

无法监测对象属性的新增和删除
无法监测数组数据变化

总结
Vue2 中，Object.defineProperty 无法监测数组的变化
因此，Vue2 对7个常见的数组操作方法进行了包装，通过这7种方法操作的数组，都可以被 Vue 监测到


### 21.说说如果需要兼容低版本浏览器有哪些思路，如果浏览器不支持webp我应该如何兼容让其图片渲染出来

* 首先，我想到的是用js判断是否支持webp格式图片，支持的就用webp，不支持的用原图。上代码：

* 方案二，根据header信息判断浏览器是否支持webp


### 22.如何实现深拷贝，如何实现浅拷贝

关键区分点就是是否开辟了新地址作为储存路径，深拷贝就是开辟了一个新的储存地址，而浅拷贝则不是

1. loadash
2. JSON.parse(JSON.strity()); // Date类型和function类型会丢失
3. 手写深拷贝


## （九）美团医疗-一面

### 1.看代码输出
```js
const first = () => (new Promise((resolve, reject) => {
    console.log(3);
    let p = new Promise((resolve, reject) => {
        console.log(7);
        setTimeout(() => {
            console.log(5);
            //
            resolve(6);
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) => {
        console.log(arg);
    });

}));

first().then((arg) => {
    console.log(arg);
});
console.log(4);

// 3,7,4,1,2,undefined,5 （6不能输出)
// 3,7,4 是因为3，7都是在promise对象的内部执行不是then或者catch语句中，也就是同在调用栈中执行
//1，2是因为进入了微任务队列中进行打印
//在setTimeout中的resolve是找不到的，所以6无法正常打印，但是微任务队列优于宏任务队列所以undefined在5的前面5


//374125
// 调用p 
```

### 2.防抖函数编写
```js
// 防抖
const debFunction = (func, time) => {
    let timer = null;
    return () => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            func();
        }, time);
    };
};
```

### 3.你说说webpack的运行逻辑


### 4.说说箭头函数吧


### 5. 箭头函数可否使用call、apply、bind

### 6.说说箭头函数的this指针是在什么时候绑定的，function a呢


### 7.说说你了解的基础建设的相关内容吧


## （十）umu技术


### 线上做题

https://m.umu.cn/session/quiz/result?sessionId=42313155&sKey=898a7a9b524a5cf81fbfe5424347f2c1&from=session

### 0.看代码

```js
var obj={a:1}
function test(obj) {
    obj={a:2}
}
test(obj)
alert(obj.a)

// 输出的是1


// 请实现红绿灯效果，使用console 输出 "红"、"绿"、"黄"示意，等待时间分别为 3s、2s、1s。
// （效果为，1-3 秒每秒打印一次“红”，4-5 秒每秒打印一次 “绿”，第6秒打印一次“黄”。一直重复执行）

const timeConsole=(str,time)=setTimeout(()=>{
    console.log(str)
},time)

setInterval(()=>{
    timeConsole('红',3000);
    timeConsole('绿',2000);
    timeConsole('黄',1000);
})

const myIsNaN=(input)=>{
    if(input){
        let params=Number(input);
        return params!==input;
    }else{
        return false;
    }
}

const sumFun=(num1,num2)=>{
    

}
```

### 1. 看代码说输出
```js
//1
var obj={
    fo(){
        console.log(this);
    }
}
// 隐式调用
obj.fo(); // 这里指向obj这个对象

//2 
var obj={
    fo(){
        console.log(this);
    }
}

// 隐式丢失
var fo=obj.fo;
fo(); // 由于this执行是在执行的时候才会生成，所以这里的指向的是window

//3
var obj={
    fo:()=>{
        console.log(this);
    }
}

obj.fo(); //这个也指向obj这个对象
```


### 2.0.1+0.2===0.3输出什么，为什么？，如果让你手写一个判断的方法你会怎么写


### 3. 看代码说输出

```js
var obj={
    a:{
        b:'bbb'
    }
}

var obj2=Object.assign({},obj);
obj2.a.b='11111';
console.log(obj.a.b);

```

### 4.深拷贝如何写，但是如果有一个对象循环依赖如何解决这个问题呢？

```js
var obj = {
	a: {
		b: {
			c: obj
		}
	}
}

var obj = {
	a: {
		b: {
			c: obj.a.b
		}
	}
}
```


### 5.看看这几个obj输出是不是一样的

```js
var obj1 = {} 
var obj2 =  new Object(null) 
var obj3 = Object.create(null)
```

### 6. 三栏布局

一、浮动布局 Float

左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应。这种布局方式，dom结构必须是先写浮动部分，然后再写中间块，否则右浮动块会掉到下一行。
```html
<style>
        .left{
            float: left;
        }
        .right{
            float: right;
        }
        .center{
            margin: 0 200px;
        }
    </style>
</head>
<body>
    <header>header</header>
    <div class="left">Left</div>
    <div class="right">Right</div>
    <!-- 中心布局必须在最后加载 -->
    <div class="center">Center</div>
    <footer>footer</footer>
</body>
```

浮动布局方式比较简单，兼容性好，但是存在局限性：浮动元素脱离文档流，要做清除浮动操作， 这个处理不好的话，会带来很多问题，比如父容器高度塌陷等问题；而且由于主要内容无法最先加载，当页面内容较多时会影响用户体验。

二、定位布局 Position
```html
<style>
        .left,
        .right{
            position: absolute;
            top: 50px;
        }
        .left{
            left: 0;
        }
        .right{
            right: 0;
        }
        .center{
            margin: 0 200px;
        }
    </style>
</head>
<body>
    <header>header</header>
    <!-- 因为不再使用浮动布局，所以可以将中间布局内容提前，以便于优先加载主要内容 -->
    <div class="center">Center</div>
    <div class="left">Left</div>
    <div class="right">Right</div>
    <footer>footer</footer>
</body>
```
三、圣杯布局 Holy Grail Layout
```html
<style>
        body{
            margin: 0 200px;
        }
        div{
            float: left;
        }
        .left{
            margin-left: -100%;
            position: relative;
            left: -200px;
        }
        .right{
            margin-right: -200px;
        }
        .center{
            width: 100%;
        }
    </style>
<body>
    <header>header</header>
    <!-- 中间布局需要优先设置 -->
    <div class="center">Main</div>
    <div class="left">Left</div>
    <div class="right">Right</div>
    <footer>footer</footer>
</body>
```

四、双飞翼布局
双飞翼布局类似于圣杯布局，不过圣杯布局利用 wrapper 的 padding 来保留左右位置的，而双飞翼布局利用 center 的 margin 来实现的。只要center 外边距的宽度只要恰好等于 left 和 right，这样在视觉上看起来 center 和 left、right 就是三个独立的板块。
```html
<style>
        body>div{
            float: left;
        }
        .left{
            margin-left: -100%;
        }
        .right{
            margin-left: -200px;
        }
        .center{
            width: 100%;
        }
        .inner {
            margin: 0 200px;
        }
    </style>
<body>
    <header>header</header>
    <!-- 中间布局需要优先设置 -->
    <div class="center">
    <!-- 多设置一层div嵌套 -->
        <div class="inner">
            Center
        </div>
    </div>
    <div class="left">Left</div>
    <div class="right">Right</div>
    <footer>footer</footer>
</body>
```

五、弹性布局 Flex
 给父级设置display：flex，可以通过Flex布局来实现三栏布局的效果：

六、表格布局 Table 
给父级设置display：table，然后让子元素都是 display: table-cell，就可以实现三栏布局：

```html
<style>
        .container {
            display: table;
            width: 100%;
        }
 
        .container>div {
            display: table-cell;
        }
    </style>
<body>
    <header>header</header>
    <div class="container">
        <div class="left">Left</div>
        <div class="center">Center</div>
        <div class="right">Right</div>
    </div>
    <footer>footer</footer>
</body>
```
Table布局具有非常好的兼容性，当内容溢出时会自动撑开父元素；但是Table布局不支持center部分前置，无法设置栏间距，而且对SEO（Search Engine Optimization，搜索引擎优化）不友好。

七、网格布局 Grid
网格布局（Grid）是最新的 CSS 布局方案。它将网页划分成一个个网格，可以任意组合不同的网格，从而就能做出各种各样的布局。新增的CSS网格布局模块(CSS Grid Layout Module)提供了带有行和列的基于网格的布局系统,它使网页设计变得更加容易,而无需使用浮动和定位。
```html
<style>
        .container {
            display: grid;
            width: 100%;
            grid-template-columns: 200px auto 200px;
        }
    </style>
<body>
    <header>header</header>
    <div class="container">
        <div class="left">Left</div>
        <div class="center">Center</div>
        <div class="right">Right</div>
    </div>
    <footer>footer</footer>
</body>
```

八、calc函数布局

  calc函数可以通过计算像素动态生成宽度，给中间盒子的宽度设置calc就可以实现三栏布局。但是每个元素都需要设置浮动：
```html
  <style>
        .container{
            width: 100%;
        }
        .container>div {
            float: left;
        }
        .center{
            width: calc(100% - 400px);
        }
    </style>
</head>
<body>
    <header>header</header>
    <div class="container">
        <div class="left">Left</div>
        <div class="center">Center</div>
        <div class="right">Right</div>
    </div>
    <footer>footer</footer>
</body>
```
### 6. css实现一段不够一行时居中显示，多于一行时两端对齐

```html
1 <div class="text"><p>2. Tap WiFi Key Search</p></div>
2 <div class="text"><p>3. Please wait 5-15 secs in your Wi-Fi Settings for WiFi list to load. Tap on hotspots with "WiFi Master Key WiFi Key Search " to connect</p></div>
<style>
.text{
    width: 285px;
    margin: auto;
    padding: 8px;
    background-color: #d8d8d8;
    text-align: center;
    font-size: 15px;
    color: #333;
}
.text p{
    display: inline-block;
    margin: auto;
    text-align: justify;
}
</style>
```

可以让p text-align:justify;display:inline-block;给p加一个外层的框div，这个外层的框text-align:center;
这样p随着文字的宽度变化，并且p在div中居中，当p宽度不够一行的时候就看起来是居中的



## （十一）高途教育业务线-小学生业务

### 1.分享一下你做的内容有哪些


### 2.说说你聊几的ts的类型定义，比如type或者interface


### 3.你对namespace了解吗，介绍一下

> 在实际语法上namespace等同于module

> namespace主要用于解决命名冲突，他会在全局生成一个对象，在namepace内部的类都要通过这个对象访问
> namespance是跨文件的，在任何文件中都可以使用


### 4.介绍一下你的工作经历与优化经验

### 5.这段代码看一下是怎么输出的

```js
Promise.resolve().then(() => {
    console.log("0")
    // 当前一个then中有return 关键字，需要return的内容完全执行结束,第二个then才会注册进入微任务队列。
    return Promise.resolve("1")
}).then((res) => console.log(res));
Promise.resolve().then(() => {
    console.log("2")
}).then(() => {
    console.log("3")
})

// 0，2，3，1
// 原因是0和2是两个promise中进行执行的，但是其中return返回的resolve开启了第二个微任务队列所以打印放在最后了
```
> 参考链接：https://www.zhihu.com/question/453677175



## （十二）百度网盘一面

### 1. 请介绍一下你的项目和亮点吧


### 2. 请说说浏览器缓存策略有哪些

浏览器有强制缓存与协商缓存两种方式，
关于协商缓存的标识code有：https://blog.csdn.net/testcs_dn/article/details/84833920

* 强制缓存
  
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)：

不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：

![强制缓存](../img/JavaScript/强制缓存.jpg)

控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

Cache-Control、Expires都是缓存到期时间，Cache-Control是相对值，Expires是绝对值，即再次发送请求时，如果时间没到期，强制缓存生效。

注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。

缺点：
缓存过期以后，服务器不管资源有没有变化，都会再次读取资源文件，并返给浏览器。

* 协商缓存
  
当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。

控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，
其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

* Last-Modified / If-Modified-Since
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件;

缺点：
如果资源被修改了，最后修改时间变了，但是内容没有变，会重新请求资源文件。

* Etag / If-None-Match
If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下


缺点：
实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源。

### 3. 既然你提到了协商缓存，说说协商缓存的etag与last-modifed的区别吗

If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比

准确来说是这个进行比较，比较这个差异然后进行数据的请求

缺点：
如果资源被修改了，最后修改时间变了，但是内容没有变，会重新请求资源文件。

缺点：
实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源。

### 4. 聊聊浏览器跨域有哪些解决办法

跨域主要可以分成三类
1.带域名限制的跨域方案，被访问页面可以约束哪些域名可以访问，比如后端实现的cors白名单跨域/iframe+postmessage/websocked
2.无限制的跨域方案，这类主要用于哪些安全性不高的，比如jsonp或者url穿参跨域，表单提交跨域，服务端代理跨域
3.最不常用的就是window.name跨域

### 5.你刚刚提到了cors解决跨域，那你说说这个到底是如何解决跨域的？

> 解决跨域问题，就是在服务器端给响应添加头信息

> 面试官回答的解决方案：第一次浏览器向服务器发起请求，服务器根据companyid或者唯一地址链接（白名单），进行判断，这次请求会正常返回数据，第二次请求，那么就会根据之前请求的数据直接给请求头添加标识，让其可以正常的浏览器进行请求。

### 6. 聊聊你知道的文件上传吧？了解断点续传吗？

> 大概流程就是需要设定文件切割的大小，然后将上传的文件进行大小切割

```js
 // 计算文件哈希值 使用第三方库SparkMD5
      function fileHash(chunks) {
        return new Promise((resolve, reject) =&gt; {
          const spark = new SparkMD5()
          function _read(i) {
            if (i &gt;= chunks.length) {
              resolve(spark.end())
              return // 读取完成
            }
            const blob = chunks[i]
            const reader = new FileReader()
            reader.onload = (e) =&gt; {
              const bytes = e.target.result // 读取到的字节数
              spark.append(bytes)
              _read(i + 1)
            }
            reader.readAsArrayBuffer(blob)
          }
          _read(0)
        })
      }
```

### 7. 说说事件循环是什么？


事件循环JavaScript中所有的任务分为同步任务与异步任务，同步任务，顾名思义就是立即执行的任务，它一般是直接进入到主线程中执行。而我们的异步任务则是进入任务队列等待主线程中的任务执行完再执行。
任务队列是一个事件的队列，表示相关的异步任务可以进入执行栈了。
主线程读取任务队列就是读取里面有哪些事件。队列是一种「先进先出」的数据结构。上面我们说到异步任务又可以分为宏任务与微任务，所以任务队列也可以分为「宏任务队列」与「微任务队列」

> Macrotask Queue：进行比较大型的工作，常见的有「setTimeout，setInterval」，用户交互操作，UI渲染等； 
> Microtask Queue：进行较小的工作，常见的有Promise，Process.nextTick； 

执行顺序：
1. 同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。
2. 系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列，并且每个任务会对应一个回调函数进行处理。
3. 这里异步任务分为宏任务与微任务，宏任务进入到宏任务队列，微任务进入到微任务队列。
4. 执行任务队列中的任务具体是在执行栈中完成的，当主线程中的任务全部执行完毕后，去读取微任务队列，如果有微任务就会全部执行，然后再去读取宏任务队列
5. 上述过程会不断的重复进行，也就是我们常说的「事件循环（Event-Loop）」。

事件循环，包含调用栈，微任务队列，宏任务队列

微任务队列与宏任务队列同时出现的时候，先执行微任务再执行宏任务

### 8. 看你做过图表，说说你知道的如何实现一个饼状图

> 饼图实现
```js
// > 1.常规操作创建canvas容器,获取DOM节点，并绑定画布。
<canvas id="pie">你的浏览器不支持HTML5 canvas</canvas>
let myPie = document.getElementById('pie')
let c = myPie.getContext('2d')

//2. 实现一个简单的圆形及API注解

// c.arc()方法创建弧/曲线（用于创建圆或者部分圆）
// 参数说明：
// 1.c.arc(x(圆的中心的x坐标),y(圆的中心的y坐标),r（圆的半径）,sAngle,eAngle,counterclockwise);
//    sAngle：初始角，以弧度计算（圆形的三点钟方向就是0度）。
//    eAngle：结束角，以弧度计算。
//    counterclockwise：可选 是布尔值，顺时针 = false 逆时针 = true
//    arc中的x坐标和y坐标对应的是什么进行计算的呢，它是通过canvas容器进行计算的，可以理解为position定位top和left的偏移量。
// 2.c.fillStyle属性是填充颜色配合 c.fill() 方法使用
//   c.fillStyle如果不写，默认值是黑色。
// 3.背景渐变色
//   如果需要使用到背景渐变的话这里也提供了API
//   let bg = c.createdLinearGradient(x(渐变开始),y（渐变开始）,x1（渐变结束）,y1（渐变结束）)
//   bg.addColorStop(0,颜色) 配合使用 两个参数  参数1：0 - 1 渐变  参数2：颜色
//   bg.addColorStop(1,颜色) 配合使用 两个参数  参数1：0 - 1 渐变  参数2：颜色
//   c.fillStyle(bg)   // 这样在渐变角度相同的情况下就是出现渐变背景颜色效果

// 绘制圆形
c.arc(150,50,50,Math.PI*2,true)
c.fill()


// 3.扇形图:实现一个扇形图

c.moveTo(x,y) 
//两个参数x:路径的目标位置的 x 坐标,y:路径的目标位置的 y 坐标
//结合 c.arc()形成扇形图
// 代码如下
c.moveTo(150,75);
c.arc(150,75,50,0,100,true)
c.fill()  // 此api 是填充图表，默认为黑色 如果需要改颜色即可配合 fillStyle进行修改 (参数为字符串类型)
c.fillStyle = 'red'  //（支持颜色名称，支持16进制 ，支持rgba，也可以使用渐变）



// 4.平分圆
// 什么是平分圆，每个饼图的数据不同，那么展示的分布也会不同，那么这个时候就会根据数据来画了。
// 在画的过程中还要考虑每个扇形的起始点和终点，把扇形组合起来最总形成一个圆。

// 
// 1.接收数据，数组类型，声明颜色值数组
let data = [
{ value: 1048, name: "Search Engine" },
{ value: 735, name: "Direct" },
{ value: 580, name: "Email" },
{ value: 484, name: "Union Ads" }
]
let color = ["red", "black", "yellow", "#EF6667", "#546FC6"];
// 2.获取数据value总和
let sum = 0;
for (let item of data) {
	sum += item.value;
}
// 3.获取数据value在总和中占比
data = data.map((v, i) => {
	return {
		name: v.name,
		value: v.value / sum,
	};
});
// 4.获取到canvas的宽度和高度，因为要根据宽高来设定 x y 的对其剧中
const cW = myPie.clientWidth
const cH = myPie.clientHeight
c.translate(cW / 4, cH / 4); // 这个除数可以根据自己的宽高来定，translate这个方法主要是用于饼图在canvas的显示位置
let mincWH = cW > cH ? cH : cW // 获取宽高最小值，设定饼图半径大小
// 5.声明弧度开始位置及结束位置
let agl; // 每条数据的终点
let startAgl = 0; //起点
// 6. for循环数据正式进行渲染
for (let i = 0; i < data.length;i++){
    agl=data[i].value*pi2+startAgl; // 本次值加上上一个的起点值计算每个数据的开始的弧度
    c.beginPath(); // 开辟新路径，如果不开启新路径，那么就会从1-100画一个数据
    c.moveTo(0,0); // 画一条线，结合arc方法实现扇形
    c.arc(0,0,mincWH*0.1,startAgl,agl,false); // 画圆的关键方法
    c.fillStyle=color[i];
    c.fill();
    startAgl=agl;// 把现在的终点赋值给下一个的起点位置
}

```

### 9. 说说你对于


## （十三）高途-图图乐学

### 1. 说说vue3与vue2有什么差别？

### 2. 说说你了解的ref和refavice有什么差别

1.ref
ref允许我们创建一个任意类型的响应式的ref对象，在使用时需要带上.value，例如下面：

2.reactive
我们通常使用reactive()来创建一个响应式的对象或数组，这样的对象或数组状态都是默认深层响应式的，也就是说 

```js
import { reactive } from 'vue'

const a = reactive({
 count:1
})
a.count++
console.log(a.count) //2

const b = reactive({
 obj:{
   arr:['Alice','Bob','Carol']
 }
})
b.obj.arr.push('Dave')
console.log(b.obj.arr) //['Alice','Bob','Carol','Dave']
```
不管他们嵌套多深，都可以被追踪到，例如下面：

reactive也有一些局限性，那就是仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的原始类型无效（见官网），并且假如用一个新对象替换了原来的旧对象，那么原来的旧对象会失去响应性，例如下面：
```js
const a = reactive({
 count:1
})
a = reactive({
 count:2
}) //{ count: 1 }失去了响应性
```

相同点：创建响应式对象

不同点：

ref可接受对象类型也可以接受基本类型，而reactive只能接收对象或数组等复杂类型

ref创建的数据返回类型为RefImpl ，而RefImpl._value是一个 reactive 代理的原始对象，reactive创建的数据返回类型为Proxy

ref使用.value来访问值

### 3. 说说浏览器缓存有哪几种

> 强制缓存/协商缓存

### 4. 你知道301和302吗？说说有啥区别

> 301代表的是永久重定向
> 302代表的是临时重定向


### 5. 说说http和https有什么差别呢？

HTTP协议以明文方式发送内容，不提供任何方式的数据加密。HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。https则是具有安全性的ssl加密传输协议。http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。并且https协议需要到ca申请证书。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

一、传输信息安全性不同

1、http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。

2、https协议：是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。

二、连接方式不同

1、http协议：http的连接很简单，是无状态的。

2、https协议：是由SSL＋HTTP协议构建的可进行加密传输、身份认证的网络协议。

三、端口不同

1、http协议：使用的端口是80。

2、https协议：使用的端口是443

### 6. 说说垂直居中有哪几种方式吧

### 7. 说说浏览器兼容的相关设计理念吧？


###  8.写一道小的算法题

```js
const array = [10, 5, 11, 7, 8, 9]
// 求解数组的最大差值

function getMaxProfit(arr) {
    if(arr.length){
     let maxnum=arr[0];
     let minnum=arr[0];
      arr.forEach(item=>{
        if(item>maxnum){
            maxnum=item;
        }
        if(item<minnum){
            minnum=item;
        }
      });
        return maxnum-minnum;
    }else{
       return null;
 }
}

console.log(getMaxProfit(array)) // 6
```


### 9. 说说你了解的localstoreage和sessionstoreage有什么应用场景吧


> 提供一种在cookie之外存储会话数据的途径。
> 提供一种存储大量可以跨会话存在的数据的机制。


1、 localStorage永久保存在浏览器（注意事是浏览器，不仅仅是一个页面），除非用户主动清除；sessionStorage在浏览器关闭之后存储的数据就会销毁（仅仅存储在当前页面）

2、根据同源原则，不同浏览器不能共享loacalStorage和sessionSrorage的信息，相同的浏览器不同页面可以共享loacalStorage（必须相同域名和端口），但是相同浏览器              不同页面或者标签不能共享sessionStorage信息（sessionStorage仅仅存储在当前页面），这个页面是指顶级窗口页面，如果一个页面有几个不同的iframe标签，是可以共享sessionStorage信息。

用法：两者用法差不多，但是取值有所不同

### 10. 说说防抖截流是什么怎么用的？


### 11. 什么是闭包？

> 闭包


### 12. 你说说事件循环是什么？


事件循环JavaScript中所有的任务分为同步任务与异步任务，同步任务，顾名思义就是立即执行的任务，它一般是直接进入到主线程中执行。而我们的异步任务则是进入任务队列等待主线程中的任务执行完再执行。
任务队列是一个事件的队列，表示相关的异步任务可以进入执行栈了。
主线程读取任务队列就是读取里面有哪些事件。队列是一种「先进先出」的数据结构。上面我们说到异步任务又可以分为宏任务与微任务，所以任务队列也可以分为「宏任务队列」与「微任务队列」

> Macrotask Queue：进行比较大型的工作，常见的有「setTimeout，setInterval」，用户交互操作，UI渲染等； 
> Microtask Queue：进行较小的工作，常见的有Promise，Process.nextTick； 

执行顺序：
1. 同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。
2. 系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列，并且每个任务会对应一个回调函数进行处理。
3. 这里异步任务分为宏任务与微任务，宏任务进入到宏任务队列，微任务进入到微任务队列。
4. 执行任务队列中的任务具体是在执行栈中完成的，当主线程中的任务全部执行完毕后，去读取微任务队列，如果有微任务就会全部执行，然后再去读取宏任务队列
5. 上述过程会不断的重复进行，也就是我们常说的「事件循环（Event-Loop）」。

事件循环，包含调用栈，微任务队列，宏任务队列

微任务队列与宏任务队列同时出现的时候，先执行微任务再执行宏任务


### 13. 你说说promise和async await有什么区别吧

> async/await的目的为了简化使用基于promise的API时所需的语法。async/await的行为就好像搭配使用了生成器和promise。

> async函数一定会返回一个promise对象。如果一个async函数的返回值看起来不是promise，那么它将会被隐式地包装在一个promise中。

> 为了解决异步方法的执行提出了promise

> 相同点
Promise和 async-await 都是优化异步编程体验的解决方案。
> 不同点
Promise 是应用层的解决方案，它有一个规范，不同的语言也可以实现，它只能异步的处理错误，在js 里它本质上是一个对象。
async-await 是语言层的解决方案，它可以说是 Promise的补充，可以让用户像编写同步代码一样编写异步代码，通过try-catch 可以同步地处理错误。
Promise 更多应用在函数封装中，async用在函数的使用中。
Promise链式调用相当于一个新的回调地狱， 也不能统一处理异常。 Promise 本身是同步函数，多个不会等待。
async-await用同步的写法使得可读性更强，同时方便 try-catch 捕获异常， async-await 有明确的前后关系，可读性好。


### 14. 你说说promise的几个方法吧

> all()
> race()
> finally()


### 15. 如果我现在要请求4个接口，这4个接口返回的，不论返回几个我都要返回这个结果，你应该怎么做？

> 或者手写一个方法，其中声明一个当前接口的状态下标，标志着当前接口返回的数量（不论是接口成功返回还是失败返回都进行计数），当当前接口返回数量等于目前请求的接口长度，这时候就可以正常的进行整体返回

### 16. 如果使用promise的方法呢是那个方法？

> 这时候promise有一个新的方法，Promise.allSettled() 方法是 promise 并发方法之一。在你有多个不依赖于彼此成功完成的异步任务时，或者你总是想知道每个 promise 的结果时，使用 Promise.allSettled() 。

### 17. 说说移动端的样式兼容，rem是什么？

> rem:指的是以根元素大小作为当前元素宽度的数值

>  媒体查询可以自动检测视口的宽度，并根据检测到的不同宽度，编写不同的CSS样式，当某个条件成立，就可以触发对应的CSS样式。

> 比如如果检测当前的浏览器宽度是375px那么根元素的字体大小

> 以上的逻辑市面上有一个js库用于解决这个适配方案：flexible

> flexible.js是手淘开发出的一个用来适配移动端的js框架。手淘框架的核心原理就是根据制不同的width给网页中html根节点设置不同的font-size，然后所有的px都用rem来代替，这样就实现了不同大小的屏幕都适应相同的样式了。其实它就是一个终端设备适配的解决方案，也就是说它可以让你在不同的终端设备中实现页面适配。

### 18. 说说你的ts用了哪些，拿来做什么，然后聊聊你知道的TypeScript 泛型是做什么的？

> 使用场景有

> 1.泛型在类中的应用

```ts
// 不使用泛型的类
class AddNumber:number {
    private numArr: number[] = []
    add(num: number) {
        this.numArr.push(num)
    }
    getSum(): number {
        let sum = 0
        return this.numArr.reduce((total, num) => {
            return total + num
        }, sum)
    }
}

const addFun = new AddNumber()
addFun.add(1)
addFun.add(2)

// 使用泛型的类
class AddNumber<T> {
    private numArr: T[] = []
    add(num: T) {
        this.numArr.push(num)
    }
    getSum(): T {
        return this.numArr[0]
    }
}
// 向T赋值为number类型，则在AddNumber类中的所有T都为number类型
const addFun = new AddNumber<number>()
addFun.add(1)
addFun.add(2)
```

> 2.在函数中的使用

```ts
// 当我们不使用泛型时：
	function identityNumber(value: number): number {
	    return value
	}
	function identityString(value: string): string {
	    return value
	}
	function identityBoolean(value: boolean): boolean {
	    return value
	}
/// 当不使用泛型时，我们需要对三种返回值，分别声明三种不同的函数，而使用泛型，我们可以直接声明为一种，大大减少了代码量
	function identity <T>(value:T) : T {
        return value
    }
```

> 3.泛型在其他类型中的应用
 在上面我们已经通过举例介绍过函数与类中泛型的应用了，但是泛型的使用不止以上两种，下面依次为大家介绍在其他类型下的使用。
```ts
// 多类型传参
// 在泛型中，可以使用多个未知的类型占位，我们可以将对应的占位符表示为任意的参数类型。
const getUser = <T, U>(name: T, age: U) => {
    const user = <{ name: T, age: U }>{
        name: name,
        age: age
    }
    return user
}
// 泛型接口
// 对于接口，我们也可以使用泛型来进行定义，其对应的type就为T类型。\
interface typeValue<T> {
    type: T;
}
// 泛型别名
//  泛型也可以作用与type上，从而行成泛型别名~

type User<T> = {
    name: T;
    age: T;
}

// 泛型使用默认参数
//  对于使用者来说，可能会存在没有对此泛型进行传值操作或者从实际值参数也无法推断出此类型，所以在这里我们可以使用默认参数来约束没有进行赋值的泛型。此例中默认泛型为string类型。

type User<T = string> = {
    name: T;
    age: T;
}

// 泛型常用字母
// T：代表Type，我们常将其用作第一个类型名称变量
// K：代表Key，也就是键值对中的键
// V：代表Value，也就是键值对中的值
// E：代表Element，代表元素类型
```




### 19. 说说你了解的ts中的namespace有什么用

> 在ts中，namespace（命名空间）相当于闭包，可以隔绝作用域，格式如下：namespace X {}

```ts
// 比如以下代码
namespace Shapes {
    export namespace Polygons {
        export class Triangle { }
        export class Square { }
    }
}
//如果我们要使用里头的Triangle或者Square，我们大概是这样子：
new Shapes.Polygons.Triangle();
new Shapes.Polygons.Square();
// 可以看到后面一大串，太长了，我们就是要解决这个问题，简化命名空间

// 2.简化命名空间
// 要简化命名空间，核心就是给常用的对象起一个短的名字
// TS中使用import为指定的符号创建一个别名，格式大概是：import q = x.y.z
// 它有点像var，但它还适用于类型和导入的具有命名空间含义的符号，而且对于值来讲， import会生成与原始符号不同的引用

// 下面我们使用，import简化代码：
import polygons = Shapes.Polygons;
// 然后使用的时候就变得简洁了
new polygons.Square();
//之前是new Shapes.Polygons.Square();


```