滴滴可能问到的面试题

1. css标签继承与权重
id 选择器 #id 100
类选择器 .class 10
标签选择器 div 10
后代选择器 li a 0
2. 对于选择器的选择应该是：标签选择器/伪元素选择器>类选择器/属性选择器>id选择器>内联样式

3. flex：1 1 0px这三个属性的含义
第一个参数表示：flex-grow 定义了项目的放大比例默认为0，也就是如果存在剩余空间，也不放大
第二个参数表示：flex-shrink定义了项目的缩小比例，默认为1， 如果空间不足，该项目缩小
第三个参数表示：flex-basis给上面两个属性分配多余空间之前，计算是否有多余空间，默认为auto

4. 九种跨域方式实现原理 https://juejin.cn/post/6844903767226351623

5.  vue3 的 watch 和 watchEffect 的区别

> watchEffect 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。
它接收两个参数。
第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。
第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。
而
> watch 我倒是一直就知道，它的作用就是侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。

6. vue-router你使用过吗？使用过 history 方式吗？使用过 hash 方式吗？使用过abstract方式吗？能不能说一下它路由的原理。
hash: 早期前端路由的实现就是基于location.hash来实现的，其实实现原理很简单，location.hash的值就是URL中#后面的内容。
它的实现原理是通过监听 window 下的 hashchange 事件，判断改变的 pathname 属于已记录的哪几个 router 地址，对应的 router-view 容器就渲染相应的路由代码如下：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>
            <a href="#/home">首页</a>
        </li>
        <li>
            <a href="#/about">关于</a>
        </li>
    </ul>

    <!-- 渲染对应的UI -->
    <div id="routerView"></div>

    <script>
        let routerView = document.getElementById('routerView')
        window.addEventListener('hashchange',onHashChange)

        //控制渲染对应的ui
        function onHashChange(){
            switch(location.hash){
                case '#/home':routerView.innerHTML='首页'
                braek;
                case '#/about':routerView.innerHTML='关于'
                break;
                default:return
            }
        }
    </script>
</body>
</html>
```
history: HTML5提供了History API来实现URL的变化，其中最主要的两个API有以下两个
history.pushState()和history.replaceState()。这两个API可以在不进行刷新的情况下，操作浏览器的历史记录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录
而 history 对比 hash 不同的是通过阻塞浏览器 url 地址栏更改之后的跳转，然后将其 pathname 拼接上去，实现路由，具体代码实现如下：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>
            <a href="/home">首页</a>
        </li>
        <li>
            <a href="/about">关于</a>
        </li>
    </ul>

    <!-- 渲染对应的UI -->
    <div id="routerView"></div>
    <script>
        let routerView = document.getElementById('routerView')

        // window.addEventListener('popstate',()=>{
        //     console.log(13)
        // })

        // window.onpopstate = function(){
        //     console.log(13)
        // }

        window.addEventListener('DOMContentLoaded',onLoad)
        // window.addEventListener('popstate',PoPState)          //浏览器的前进后退能匹配
        function onLoad(){
            PoPState()
            let links = document.querySelectorAll('li a[href]')
            links.forEach(a=>{
                a.addEventListener('click',(e)=>{
                    e.preventDefault();      //阻止a标签的href标签
                    
                    history.pushState(null,'',a.getAttribute('href'))
                    PoPState()
                })
            })
        }
        onLoad()
        function PoPState(){
            console.log(location.pathname)
            switch(location.pathname){
                case '/home':
                    routerView.innerHTML = '<h2>home page</h2>'
                    return
                case '/about':
                    routerView.innerHTML = '<h2>about page</h2>'
                    return
                default:
                    return
            }
        }
    </script>
</body>
</html>
```


7. 怎么让对象上的属性成为不可更改的属性
vue2 上的这个字段有这个样一个属性
Object.defineProperty 上有一个 writable 属性设置为 false 可以使其对象上的属性不可修改。
对象冻结：Object.freeze(obj),使被冻结的对象不可被修改，不可添加新属性，不可修改值，不可删除
对象密封：Object.seal(obj),使被密封的对象不可添加，不可以改动键值，但能改value
阻止扩展：Object.preventExtensions(obj),阻止对象增加属性，但不会阻止其它操作


8. 遍历嵌套对象
编写函数获得对象中的值666，必须使用到 str = 'a.b.c';
```js
// 方法一
const obj = {
    a:{
        b:{
            c:666
        }
    }
}
 
var str = 'a.b.c';
const getData = ()=>{
  var newArr =  str.split('.').reduce((o,s)=>{ return  o[s]},obj)
    return newArr
}
console.log( getData());


// 方法二
const obj = {
    a:{
        b:{
            c:666
        }
    }
}
 
var str = 'a.b.c';
const getData=(obj,str)=>{
 str.split('.').forEach(element =>{ 
     obj= obj[element]
})    
return obj;
}
console.log(getData(obj,str));

```


9. webpack 原理
大致就是：

* 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
* 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
* 确定入口：根据配置中的 entry 找出所有的入口文件；
* 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
* 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
* 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
* 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

10. babel 原理
babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：

ES6代码输入
babylon 进行解析得到 AST
plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树
用 babel-generator 通过 AST 树生成 ES5 代码

11. 有哪些方法可以判断类型
```js
当时我一时紧张，只记起来了两种方式，一种 typeof ,另外一种则是 instanceof ，第三种的是模模糊糊的回答上 Object.prototype.toString 。
typeof 特点：可以准确的判断出原始类型的种类，但是会对 null 判断成 Object ,算是 JS 历史残留问题，引用类型除了 function 能够准确判断出来，其它类型一律会被判断成 Object 类型。
instanceof 特点：可以准确判断出任意数据类型，但不能判断数据类型 null ，且由于原型链可能被修改，就会导致检测结果不准确。
Object.prototype.toString 特点：看名字它是用来将一个值转为字符串的，但其实并不是，它是一个专门检测数据类型的方法。它返回的值是一个形如 [object Object] 的字符串，且什么类型都可以准确判断。
当然，肯定还有其他方法，不过当时我确实是不记得了，后面回想起来一些，也再查了一下，其他方法如下：constructor、Symbol.toStringTag、Object.prototype.isPrototypeOf、Array.isArray、Number.isNaN等等......
```

12. 如何判断当前对象的属性
Object.prototype.hasOwnProperty()

13. nextTick在哪里使用？原理是？
> nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
> 在修改数据之后立即使用这个方法，获取更新后的 DOM
> 主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法
nextTick 方法主要是使用了宏任务和微任务,定义了一个异步方法.多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。所以这个 nextTick 方法就是异步方法
```
回答范例
nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
Vue有个异步更新策略，意思是如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick

开发时，有两个场景我们会用到nextTick

created中想要获取DOM时
响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度
nextTick签名如下：function nextTick(callback?: () => void): Promise<void>

所以我们只需要在传入的回调函数中访问最新DOM状态即可，或者我们可以await nextTick()方法返回的Promise之后做这件事

在Vue内部，nextTick之所以能够让我们看到DOM更新后的结果，是因为我们传入的callback会被添加到队列刷新函数(flushSchedulerQueue)的后面，这样等队列内部的更新函数都执行完毕，所有DOM操作也就结束了，callback自然能够获取到最新的DOM值
```

14. 那vue中是如何检测数组变化的呢？
数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。

是用来函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新。
数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）

vue3：改用 proxy ，可直接监听对象数组的变化。

15. 为什么Vue采用异步渲染呢？
Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。
 dep.notify（） 通知 watcher进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一tick中刷新watcher队列（异步）。

 16. vue和react的却别
 ```
  1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
 2.数据渲染：大规模的数据渲染，react更快
 3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
 4.开发风格：react推荐做法jsx + inline style把html和css都写在js了
      vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
```


##  滴滴打车

### 1. 聊聊你的项目吧，有做过哪些数据上报的内容，有做过什么性能优化吗

性能优化：减少http请求
图片类型修改由png/jpg修改成webp
设置合理的缓存
资源合并或者压缩，这一般是webpack做的事情

页面加载时间的方法
1. 压缩css/js文件
2. 合并js/css文件，减少http请求
3. 外部js/css放在底部
4. 减少dom操作，尽可能用变量替代不必要的dom操作

### 2. 你对webpack有什么了解，你知道webpack与vite有什么区别吗


1.开发模式不同

Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。

2.打包效率不同

Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。

3.插件生态不同

Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。

4.配置复杂度不同

Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。

5.热更新机制不同

Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度。

### 3.你对node有什么了解？，说说node
### 4.微前端是什么，介绍一下微前端呗

我了解的微前端技术有：
iframe
single-spa
qiankun 基于 single-spa 方案实现, 更强大更易上手
webpack5 ModuleFederationPlugin（EMP）
microApp

### 5. [{ key: 'x', value: '2' }, { key: 'x', value: '2' }, { key: 'x', value: '3' }]如何去重
### 6. abcd，aba，adbd，如何判断他是不是回文

### 6.请找出abdcdasd这里面的最长不重复的字符串，请返回他的长度

```ts
[{ key: 'x', value: '2' }, { key: 'x', value: '2' }, { key: 'x', value: '3' }]

const fun = (arr) => {
    let obj = {}
    let newSet = new Set();
    let arr = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr.has(i)) {

        } else {

        }
    }
    for () {
        //下次循环就拿到对应的新的arr
    }
}

const fun = (sting) => {
    const stringArray = string.split('');
    const center = Math.ceil(stringArray.length / 2);
    if (let i = 0; i < center; i++) {
        if (stringArray[i].toLocaleUpperCase() !== stringArray[stringArray.length - i].toLocaleUpperCase()) {
            return false;
        }
    }
    return true;
}

const fun1=(string)=>{

}
```
express
koa


### 博研智通

1. 高阶函数用过吗？了解过arguments对象吗？

* 函数柯里化，使用场景比如有固定参数你需要动态化，这时候写一个最最基础的方法，然后使用柯里化声明一个新的对象这时候就可以解决这些问题了

2. HTTP状态码与304状态码介绍一下

3. pinia和vuex区别介绍一下

4. vue中$set用法详细讲解

5. 详解require和import有什么区别介绍一下

> require 是运行时调用，import 是编译时调用
> require 是 AMD 规范引入方式;import 是 es6 的一个语法标准，如果要兼容浏览器的话必须转化成 es5 的语法
> require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用

6. forEach方法如何跳出循环？

7. rpc框架了解么？问问你们app是如何通信的

8. app的登陆是如何做的，介绍一下？如何判断当前环境是否是app的环境呢？

9. 中间件有了解吗，做过中间件吗？

10. 如何使用链式进行父子组件传入参数

## 百度一面

1. 请讲讲盒子模型有哪几种，他的区别是什么

有两种盒模型，分别是IE盒模型（border-box） 和 W3C标准盒模型（content-box）。
答：IE盒模型，它的元素width、height的值的计算方式包含了content、border和padding等属性的数值，也就是说它的基本宽高大小等于 content + padding + border。

再来说W3C标准盒模型，它的元素width，height的计算方式只包含内容了content 这一个属性的数值，不包含 border 和 padding 元素

2. 请问package.json 与package.lock.json版本不一致在安装过程中应该以那个依赖为主
还是以package.lock.json为主，除非你把这个配置文件删除了否则安装的依赖版本还是package.lock.json上的版本

3. 请说说vue的生命周期，并讲讲父子组件的生命周期是什么样的

1.vue生命周期
每个vue实例都有一个生命周期 一共分为八个阶段
创建前后： beforeCreate/created 渲染前后： beforeMount/mounted
更新前后： beforeUpdate/updated 销毁前后： beforeDestroy/destroyed

在created周期的时候 就可以访问到this了 也可以调用异步的方法去获取后台的数据
在mounted周期的时候 就能够访问到DOM结构 对dom结构进行一些增删改查的操作 因为在这个时候 dom结构已经渲染完成并挂载在vue实例上面了
当data变化时，会触发beforeUpdate和updated方法
在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。
2.父子组件的生命周期顺序
加载渲染过程：
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
子组件更新过程：父beforeUpdate->子beforeUpdate->子updated->父updated
父组件更新过程：父beforeUpdate->父updated
销毁过程：父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

4. 请说说promise对象与async await的区别


5. 请说说vue的双向绑定是什么样的（响应式）

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。
> vue3.0使用的是proxy拦截器实现的数据双向绑定

6. 请说说vue的响应式？？

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。
> vue3.0使用的是proxy拦截器实现的数据双向绑定


7. 如果你有一段代码发现推到远程了，你想重置掉远程代码，但是要保留本地代码，有哪些方法？

面试的时候我说的是，在你的开发分支拉出来一个分支，作为备份分支，

然后git reset --hard
git push origin dev


```
git pull 拉最新代码，提交之类，保证本地代码最新且无修改

git log  查看提交日志

git reset --hard  2ea5c6b311d8c45d62acdd6061a038950ea81b19  回退到要修改这个, --hard 会删除本地未提交的代码，回退回某一个版本，之间的代码不会在暂存区有记录

git reset 6df0437277dd01c29362c690b9448a3f0e72b1ce   再回退到它的上一次提交 ，暂存区会有这次回退之间的内容

git diff  可查看这些内容，可能需要去项目中解决冲突之类

git add . 有修改的话add下

git stash save 权限框     保存2ea5c6b311d8c45d62acdd6061a038950ea81b19提交的内容，至此需要修改的内容就存了下来。

 
git pull  拉下远端代码

git revert 6df0437277dd01c29362c690b9448a3f0e72b1ce 重置要修改的此次提交

git status 查看当前状态

git add .   修改错误后提交

git commit

git push 

git stash list    查看之前存下来的内容。

git stash apply stash@{0}  本地应用保存起来的修改，这样，重置的修改就在本地了
```


7. 请介绍一下你的项目吧，有哪些你觉得好的点

8. 项目重构为了什么，为什么要项目重构

9. 请介绍一下回流重绘吧，有哪些注意的点

10. 请说明一下如何隐藏一个元素，有哪些方式，并且他们的差异点有哪些

方法有三个：
display:none; 这个属性用于定义建立布局时元素生成的显示框类型,而none属性可以让元素隐藏

visibility:hidden；这个属性是能见度的意思，使用hidden属性值后可以让元素“隐藏”

opacity:0; 这个属性是透明度的意思，为零即透明度为0，也可以做到隐藏元素的作用


虽然上面三个属性都可以让元素实现“隐藏”的效果但是有的是真的让元素隐藏起来了，但有的只是假的让元素元素“隐藏”起来了，
display:none; 可以直接让元素“消失”而且在页面中不会占元素隐藏前该占的位置

visibility:hidden；和 opacity:0; 虽然也能让元素实现“隐藏”效果，但是他们让元素隐藏后在页面上该占的位置是不会变的，

打个比喻display可以做到让一个元素真真正正的消失，不管他之前占了什么位置有多大，而另外两个更像是让元素隐身起来了，该有的属性是一点不变，只是看不见而已，

那么他们都能用于什么场景呢，比如你想在一个元素上面做一个按钮，让点击这个元素的时候实现按钮一样的效果，但是这个按钮很丑，而且影响客户视觉效果，这时候就可以使用opacity，visibility两个属性了，这样虽然按钮是隐藏的但是功能并不会消失


把[1,2,3,4,5,6,7,8,9,0]变成三个三个的二维数组

1. loadsh的chunk方法
2. 手写一个方法
```js
const convertTo =(arr,size)=>{
    let result=[];
    for(let i=0;i<arr.length;i+=size){
        result.push(arr.slice(i,i+size));
    }
    return result;
}
```


实现一个斐波那契数列
```js
const fib=(n)=>{
    if(n===0||n===1){
        return 1;
    }
    return fib(n-1)+fib(n-2);
}
```

算法优化：dp[i]=dp[i-1]+dp[i-2]
```js
const fib=(n){
    if(n<=1)return n;
    let fib=[0,1];
    for(let i=2;i<=n;i++){
        fib[i]=fib[i-1]+fib[i-2];
    }
    return fib[n];
}
```


## 美团一面

1. 请说说点击小程序到底发生了什么


2. 请说说小程序的线程会发生哪些操作

* 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View层用来渲染页面结构，App Service层用来逻辑处理、数据请求、接口调用，它们在两个线程（Webview）里运行。
* 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。

3. 如何判断一个链表是否有环


```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function detectCycle(head: ListNode | null): ListNode | null {
    if(!head) return null;
        // method: double pointer
    let fast = head;
    let slow = head;
    // fast step moves by two steps,slow moves by one
    while(fast && fast.next!=null && fast.next.next!=null){
        fast = fast.next.next
        slow = slow.next
        if(fast === slow){
            let index1 = fast
            let index2 = head
            while(index1!=index2){
                index1=index1.next
                index2=index2.next
            }
            return index1
        }
    }
    return null

};
```
4. 手写promise.all

```js
const PromiseAll = (iterator) => {
  const promises = Array.from(iterator); // 对传入的数据进行浅拷贝，确保有遍历器
  const len = promises.length; // 长度
  let index = 0; // 每次执行成功+1,当等于长度时，说明所有数据都返回，则可以resolve
  let data = []; // 用来存放返回的数据数组
  return new Promise((resolve, reject) => {
    for (let i in promises) {
      promises[i]
        .then((res) => {
          data[i] = res;
          if (++index === len) {
            resolve(data);
          }
        })
        .catch((err) => {
          reject(err);
        });
    }
  });
};

const promise1 = Promise.resolve('promise1');
const promise2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 2000, 'promise2');
});
const promise3 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 1000, 'promise3');
});

PromiseAll([promise1, promise2, promise3]).then(function(values) {
    console.log(values);
});
```
# 推想医疗一面

手写promise.all
```ts
const promiseAll = (arr) => {
    const result = [];
    const tempArr = Array.from(arr);
    let resultNumber = 0;
    return new Promise((resole, reject) => {
        tempArr.forEach((item, index) => {
            if (item) {
                // 解析的操作
                Promise.resolve(item).then(res => {
                    result[i] = res;
                    resultNumber++;

                    if (resultNumber === tempArr.length) {
                        resolve(result);
                    }
                }, err => {
                    reject(err);
                })

            });
    })
}
```

1. 介绍一下type和interface的区别

> type 可以使用联合类型（|）和交叉类型（&）进行类型组合;而 interface 不支持联合类型和交叉类型。

> type 和 interface 是 TypeScript 中用于定义类型的关键字。
它们在定义对象类型、函数类型和类型组合等方面有一些区别。
type 更灵活，支持联合类型和交叉类型，并且可以使用类型别名来简化复杂的类型定义；
而 interface 支持继承和类的实现。你可以根据具体的使用场景选择合适的方式。

> 

2. 介绍一下你的项目

3. 请说说以下打印是什么样的
```ts
for(const i=0; i<6; i++){
    console.log(i);
}

for(let i=0; i<6; i++){
    console.log(i);
}

for(var i=0; i<6; i++){
    console.log(i);
}

for(var i=0; i<6; i++){
    setTimeout(()=>{
        console.log(i);
    },0)
}

// 如果想要打印0-5我应该如何修改
```

4. 请介绍一下settimeout与promise的打印顺序

5. 请说说png和webp的区别吧

 
WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。


结论：建议原创表情尽量控制颜色数在 256 色以内，采用无损压缩性价比最高。
小于 256 色：以图标，图形，剪贴画为代表，最适合采用 WebP 无损压缩，精细度完美，体积大幅减少；
大于 256 色：以多数表情图，广告图为代表，最适合采用 WebP 有损压缩，选择较高压缩比（建议压缩质量为 100% ~ 75%）
远大于 256 色：以风景照，视频截图为代表，最适合采用 WebP 有损压缩，选择适中压缩比（建议压缩质量为 75% 以下）

6. 请介绍一下你在项目中做过哪些优化点呢

7. 介绍一下虚拟列表的实现思路吧

8. 聊聊你参与的项目的基础构建做了哪些吧？

9. 如果现在的需求是需要实现一个鼠标滚轮滚动的时候需要让页面左右滚动，应该如何实现

```html
<!DECTYPEhtml>
<html>
    <head><metacharset=‘utf-8’><title>onwheel-test</title></head>
    <body>
        <div id='out'style='width:500px;height:500px;overflow:auto'>
        <div id='inside'style='width:1000px;height:1000px;background-color:gray;overflow:auto'></div>
        </div>
        <script type='application/javascript'>
        var outDiv= document.getElementById('out');  
        outDiv.onwheel=function(event)
        {//禁止事件默认行为（此处禁止鼠标滚轮行为关联到"屏幕滚动条上下移动"行为）
            event.preventDefault();
            //设置鼠标滚轮滚动时屏幕滚动条的移动步长var step=50;
            if(event.deltaY<0){
                //向上滚动鼠标滚轮，屏幕滚动条左移
                this.scrollLeft-= step;
                }else{
                    //向下滚动鼠标滚轮，屏幕滚动条右移
                    this.scrollLeft+= step;
                }
        }
                    /**
            // 如果要手动设置滚动条在Y轴方向的位置可以直接设置scrollTop,例如：
            outDiv.scrollTop = 500;
            // 如果要手动设置滚动条在X、Y轴方向的位置可以使用函数scrollTo,例如设置X轴滚动100，Y轴滚动400：
            outDiv.scrollTo(100,400);
        **/
        </script>
    </body>
</html>
```

## 滴滴网约车小程序一面

1. 手写代码：
```js
// 数组打平
// arr = [1,2,3,[4,5,[6,[7]]]]
// level: 1
// [1,2,3,4,5,[6,[7]]]
// level: 2
// [1,2,3,4,5,6,[7]]
// level: >= 3
// [1,2,3,4,5,6,7]
let currentLevel = 1;
const resultArr = [];

function flat(arr, level) {
    let isPush = false;
    if (currentLevel <= level) {
        arr.forEach(arrItem => {
            if (Array.isArray(arrItem)) {
                isPush = true;
                flat(arrItem, level)
            } else {
                resultArr.push(arrItem)
            }
        });
    }
    if (isPush) {
        currentLevel++;
    }

    return resultArr
}
```
2. 正则匹配,邮箱匹配
```js
// reg
da@gmail.com

^[a-zA-Z0-9_-]@[a-zA-Z0-9_-].[a-zA-Z]$
string
"[{a,a},{b,b}]
string
a,a b,b

[[]
JSON.parse("string")
```
1. 请说说你了解的排序算法（介绍一下快速排序吧）

2. 请说说你了解的你认为不错的技术点

介绍了一下虚拟列表

3. 请说说ts你用了哪些，你怎么用的

4. 请说说js的array你用过哪些方法有什么用

array的map，foreach，filiter，find

5. 请说说slice方法与splice方法有什么区别干什么的

* slice() 方法返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变

* splice() 方法通过移除或者替换已存在的元素和/或添加新元素就地改变一个数组的内容。其中该方法接收三个参数，分别是start，deleteCount：（一个整数，表示数组中要从 start 开始删除的元素数量。），item1, …, itemN：（从 start 开始要加入到数组中的元素。如果不指定任何元素，splice() 将只从数组中删除元素。）

* 要创建一个删除和/或替换部分内容而不改变原数组的新数组，请使用 toSpliced()。要访问数组的一部分而不修改它，参见 slice()。

6. 请介绍一下浏览器缓存有哪些，并且是什么（强制缓存，协商缓存）

7. 请说说taro与uniapp的区别和异同

* 底层实现不同，taro底层使用的是react而uniapp则是使用的是vue

8. 你能介绍一下taro最近几个版本有什么差别吗

9. js有几种类型分别是什么

* 基本类型： string，number，boolean，undefined，

* 引用类型：array，function，object

10. 介绍一下symbol吧，你在ts中怎么使用的

11. 介绍一下箭头函数和普通函数的区别

* 箭头函数不是匿名函数，不能使用new关键字
* 箭头函数不绑定arguments，取而代之用rest参数...解决
* 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
    箭头函数根本就没有this指针，是最外层代码块的this：也就是继承父执行的上下文中的this
* 箭头函数没有原型属性
* 箭头函数不能当做Generator函数,不能使用yield关键字

12. 那箭头函数可否使用apply，bind，call方法吗

可以，但是：由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this）
```js
// demo 代码
let obj={
    name:'lee',
    num:1,
    newObjFun(str,otherStr){
        if(otherStr){
            str=str+otherStr;
        }
        console.log(str+this.name);
    },
    arrowObjFun:(...b)=>{
        console.log('b',b);
        console.log('this',this)
    }
}

```



13. 请说说小程序的底层设计是什么

https://blog.csdn.net/weixin_45658814/article/details/125655025

* 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View层用来渲染页面结构，App Service层用来逻辑处理、数据请求、接口调用，它们在两个线程（Webview）里运行。
* 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。
[小程序流程](./pic/xcx.png)
* 小程序的渲染层和逻辑层分别由2个线程管理：
```
（1）视图层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。

（2）逻辑层：采用 JsCore 线程运行JS脚本。

视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。
```
* 渲染流程
```
把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。
逻辑层和试图层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。

这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现。

Virtual DOM 大概是这么个过程：用 JS 对象模拟 DOM 树 -> 比较两棵虚拟 DOM 树的差异 -> 把差异应用到真正的 DOM 树上。

页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。

（1）在渲染层把 WXML 转化成对应的 JS 对象。
（2）在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。
（3）经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。

我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。
```

* 双线程模型设计的好处
```
双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。

为什么要这样设计呢，前面也提到了管控和安全，为了解决这些问题，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。

我们可以使用客户端系统的 JavaScript 引擎（iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境），这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口，这就是小程序双线程模型的由来。
```

* 性能优化
主要的优化策略可以归纳为三方面：

启动小程序方面：
> 分包加载
性能优化方式一：分包加载
采用分包加载时，小程序的代码包有两种：
一个“主包”，包含小程序启动时会马上打开的页面代码和相关资源。
多个“分包”，包含其余的代码和资源。
这样，小程序启动时，只需要先将主包下载完成，就可以立刻启动小程序，从而降低小程序代码包的下载时间。

> 控制代码包大小
性能优化方式二：控制代码包大小
精简代码，去掉不必要的WXML结构和未使用的WXSS。
减少在代码包中直接嵌入的资源文件。不是必须的可以放在服务器上。
压缩图片，使用适当的图片格式。


页面及页面层级方面
>合理使用setData调用，减少setData次数和数据量
性能优化方式三：合理使用setData调用，减少setData次数和数据量；

1、setData 工作原理

小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。

在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。

当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。

而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。


2、常见的 setData 操作错误

（1）频繁的去 setData

在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；

（2）每次 setData 都传递大量新数据

由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程

（3）后台态页面进行setData

当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。

数据通信方面：精简代码，降低WXML结构和JS代码的复杂性。
> js中提高数据更新速度
性能优化方式四：js中提高数据更新速度
多次setData合并成一次setData调用，不要过于频繁调用setData。
数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示，且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据。
与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其它字段下。
```js
onShow: function() {
    // 不要频繁调用setData
    this.setData({ a: 1 })
    this.setData({ b: 2 })
    // 绝大多数时候可优化为
    this.setData({ a: 1, b: 2 })
    // 将与界面无关的数据放在data外
    this.setData({myData: {a: '这个字符串在WXML中用到了',b: '这个字符串未在WXML中用到，且很长…’ }})
    // 可以优化为
    this.setData({'myData:{a': '这个字符串在WXML中用到了'})
    this._myData = {b: '这个字符串未在WXML中用到，且很长…'}
}
```
> wxml 中提高数据更新速度
性能优化方式五：wxml 中提高数据更新速度
去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数。
不要在节点的data前缀属性中放置过大的数据，因为事件绑定时需要传输target和currentTarget的dataset




