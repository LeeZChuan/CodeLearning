# 滴滴可能问到的面试题

### 1. css标签继承与权重
id 选择器 #id 100
类选择器 .class 10
标签选择器 div 10
后代选择器 li a 0
### 2. 对于选择器的选择应该是：标签选择器/伪元素选择器>类选择器/属性选择器>id选择器>内联样式

### 3. flex：1 1 0px这三个属性的含义
第一个参数表示：flex-grow 定义了项目的放大比例默认为0，也就是如果存在剩余空间，也不放大
第二个参数表示：flex-shrink定义了项目的缩小比例，默认为1， 如果空间不足，该项目缩小
第三个参数表示：flex-basis给上面两个属性分配多余空间之前，计算是否有多余空间，默认为auto

### 4. 九种跨域方式实现原理 https://juejin.cn/post/6844903767226351623

### 5.  vue3 的 watch 和 watchEffect 的区别

> watchEffect 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。
它接收两个参数。
第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。
第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。
而
> watch 我倒是一直就知道，它的作用就是侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。

### 6. vue-router你使用过吗？使用过 history 方式吗？使用过 hash 方式吗？使用过abstract方式吗？能不能说一下它路由的原理。

hash: 早期前端路由的实现就是基于location.hash来实现的，其实实现原理很简单，location.hash的值就是URL中#后面的内容。
它的实现原理是通过监听 window 下的 hashchange 事件，判断改变的 pathname 属于已记录的哪几个 router 地址，对应的 router-view 容器就渲染相应的路由代码如下：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>
            <a href="#/home">首页</a>
        </li>
        <li>
            <a href="#/about">关于</a>
        </li>
    </ul>

    <!-- 渲染对应的UI -->
    <div id="routerView"></div>

    <script>
        let routerView = document.getElementById('routerView')
        window.addEventListener('hashchange',onHashChange)

        //控制渲染对应的ui
        function onHashChange(){
            switch(location.hash){
                case '#/home':routerView.innerHTML='首页'
                braek;
                case '#/about':routerView.innerHTML='关于'
                break;
                default:return
            }
        }
    </script>
</body>
</html>
```
history: HTML5提供了History API来实现URL的变化，其中最主要的两个API有以下两个
history.pushState()和history.replaceState()。这两个API可以在不进行刷新的情况下，操作浏览器的历史记录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录
而 history 对比 hash 不同的是通过阻塞浏览器 url 地址栏更改之后的跳转，然后将其 pathname 拼接上去，实现路由，具体代码实现如下：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>
            <a href="/home">首页</a>
        </li>
        <li>
            <a href="/about">关于</a>
        </li>
    </ul>

    <!-- 渲染对应的UI -->
    <div id="routerView"></div>
    <script>
        let routerView = document.getElementById('routerView')

        // window.addEventListener('popstate',()=>{
        //     console.log(13)
        // })

        // window.onpopstate = function(){
        //     console.log(13)
        // }

        window.addEventListener('DOMContentLoaded',onLoad)
        // window.addEventListener('popstate',PoPState)          //浏览器的前进后退能匹配
        function onLoad(){
            PoPState()
            let links = document.querySelectorAll('li a[href]')
            links.forEach(a=>{
                a.addEventListener('click',(e)=>{
                    e.preventDefault();      //阻止a标签的href标签
                    
                    history.pushState(null,'',a.getAttribute('href'))
                    PoPState()
                })
            })
        }
        onLoad()
        function PoPState(){
            console.log(location.pathname)
            switch(location.pathname){
                case '/home':
                    routerView.innerHTML = '<h2>home page</h2>'
                    return
                case '/about':
                    routerView.innerHTML = '<h2>about page</h2>'
                    return
                default:
                    return
            }
        }
    </script>
</body>
</html>
```


### 7. 怎么让对象上的属性成为不可更改的属性
vue2 上的这个字段有这个样一个属性
Object.defineProperty 上有一个 writable 属性设置为 false 可以使其对象上的属性不可修改。
对象冻结：Object.freeze(obj),使被冻结的对象不可被修改，不可添加新属性，不可修改值，不可删除
对象密封：Object.seal(obj),使被密封的对象不可添加，不可以改动键值，但能改value
阻止扩展：Object.preventExtensions(obj),阻止对象增加属性，但不会阻止其它操作


### 8. 遍历嵌套对象
编写函数获得对象中的值666，必须使用到 str = 'a.b.c';
```js
// 方法一
const obj = {
    a:{
        b:{
            c:666
        }
    }
}
 
var str = 'a.b.c';
const getData = ()=>{
  var newArr =  str.split('.').reduce((o,s)=>{ return  o[s]},obj)
    return newArr
}
console.log( getData());


// 方法二
const obj = {
    a:{
        b:{
            c:666
        }
    }
}
 
var str = 'a.b.c';
const getData=(obj,str)=>{
 str.split('.').forEach(element =>{ 
     obj= obj[element]
})    
return obj;
}
console.log(getData(obj,str));

```


### 9. webpack 原理
大致就是：

* 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
* 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
* 确定入口：根据配置中的 entry 找出所有的入口文件；
* 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
* 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
* 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
* 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

### 10. babel 原理
babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：

ES6代码输入
babylon 进行解析得到 AST
plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树
用 babel-generator 通过 AST 树生成 ES5 代码

### 11. 有哪些方法可以判断类型
```js
当时我一时紧张，只记起来了两种方式，一种 typeof ,另外一种则是 instanceof ，第三种的是模模糊糊的回答上 Object.prototype.toString 。
typeof 特点：可以准确的判断出原始类型的种类，但是会对 null 判断成 Object ,算是 JS 历史残留问题，引用类型除了 function 能够准确判断出来，其它类型一律会被判断成 Object 类型。
instanceof 特点：可以准确判断出任意数据类型，但不能判断数据类型 null ，且由于原型链可能被修改，就会导致检测结果不准确。
Object.prototype.toString 特点：看名字它是用来将一个值转为字符串的，但其实并不是，它是一个专门检测数据类型的方法。它返回的值是一个形如 [object Object] 的字符串，且什么类型都可以准确判断。
当然，肯定还有其他方法，不过当时我确实是不记得了，后面回想起来一些，也再查了一下，其他方法如下：constructor、Symbol.toStringTag、Object.prototype.isPrototypeOf、Array.isArray、Number.isNaN等等......
```

### 12. 如何判断当前对象的属性
Object.prototype.hasOwnProperty()

### 13. nextTick在哪里使用？原理是？
> nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
> 在修改数据之后立即使用这个方法，获取更新后的 DOM
> 主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法
nextTick 方法主要是使用了宏任务和微任务,定义了一个异步方法.多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。所以这个 nextTick 方法就是异步方法
```
回答范例
nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
Vue有个异步更新策略，意思是如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick

开发时，有两个场景我们会用到nextTick

created中想要获取DOM时
响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度
nextTick签名如下：function nextTick(callback?: () => void): Promise<void>

所以我们只需要在传入的回调函数中访问最新DOM状态即可，或者我们可以await nextTick()方法返回的Promise之后做这件事

在Vue内部，nextTick之所以能够让我们看到DOM更新后的结果，是因为我们传入的callback会被添加到队列刷新函数(flushSchedulerQueue)的后面，这样等队列内部的更新函数都执行完毕，所有DOM操作也就结束了，callback自然能够获取到最新的DOM值
```

### 14. 那vue中是如何检测数组变化的呢？
数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。

是用来函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新。
数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）

vue3：改用 proxy ，可直接监听对象数组的变化。

### 15. 为什么Vue采用异步渲染呢？
Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。
 dep.notify（） 通知 watcher进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一tick中刷新watcher队列（异步）。

 ### 16. vue和react的却别
 ```
  1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
 2.数据渲染：大规模的数据渲染，react更快
 3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
 4.开发风格：react推荐做法jsx + inline style把html和css都写在js了
      vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
```


##  滴滴打车

### 1. 聊聊你的项目吧，有做过哪些数据上报的内容，有做过什么性能优化吗

性能优化：减少http请求
图片类型修改由png/jpg修改成webp
设置合理的缓存
资源合并或者压缩，这一般是webpack做的事情

页面加载时间的方法
1. 压缩css/js文件
2. 合并js/css文件，减少http请求
3. 外部js/css放在底部
4. 减少dom操作，尽可能用变量替代不必要的dom操作

### 2. 你对webpack有什么了解，你知道webpack与vite有什么区别吗


1.开发模式不同

Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。

2.打包效率不同

Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。

3.插件生态不同

Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。

4.配置复杂度不同

Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。

5.热更新机制不同

Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度。

### 3.你对node有什么了解？，说说node
### 4.微前端是什么，介绍一下微前端呗

我了解的微前端技术有：
iframe
single-spa
qiankun 基于 single-spa 方案实现, 更强大更易上手
webpack5 ModuleFederationPlugin（EMP）
microApp

### 5. [{ key: 'x', value: '2' }, { key: 'x', value: '2' }, { key: 'x', value: '3' }]如何去重
### 6. abcd，aba，adbd，如何判断他是不是回文

### 6.请找出abdcdasd这里面的最长不重复的字符串，请返回他的长度

```ts
[{ key: 'x', value: '2' }, { key: 'x', value: '2' }, { key: 'x', value: '3' }]

const fun = (arr) => {
    let obj = {}
    let newSet = new Set();
    let arr = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr.has(i)) {

        } else {

        }
    }
    for () {
        //下次循环就拿到对应的新的arr
    }
}

const fun = (sting) => {
    const stringArray = string.split('');
    const center = Math.ceil(stringArray.length / 2);
    if (let i = 0; i < center; i++) {
        if (stringArray[i].toLocaleUpperCase() !== stringArray[stringArray.length - i].toLocaleUpperCase()) {
            return false;
        }
    }
    return true;
}

const fun1=(string)=>{

}
```
express
koa


### 博研智通

### 1. 高阶函数用过吗？了解过arguments对象吗？

* 函数柯里化，使用场景比如有固定参数你需要动态化，这时候写一个最最基础的方法，然后使用柯里化声明一个新的对象这时候就可以解决这些问题了

### 2. HTTP状态码与304状态码介绍一下

### 3. pinia和vuex区别介绍一下

### 4. vue中$set用法详细讲解

### 5. 详解require和import有什么区别介绍一下

> require 是运行时调用，import 是编译时调用
> require 是 AMD 规范引入方式;import 是 es6 的一个语法标准，如果要兼容浏览器的话必须转化成 es5 的语法
> require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用

### 6. forEach方法如何跳出循环？

### 7. rpc框架了解么？问问你们app是如何通信的

### 8. app的登陆是如何做的，介绍一下？如何判断当前环境是否是app的环境呢？

### 9. 中间件有了解吗，做过中间件吗？

### 10. 如何使用链式进行父子组件传入参数

## 百度一面

### 1. 请讲讲盒子模型有哪几种，他的区别是什么

有两种盒模型，分别是IE盒模型（border-box） 和 W3C标准盒模型（content-box）。
答：IE盒模型，它的元素width、height的值的计算方式包含了content、border和padding等属性的数值，也就是说它的基本宽高大小等于 content + padding + border。

再来说W3C标准盒模型，它的元素width，height的计算方式只包含内容了content 这一个属性的数值，不包含 border 和 padding 元素

### 2. 请问package.json 与package.lock.json版本不一致在安装过程中应该以那个依赖为主
还是以package.lock.json为主，除非你把这个配置文件删除了否则安装的依赖版本还是package.lock.json上的版本

### 3. 请说说vue的生命周期，并讲讲父子组件的生命周期是什么样的

1.vue生命周期
每个vue实例都有一个生命周期 一共分为八个阶段
创建前后： beforeCreate/created 渲染前后： beforeMount/mounted
更新前后： beforeUpdate/updated 销毁前后： beforeDestroy/destroyed

在created周期的时候 就可以访问到this了 也可以调用异步的方法去获取后台的数据
在mounted周期的时候 就能够访问到DOM结构 对dom结构进行一些增删改查的操作 因为在这个时候 dom结构已经渲染完成并挂载在vue实例上面了
当data变化时，会触发beforeUpdate和updated方法
在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。
2.父子组件的生命周期顺序
加载渲染过程：
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
子组件更新过程：父beforeUpdate->子beforeUpdate->子updated->父updated
父组件更新过程：父beforeUpdate->父updated
销毁过程：父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

### 4. 请说说promise对象与async await的区别

1.Promise是ES6，而async是ES7

2.Promise原来有规范的意义，Promise a，b，c，d 等规范，最终确定的是Promise a+ 规范

3.Promise链式操作，自己catch异常。async则要在函数内catch，好在现在catch成本较低

4.Promise有很多并行神器，比如Promise.all\Promise.race等。这些是async没法搞定的

5.Promise是显式的异步，而 Async/await 让你的代码看起来是同步的，你依然需要注意异步

6.Promise即使不支持es6，你依然可以用promise的库或polyfil，而async就很难做，当然也不是不能，成本会高很多

7.async functions 和Array.forEach等结合，很多tc39提案都在路上或者已经实现，处于上升期，而promise也就那样了


### 5. 请说说vue的双向绑定是什么样的（响应式）

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。
> vue3.0使用的是proxy拦截器实现的数据双向绑定

### 6. 请说说vue的响应式？？

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。
> vue3.0使用的是proxy拦截器实现的数据双向绑定


### 7. 如果你有一段代码发现推到远程了，你想重置掉远程代码，但是要保留本地代码，有哪些方法？

面试的时候我说的是，在你的开发分支拉出来一个分支，作为备份分支，

然后git reset --hard
git push origin dev


```
git pull 拉最新代码，提交之类，保证本地代码最新且无修改

git log  查看提交日志

git reset --hard  2ea5c6b311d8c45d62acdd6061a038950ea81b19  回退到要修改这个, --hard 会删除本地未提交的代码，回退回某一个版本，之间的代码不会在暂存区有记录

git reset 6df0437277dd01c29362c690b9448a3f0e72b1ce   再回退到它的上一次提交 ，暂存区会有这次回退之间的内容

git diff  可查看这些内容，可能需要去项目中解决冲突之类

git add . 有修改的话add下

git stash save 权限框     保存2ea5c6b311d8c45d62acdd6061a038950ea81b19提交的内容，至此需要修改的内容就存了下来。

 
git pull  拉下远端代码

git revert 6df0437277dd01c29362c690b9448a3f0e72b1ce 重置要修改的此次提交

git status 查看当前状态

git add .   修改错误后提交

git commit

git push 

git stash list    查看之前存下来的内容。

git stash apply stash@{0}  本地应用保存起来的修改，这样，重置的修改就在本地了
```


### 7. 请介绍一下你的项目吧，有哪些你觉得好的点

### 8. 项目重构为了什么，为什么要项目重构

### 9. 请介绍一下回流重绘吧，有哪些注意的点

### 10. 请说明一下如何隐藏一个元素，有哪些方式，并且他们的差异点有哪些

方法有三个：
display:none; 这个属性用于定义建立布局时元素生成的显示框类型,而none属性可以让元素隐藏

visibility:hidden；这个属性是能见度的意思，使用hidden属性值后可以让元素“隐藏”

opacity:0; 这个属性是透明度的意思，为零即透明度为0，也可以做到隐藏元素的作用


虽然上面三个属性都可以让元素实现“隐藏”的效果但是有的是真的让元素隐藏起来了，但有的只是假的让元素元素“隐藏”起来了，
display:none; 可以直接让元素“消失”而且在页面中不会占元素隐藏前该占的位置

visibility:hidden；和 opacity:0; 虽然也能让元素实现“隐藏”效果，但是他们让元素隐藏后在页面上该占的位置是不会变的，

打个比喻display可以做到让一个元素真真正正的消失，不管他之前占了什么位置有多大，而另外两个更像是让元素隐身起来了，该有的属性是一点不变，只是看不见而已，

那么他们都能用于什么场景呢，比如你想在一个元素上面做一个按钮，让点击这个元素的时候实现按钮一样的效果，但是这个按钮很丑，而且影响客户视觉效果，这时候就可以使用opacity，visibility两个属性了，这样虽然按钮是隐藏的但是功能并不会消失


把[1,2,3,4,5,6,7,8,9,0]变成三个三个的二维数组

1. loadsh的chunk方法
2. 手写一个方法
```js
const convertTo =(arr,size)=>{
    let result=[];
    for(let i=0;i<arr.length;i+=size){
        result.push(arr.slice(i,i+size));
    }
    return result;
}
```


实现一个斐波那契数列
```js
const fib=(n)=>{
    if(n===0||n===1){
        return 1;
    }
    return fib(n-1)+fib(n-2);
}
```

算法优化：dp[i]=dp[i-1]+dp[i-2]
```js
const fib=(n){
    if(n<=1)return n;
    let fib=[0,1];
    for(let i=2;i<=n;i++){
        fib[i]=fib[i-1]+fib[i-2];
    }
    return fib[n];
}
```


## 美团一面

### 1. 请说说点击小程序到底发生了什么


### 2. 请说说小程序的线程会发生哪些操作

* 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View层用来渲染页面结构，App Service层用来逻辑处理、数据请求、接口调用，它们在两个线程（Webview）里运行。
* 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。

### 3. 如何判断一个链表是否有环


```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function detectCycle(head: ListNode | null): ListNode | null {
    if(!head) return null;
        // method: double pointer
    let fast = head;
    let slow = head;
    // fast step moves by two steps,slow moves by one
    while(fast && fast.next!=null && fast.next.next!=null){
        fast = fast.next.next
        slow = slow.next
        if(fast === slow){
            let index1 = fast
            let index2 = head
            while(index1!=index2){
                index1=index1.next
                index2=index2.next
            }
            return index1
        }
    }
    return null

};
```
### 4. 手写promise.all

```js
const PromiseAll = (iterator) => {
  const promises = Array.from(iterator); // 对传入的数据进行浅拷贝，确保有遍历器
  const len = promises.length; // 长度
  let index = 0; // 每次执行成功+1,当等于长度时，说明所有数据都返回，则可以resolve
  let data = []; // 用来存放返回的数据数组
  return new Promise((resolve, reject) => {
    for (let i in promises) {
      promises[i]
        .then((res) => {
          data[i] = res;
          if (++index === len) {
            resolve(data);
          }
        })
        .catch((err) => {
          reject(err);
        });
    }
  });
};

const promise1 = Promise.resolve('promise1');
const promise2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 2000, 'promise2');
});
const promise3 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 1000, 'promise3');
});

PromiseAll([promise1, promise2, promise3]).then(function(values) {
    console.log(values);
});
```
# 推想医疗一面

### 手写promise.all
```ts
const promiseAll = (arr) => {
    const result = [];
    const tempArr = Array.from(arr);
    let resultNumber = 0;
    return new Promise((resole, reject) => {
        tempArr.forEach((item, index) => {
            if (item) {
                // 解析的操作
                Promise.resolve(item).then(res => {
                    result[i] = res;
                    resultNumber++;

                    if (resultNumber === tempArr.length) {
                        resolve(result);
                    }
                }, err => {
                    reject(err);
                })

            });
    })
}
```

### 1. 介绍一下type和interface的区别

> type 可以使用联合类型（|）和交叉类型（&）进行类型组合;而 interface 不支持联合类型和交叉类型。

> type 和 interface 是 TypeScript 中用于定义类型的关键字。
它们在定义对象类型、函数类型和类型组合等方面有一些区别。
type 更灵活，支持联合类型和交叉类型，并且可以使用类型别名来简化复杂的类型定义；
而 interface 支持继承和类的实现。你可以根据具体的使用场景选择合适的方式。

> 

### 2. 介绍一下你的项目

### 3. 请说说以下打印是什么样的
```ts
for(const i=0; i<6; i++){
    console.log(i);
}

for(let i=0; i<6; i++){
    console.log(i);
}

for(var i=0; i<6; i++){
    console.log(i);
}

for(var i=0; i<6; i++){
    setTimeout(()=>{
        console.log(i);
    },0)
}

// 如果想要打印0-5我应该如何修改
```

### 4. 请介绍一下settimeout与promise的打印顺序

### 5. 请说说png和webp的区别吧

 
WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。


结论：建议原创表情尽量控制颜色数在 256 色以内，采用无损压缩性价比最高。
小于 256 色：以图标，图形，剪贴画为代表，最适合采用 WebP 无损压缩，精细度完美，体积大幅减少；
大于 256 色：以多数表情图，广告图为代表，最适合采用 WebP 有损压缩，选择较高压缩比（建议压缩质量为 100% ~ 75%）
远大于 256 色：以风景照，视频截图为代表，最适合采用 WebP 有损压缩，选择适中压缩比（建议压缩质量为 75% 以下）

### 6. 请介绍一下你在项目中做过哪些优化点呢

### 7. 介绍一下虚拟列表的实现思路吧

### 8. 聊聊你参与的项目的基础构建做了哪些吧？

### 9. 如果现在的需求是需要实现一个鼠标滚轮滚动的时候需要让页面左右滚动，应该如何实现

```html
<!DECTYPEhtml>
<html>
    <head><metacharset=‘utf-8’><title>onwheel-test</title></head>
    <body>
        <div id='out'style='width:500px;height:500px;overflow:auto'>
        <div id='inside'style='width:1000px;height:1000px;background-color:gray;overflow:auto'></div>
        </div>
        <script type='application/javascript'>
        var outDiv= document.getElementById('out');  
        outDiv.onwheel=function(event)
        {//禁止事件默认行为（此处禁止鼠标滚轮行为关联到"屏幕滚动条上下移动"行为）
            event.preventDefault();
            //设置鼠标滚轮滚动时屏幕滚动条的移动步长var step=50;
            if(event.deltaY<0){
                //向上滚动鼠标滚轮，屏幕滚动条左移
                this.scrollLeft-= step;
                }else{
                    //向下滚动鼠标滚轮，屏幕滚动条右移
                    this.scrollLeft+= step;
                }
        }
                    /**
            // 如果要手动设置滚动条在Y轴方向的位置可以直接设置scrollTop,例如：
            outDiv.scrollTop = 500;
            // 如果要手动设置滚动条在X、Y轴方向的位置可以使用函数scrollTo,例如设置X轴滚动100，Y轴滚动400：
            outDiv.scrollTo(100,400);
        **/
        </script>
    </body>
</html>
```

## 滴滴网约车小程序一面

### 1. 手写代码：
```js
// 数组打平
// arr = [1,2,3,[4,5,[6,[7]]]]
// level: 1
// [1,2,3,4,5,[6,[7]]]
// level: 2
// [1,2,3,4,5,6,[7]]
// level: >= 3
// [1,2,3,4,5,6,7]
let currentLevel = 1;
const resultArr = [];

function flat(arr, level) {
    let isPush = false;
    if (currentLevel <= level) {
        arr.forEach(arrItem => {
            if (Array.isArray(arrItem)) {
                isPush = true;
                flat(arrItem, level)
            } else {
                resultArr.push(arrItem)
            }
        });
    }
    if (isPush) {
        currentLevel++;
    }

    return resultArr
}
```
### 2. 正则匹配,邮箱匹配
```js
// reg
da@gmail.com

^[a-zA-Z0-9_-]@[a-zA-Z0-9_-].[a-zA-Z]$
string
"[{a,a},{b,b}]
string
a,a b,b

[[]
JSON.parse("string")
```
### 1. 请说说你了解的排序算法（介绍一下快速排序吧）

### 2. 请说说你了解的你认为不错的技术点

介绍了一下虚拟列表

### 3. 请说说ts你用了哪些，你怎么用的

### 4. 请说说js的array你用过哪些方法有什么用

> array的map，foreach，filiter，find

### 5. 请说说slice方法与splice方法有什么区别干什么的

* slice() 方法返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变

* splice() 方法通过移除或者替换已存在的元素和/或添加新元素就地改变一个数组的内容。其中该方法接收三个参数，分别是start，deleteCount：（一个整数，表示数组中要从 start 开始删除的元素数量。），item1, …, itemN：（从 start 开始要加入到数组中的元素。如果不指定任何元素，splice() 将只从数组中删除元素。）

* 要创建一个删除和/或替换部分内容而不改变原数组的新数组，请使用 toSpliced()。要访问数组的一部分而不修改它，参见 slice()。

### 6. 请介绍一下浏览器缓存有哪些，并且是什么（强制缓存，协商缓存）


浏览器有强制缓存与协商缓存两种方式，
关于协商缓存的标识code有：https://blog.csdn.net/testcs_dn/article/details/84833920

* 强制缓存
  
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)：

不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：

![强制缓存](../img/JavaScript/强制缓存.jpg)

控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

Cache-Control、Expires都是缓存到期时间，Cache-Control是相对值，Expires是绝对值，即再次发送请求时，如果时间没到期，强制缓存生效。

注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。

缺点：
缓存过期以后，服务器不管资源有没有变化，都会再次读取资源文件，并返给浏览器。

* 协商缓存
  
当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。

控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，
其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

* Last-Modified / If-Modified-Since
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件;

缺点：
如果资源被修改了，最后修改时间变了，但是内容没有变，会重新请求资源文件。

* Etag / If-None-Match
If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下


缺点：
实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源。


![1](https://img-blog.csdnimg.cn/20210328152529389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTAzNTY3,size_16,color_FFFFFF,t_70)

同时在浏览器取缓存的过程中，有两种取的逻辑，一种是从内存中取缓存，还有一种是从硬盘中取缓存；
> 浏览器读取缓存的顺序为memory –> disk –> 服务器请求。  
> 内存缓存(from memory cache)：内存缓存具有两个特点，分别是速度快和时间限制。

> 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。

### 7. 请说说taro与uniapp的区别和异同

* 底层实现不同，taro底层使用的是react而uniapp则是使用的是vue

### 8. 你能介绍一下taro最近几个版本有什么差别吗

### 9. js有几种类型分别是什么

* 基本类型： string，number，boolean，undefined，

* 引用类型：array，function，object

### 10. 介绍一下symbol吧，你在ts中怎么使用的

> 用于声明哪些不可变化的值

### 11. 介绍一下箭头函数和普通函数的区别

* 箭头函数不是匿名函数，不能使用new关键字
* 箭头函数不绑定arguments，取而代之用rest参数...解决
* 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
    箭头函数根本就没有this指针，是最外层代码块的this：也就是继承父执行的上下文中的this
* 箭头函数没有原型属性
* 箭头函数不能当做Generator函数,不能使用yield关键字

### 12. 那箭头函数可否使用apply，bind，call方法吗

可以，但是：由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this）
```js
// demo 代码
let obj={
    name:'lee',
    num:1,
    newObjFun(str,otherStr){
        if(otherStr){
            str=str+otherStr;
        }
        console.log(str+this.name);
    },
    arrowObjFun:(...b)=>{
        console.log('b',b);
        console.log('this',this)
    },
    commonFunc:function(b){
        console.log('arguments',arguments);
        console.log('this',this);
    },
    arrowAddNumFunc(n){
        let func=(n)=>{
            n+this.num;
        }
        let m={
            num:20
        }
        return func.call(m,n);
    }
}

// 箭头函数是匿名函数，不能作为构造函数，不能使用new
// let a=new obj.commonFuc([1,2,3,4,5],"zhangsan");// 普通函数可以

// this指向
obj.commonFunc([1,2,3,4,5],'zhangsan');
obj.arrowObjFun([1,2,3,4,5],"zhangsan");
let newPerson={
    name:'list'
}
let applyFunc=obj.newObjFun;
// apply和call绑定后会立刻执行
// apply只能穿入数组，但是call可以穿入任何类型的数据
applyFunc.apply(newPerson,['我是'])
applyFunc.call(newPerson,'我是**')
// 而bind不是绑定之后会立刻执行
let newApplyFunc=applyFunc.bind(obj,'我不是');
newApplyFunc('你猜猜');


// 如果是箭头函数
let arrowFunc=obj.arrowObjFun;
arrowFunc.apply(newPerson,['我是箭头函数','箭头函数'])
arrowFunc.call(newPerson,'我是**箭头函数','jiantou')
// 而bind不是绑定之后会立刻执行
let newarrowFunc=arrowFunc.bind(obj,'我不是*箭头函数');
newarrowFunc('你猜猜');

console.log(obj.arrowAddNumFunc(10));
console.log(obj.arrowObjFun.prototype)
console.log(obj.commonFunc.prototype)

```



### 13. 请说说小程序的底层设计是什么

https://blog.csdn.net/weixin_45658814/article/details/125655025

* 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View层用来渲染页面结构，App Service层用来逻辑处理、数据请求、接口调用，它们在两个线程（Webview）里运行。
* 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。
[小程序流程](./pic/xcx.png)
* 小程序的渲染层和逻辑层分别由2个线程管理：
```
（1）视图层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。

（2）逻辑层：采用 JsCore 线程运行JS脚本。

视图层和逻辑层通过系统层的 WeixinJsBridage 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。
```
* 渲染流程
```
把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。
逻辑层和试图层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。

这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现。

Virtual DOM 大概是这么个过程：用 JS 对象模拟 DOM 树 -> 比较两棵虚拟 DOM 树的差异 -> 把差异应用到真正的 DOM 树上。

页面渲染的具体流程是：在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。

（1）在渲染层把 WXML 转化成对应的 JS 对象。
（2）在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。
（3）经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。

我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。
```

* 双线程模型设计的好处
```
双线程模型是小程序框架与业界大多数前端 Web 框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。

为什么要这样设计呢，前面也提到了管控和安全，为了解决这些问题，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。

我们可以使用客户端系统的 JavaScript 引擎（iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境），这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口，这就是小程序双线程模型的由来。
```

* 性能优化
主要的优化策略可以归纳为三方面：

启动小程序方面：
> 分包加载
性能优化方式一：分包加载
采用分包加载时，小程序的代码包有两种：
一个“主包”，包含小程序启动时会马上打开的页面代码和相关资源。
多个“分包”，包含其余的代码和资源。
这样，小程序启动时，只需要先将主包下载完成，就可以立刻启动小程序，从而降低小程序代码包的下载时间。

> 控制代码包大小
性能优化方式二：控制代码包大小
精简代码，去掉不必要的WXML结构和未使用的WXSS。
减少在代码包中直接嵌入的资源文件。不是必须的可以放在服务器上。
压缩图片，使用适当的图片格式。


页面及页面层级方面
>合理使用setData调用，减少setData次数和数据量
性能优化方式三：合理使用setData调用，减少setData次数和数据量；

1、setData 工作原理

小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。

在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。

当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。

而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。


2、常见的 setData 操作错误

（1）频繁的去 setData

在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；

（2）每次 setData 都传递大量新数据

由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程

（3）后台态页面进行setData

当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。

数据通信方面：精简代码，降低WXML结构和JS代码的复杂性。
> js中提高数据更新速度
性能优化方式四：js中提高数据更新速度
多次setData合并成一次setData调用，不要过于频繁调用setData。
数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示，且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据。
与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其它字段下。
```js
onShow: function() {
    // 不要频繁调用setData
    this.setData({ a: 1 })
    this.setData({ b: 2 })
    // 绝大多数时候可优化为
    this.setData({ a: 1, b: 2 })
    // 将与界面无关的数据放在data外
    this.setData({myData: {a: '这个字符串在WXML中用到了',b: '这个字符串未在WXML中用到，且很长…’ }})
    // 可以优化为
    this.setData({'myData:{a': '这个字符串在WXML中用到了'})
    this._myData = {b: '这个字符串未在WXML中用到，且很长…'}
}
```
> wxml 中提高数据更新速度
性能优化方式五：wxml 中提高数据更新速度
去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数。
不要在节点的data前缀属性中放置过大的数据，因为事件绑定时需要传输target和currentTarget的dataset


### 14. 说说浏览器缓存吧，有哪些

浏览器有强制缓存与协商缓存两种方式，
关于协商缓存的标识code有：https://blog.csdn.net/testcs_dn/article/details/84833920

* 强制缓存
  
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)：

不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：

![强制缓存](../img/JavaScript/强制缓存.jpg)

控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

Cache-Control、Expires都是缓存到期时间，Cache-Control是相对值，Expires是绝对值，即再次发送请求时，如果时间没到期，强制缓存生效。

注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。

缺点：
缓存过期以后，服务器不管资源有没有变化，都会再次读取资源文件，并返给浏览器。

* 协商缓存
  
当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。

控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，
其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

* Last-Modified / If-Modified-Since
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件;

缺点：
如果资源被修改了，最后修改时间变了，但是内容没有变，会重新请求资源文件。

* Etag / If-None-Match
If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下


缺点：
实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源。


![1](https://img-blog.csdnimg.cn/20210328152529389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTAzNTY3,size_16,color_FFFFFF,t_70)

同时在浏览器取缓存的过程中，有两种取的逻辑，一种是从内存中取缓存，还有一种是从硬盘中取缓存；
> 浏览器读取缓存的顺序为memory –> disk –> 服务器请求。  
> 内存缓存(from memory cache)：内存缓存具有两个特点，分别是速度快和时间限制。

> 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。


# 去哪网一面

## 1.看看这个如何打印
```js
A.prototype.x=10;
const a1=new A();
A.prototype={x:20,y:30};
const a2=new A();
console.log(a1.x);
console.log(a1.y);
console.log(a2.x);
console.log(a2.y);
```

## 2.看看这个css样式是什么样的

```html
<div class="lightblue">
    <div class="drakblue">
        <p>drakblue</p>
    </div>
</div>

<div class="drakblue">
    <div class="lightblue">
        <p>drakblue</p>
    </div>
</div>

	<style>

/** 这里的颜色就是那个标签是那个颜色 */
.lightblue{
    background-color:lightblue;
}
.drakblue{
    background-color:blue;
}


/** 但是一旦出现了标签选择器，那么就会是使用最近（最后声明的）的这个标签属性，也就是drakblue p这个属性 */
.lightblue p{
    background-color:lightblue;
}
.drakblue p{
    background-color:blue;
}
	</style>
```

## 3.看看下列代码那里有问题
```js
const axios = require('@qnpm/qaxios');
const URL = 'http://xxxx.xx.com/getList';

module.exports = function (req, res, next) {
    axios(URL, {
        timeout: 60,
        data: Object.assign({}, {
            extInfo: req.extInfo || ''
        }),
        responseDataType: 'string'
    }).then(function (res) {
        const { data } = res;
        // {
        //     code:,
        //     data:"134",
        // }
        // 问题：JSON.parse校验入参数string，“asd”
        // “[{}]”,"[]","dasd"
        // 1:String
        // 2:[]
        // 
        data = JSON.parse(data);
        const resultNo = data.codeNo + 32;
        res.send('200', resultNo)
    }).catch(function (err) {
        res.send(500, 'error')
    });
};


const axios = require('@qnpm/qaxios');
const URL = 'http://xxxx.xx.com/getList';

module.exports = function (req, res, next) {
    axios(URL, {
        timeout: 60,
        data: Object.assign({}, {
            extInfo: req.extInfo || ''
        }),
        responseDataType: 'string'
    }).then(function (res) {
        const { data } = res;
        data = JSON.parse(data);
        const resultNo = data.codeNo + 32;
        res.send('200', resultNo)
    }).catch(function (err) {
        res.send(500, 'error')
    });
};
```

# 百度文库一面

## 1.说一下eventloop


## 2.说一下这个代码的打印

```js
// 先是执行微任务，再是宏任务
var r=new Promise(function(resolve,reject){
    var begin=Date.now();
    while(Date.new()-begin<1000){
        console.log("a");
        resolve
    }
})

setTimeout(()=>{
    console.log("b")
},0);

r.then(()=>{
    console.log("c");
})

console.log("d");
```

## 3.说一下promiseall你的使用场景有哪些，简单介绍一下

## 4.实现一个promiseMyall
```js
// 手动实现一个promiseMyrace
Promise.race = (promises)=> {
  return new Promise((resolve, reject)=> {
    for (let i = 0; i < promises.length; i++) {
      promises[i].then(resolve, reject);
    }
  });
};

// 手动实现一个promiseMyall
const romiseMyall = (arr) => {
    const tempArr = Array.from(arr);
    const resultArr = [];
    let sumIndex = 0;

    return new Promise((resolve, reject) => {
        tempArr.forEach((item, index) => {
            if (item) {
                // 解析的操作
                Promise.resolve(item).then(res => {
                    result[i] = res;
                    sumIndex++;
                    if (sumIndex === tempArr.length) {
                        resolve(result);
                    }
                }, err => {
                    reject(err);
                })

                // // item {}
                // // item()
                // // 我们内部写的一个方法或者封装的组件
                // item().then((res) => {
                //     resultArr.push(res);
                //     sumIndex++;
                //     if (sumIndex === tempArr.length) {
                //         // 当前
                //         resolve(resultArr);
                //     };
                // }).catch(error => {
                //     reject(error)
                // })
                // // 2 {} //接口请求返回的结果
                // resultArr.push(item);
                // sumIndex++;
                // if (sumIndex === tempArr.length) {
                //     // 当前
                //     resolve(resultArr);
                };

            }
        })
    });
}
```
## 5.模块化commonjs 和esmodle介绍一下吧

### commonjs--(require/export)
> commonjs也叫cjs,在node中每一个js文件都是一个单独的模块,这个模块中包含CommonJS的规范的核心变量: exports， module.exports, require,exports和module.exports可以负责对模块中的内容进行导出。require函数可以帮助我们导入其他模块（自定义模块，系统模块，第三方库）。
```ts
// exports和module.exports之间的区别
1、每一个模块都是一个module模块，也就是module。
2、node中导出的不是exports,而是module.exports。
3、也就是说exports和module.exports本来指向的是同一个引
用地址，但是真正导入的是module.exports,所以当我们手动更改
exports = {},这样就会报错，我们只能改属性。
```

```ts
// require的引入规则
1、如果存在核心模块（path, url）等，可以直接引入即可。
2、如果使用./x或者../x以及/x等来引入的话，首先会先找到相应目录下面的x文件，没有找x.js,x.json,x.node,还没有找到就去找./x/index.js, ./x/index.json,./x/index.node文件，如果都不存在，则报错。
3、如果为第三方库，则按照类似于这种规则进行查找。
/*
[
  'D:\\web前端开发\\javascript高级\\二十五\\一、require的查找规则\\node_modules',
  'D:\\web前端开发\\javascript高级\\二十五\\node_modules',
  'D:\\web前端开发\\javascript高级\\node_modules',
  'D:\\web前端开发\\node_modules',
  'D:\\node_modules'
]
*/
4、require在进行加载模块的时候，后执行一遍里面的代码，但是当该模块中多次引入该模块，则require只会执行一次，因为存在缓存(module中存在loaded函数)。

```

```ts
// commonjs的缺点
1、commonjs加载是同步的，所以必须等到相应的模块加载完毕，
在会执行后续代码，在node环境中使用，没有什么问题，因为node
的js文件都是本地的。
2、如果要是在浏览器中执行，因为浏览器中都是从远程服务器上请
求到的，同步势必会引起一些卡顿。
3、但是在webpack中可以使用commonjs是因为webpack可以对其
进行打包处理。

```


### esmodule--（import/export）


```js
// 基本使用
1、在浏览器上使用esmodule必须加上type = 'module'
2、必须需要开启服务器(live server)
3、在js中引入文件的时候，必须要加上'.js'.
```


```js
// 三种导出方式
//1、第一种导出方式
export const name = 'dl'
export const age = 20
//2、第二种导出方式（集体导出）
const name = '董礼'
const age = 20
function sum(num1, num2) {
	return num1 + num2
}
export {  //注意：这里不是对象，这里必须这样写
  name, 
  age,
  sum
}
//三、第三种导出方式，起别名
const name = 'dl'
const age = 20
export {
	name as FName,
	age as FAge
}

//三种导入方式
//第一种导入方式
import {
	name,
	age,
	sum
} from './foo.js'
//二、第二种导入方式，起别名
import { name as Fname, age as FAage } from './foo.js'
//三、第三种导入方式
import * as foo from './foo.js'


//default默认导出
const foo = 'foo value'
export default foo

//默认导出二
export {
  name,
  age,
  foo as default
} 


//import函数
//为什么要有import函数
因为在使用import xx from 'xx'的时候，不能将其写在逻辑代码中。
if(true) {
	import xx from 'xxx'
}
esmodule在被js引擎解析的时候，就必须知道他的依赖关系，但是
一些请款下，我们确确实实希望动态来加载一个模块。所以我们可以
使用import()函数来实现异步加载，浏览器调用另一个线程进行下
载，然后不会阻塞js线程。import()函数返回的是一个promise
函数，所以在拿到结果的时候需要使用.then来获取相应的值，
import.meta:es11中新增的一个属性，可以拿到当前文件的url
地址。

```

### 其他总结
> require 是运行时调用，import 是编译时调用
> require 是 AMD 规范引入方式;import 是 es6 的一个语法标准，如果要兼容浏览器的话必须转化成 es5 的语法
> require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用


### 两种的区别
```js
4.1、commonjs是对模块的浅拷贝，esmodule是对模块的引用。
4.2、import的接口是read-only（只读状态），不能修改其变量
值。即不能修改变量的指针指向，但是可以改变变量内部的指针指
向，可以对commonjs对重新赋值，但是esmodule赋值会编译报错。
```



// 
### 6.链表翻转
```js
//1 ，2，3，4，5
//arr数组去储存当前value，利用数组方法
// {
//     value:1,
//     next:{
//         value:2,
//         next:{

//         }
//     }
// }

function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val)
    this.next = (next === undefined ? null : next)
}


function reverseList(head) {
    // 翻转
    if (head === null) {
        return '';
    }
    let result=null;
    let current=head;
    while (current) {
        const nextResult = current.next;
        current.next=result;
        console.log(head,'head')
        result = current;
        current=nextResult;
    }
    return result;
}

function main() {
    let head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    let result = reverseList(head);
    let list = '';
    while (result != null) {
        list += result.val + (result.next ? "->" : "");
        result = result.next;
    }
    console.log(list);
}
main();
```

### 7.百度的性能监控与报表
底层使用的是：window.performance.timing这里面的参数

```js
connectEnd
: 
1690786434604
connectStart
: 
1690786434325
domComplete
: 
1690786438335
domContentLoadedEventEnd
: 
1690786436693
domContentLoadedEventStart
: 
1690786436683
domInteractive
: 
1690786435792
domLoading
: 
1690786435432
domainLookupEnd
: 
1690786434320
domainLookupStart
: 
1690786434320
fetchStart
: 
1690786434320
loadEventEnd
: 
1690786438339
loadEventStart
: 
1690786438335
navigationStart
: 
1690786434316
redirectEnd
: 
0
redirectStart
: 
0
requestStart
: 
1690786434604
responseEnd
: 
1690786435674
responseStart
: 
1690786435429
secureConnectionStart
: 
1690786434325
unloadEventEnd
: 
0
unloadEventStart
: 
0
```


### 8.百度小程序使用的底层

<!-- okam这个框架，基于原生使用的是vue底层进行封装的 -->


### 高途教育


### 1.介绍一下你的项目吧，

### 2.说一下浏览器的缓存有哪些


### 3.介绍一下强制缓存的cache-control的no catch与no store

### 4.说一下你的项目如果是存在登陆出错与弱网的时候应该如何解决


### 5.介绍一下px/rem/em的区别和差异

对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。

1. em
是一个相对单位。相对于当前对象内文本的font-size，如果当前文本的字体尺寸没有设置，则相对于浏览器的默认字体尺寸。即1em=16px

2. rem
是一个相对单位。是相对HTML根元素。

像素（px）：用于元素的边框或定位。

em/rem：用于做响应式页面，不过我更倾向于rem，因为em不同元素的参照物不一样（都是该元素父元素），所以在计算的时候不方便，相比之下rem就只有一个参照物（html元素），这样计算起来更清晰


### 6.说说script标签的differ和sync有什么用


### 7.说说浏览器攻击的csrf与依赖注入攻击如何防范


一、XSS(Cross Site Scripting)跨站JS脚本攻击，如何防范？

* 针对接口进行 XSS攻击，即把js脚本或者带恶意js脚本的html标签，作为GET或者POST参数提交到服务器，然后服务器解释并响应
* 防范方式：
* 1）提交数据前前端要做数据校验，对用户输入的信息(js代码及dom节点)进行过滤。
* 2）对重要的cookie设置为httponly（服务器端可设置此字段），客户端就没有操作此cookie的权限。
* 3）服务器端也要数据合法性校验
针对DOM本身进行 XSS攻击，如果本身页面代码中使用了window.eval来执行代码。eval本身会把一段字符串变成可执行的js代码，这是非常危险的。还有拼接html字符串后直接显示DOM时也会遇到同样的问题。防范方式：尽量避免使用eval，拼接html字符串时应校验字符串的合法性，过滤非法元素节点与属性节点,如iframe,script标签，onerror事件, style, src, href等。
 
* 可能产生危害：泄露了个人的cookie信息，身份认证被套取后，被用作非法用途

* 非法字符过滤可以使用第三方的过滤库如：HTMLParser.js及he.js

二、CSRF(Cross-site request forgery)跨站请求(GET和POST)伪造攻击，如何防范？ 

* 由于浏览器一般都是可同时打开多标签的。举个例了，现浏览器同时打开了两个标签，一个是已被合法登录并保持登录状态的网站A，另外一个是已被欺骗打开的含恶意代码的网站B（不一定是来源于非法网站，也可能藏在各大合法论坛上的一些非法链接被你打开了），则可以通过在恶意网站B上静态或者动态创建img,script等标签发起GET或者POST请求，发出的恶意请求是身份认证后的，这就构成CSRF攻击了。将其src属性指向发起对A网站的接口请求（如一个GET请求：api.a.com/blog/del?id=1）。通过标签的方式发起的请求不受同源策略的限制。

* 可能产生危害：模拟表单提交盗取用户资金，篡改目标网站上的用户数据，盗取用户隐私数据

* 防范方式：
* 1）后端接口要对接口请求来源如（* Referer:）字段进行合法校验。
* 2）添加token，带token请求。


三、SQL注入，攻击如何防范？

1. 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双"-"进行转换等。

2. 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。

3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

4. 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。

5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装

6. sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky,网站平台就有亿思网站安全平台检测工具。


四、接口访刷问题，前端如何与后端配合？

* 在IT行业混得有一点资历的人估计都会遇到过接口被刷的情况了。如：听说搞某某活动，大奖瞬间被刷走。某某营销活动，奖品瞬间被抢光了。某某平台，短信验证码几天被刷到欠费。

认真去查查记录，发现这些行为都是人家用机器写程序自动刷你接口的。现在还有卡商有各种短信接码平台，专业批量接发验证码的。

如何能更好的做接口防刷：

1. 发送请求之前前端这边要做人机识别。（如微信的静默授权返回一次唯一码，小程序的wx.login接口返回的code，可供后端二次验证，还有发送短信验证码前要手动先输入验证码，或者使用拖动方块填充缺块那种人机识明系统）

2. 接口传参要带加密签名。


### 8.你对cookie的http-only有什么了解吗


### 9.说说map和weakmap吧

WeakMap
1:什么是WeakMap
WeakMap是ES6中新增的一种集合类型，叫做'弱映射'。它和Map是兄弟关系，与Map的区别在于这个弱字，API还是Map那套API

什么是弱引用
是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问的，并因此可能在任何时刻被回收。


Map和WeakMap区别
Map的键可以是任意类型，WeakMap只接受对象作为键，不接受其它类型的值作为键
Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键；WeakMap的键是弱引用，键所指向的对象是可以被垃圾回收，此时键是无效的。
Map可以被遍历，WeakMap不能被遍历


强引用和弱引用
1 .强引用：将对象保留在内存中的引用
```js
let cat={name:"cat"}
 const pets=[cat]
// cat=null:对原来没影响，值还是原来的
//cat.name="mouse" 原来数组的值变了,变为mosue
同理 cat.name=null也是会变得

let cat={name:"cat",likes:{name:"123",age:10}}
const pets=[cat]
cat.likes=null
//里面嵌套的就是会变成null，有改变了
console.log(pets)
```
6 .垃圾回收机制将不会考虑这个引用。只要所引用的对象的其他引用被清除，垃圾回收机制就会释放改对象所占用的内存。一旦不需要，weakMap里面的键名对象和所对应的键值对会自动消失，不需要手动删除引用
7 .如果你想要往一个对象上添加数据，又不像干扰垃圾回收机制，就可以使用weakMap

WeakMap使用场景-他的键对应的对象，可能会在未来消失，weakMap有助于防止内存泄漏
1 .在DOM对象上保存相关数据.当dom删除的时候，相关联的对象会自动删除，不需要自己管理
2 .数据缓存：当我们需要关联对象和数据。在不修改原有对象的情况下存储某些属性或者根据对象存储一些计算值。又不想管这些对象的死活，非常适合使用这个。
3 .实现私有变量


### 10.说说useEffect的几种情况吧


### 11.说说Webpack文件指纹和JS文件采用[chunkhash]文件指纹策略，CSS文件采用[contenthash]文件指纹策略

> Hash

和整个项目的构建相关，只要项目文件有修改，整个项目构建的hash值就会更改，并且全部文件都共用相同的hash值

> Chunkhash

和webpack打包的chunk有关，不同的entyr会生成不同的Chunkhash值（一个页面的值改变了并不会影响另一个页面，js文件一般采用此方法），chunkhash和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。

> Contenthash

根据文件内容来定义hash，文件内容不变，则contenthash不变（css文件一般采用此方法）。

比如文件index.css被index.js引用了，所以共用相同的chunkhash值。但是这样子有个问题，如果index.js更改了代码，css文件就算内容没有任何改变，由于是该模块发生了改变，导致css文件会重复构建。
这个时候，我们可以使用extra-text-webpack-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建。


### 12.说说compated与watch还有metod有什么区别和差异

### 13.说说你觉得一个产品的数据分析应该如何做，你了解过你的产品的收益是多少吗？比如pv/uv


### 14.聊聊你知道的垃圾回收吧

### 15.你提到了标记的垃圾回收，说说什么是标记法的垃圾回收呢？


### 16.聊聊你觉得如果要学习一个你没有接触过的，你应该如何学习呢？


### 17.看你之前喜欢可视化，你现在如果还是去做可视化相关的内容吗


### 18.你知道srcipt标签的defer和async吗

```js
<script>标签

阻塞html parsing
脚本将会立即被请求和执行
脚本执行完毕后, 继续进行html parsing
<script async>标签

脚本的请求将会和html parsing 并行执行
脚本请求完成后将会立即执行(此时可能html parsing并未完成)
当此脚本与其他脚本无关时使用
<script defer>标签

脚本的请求将会和html parsing 并行执行
当html parsing 结束后才会执行脚本
如果有多个<script defer>标签, 它们将按照它们出现的顺序依次执行
注意

如果<script>标签中没有src属性, async和defer将会被忽略
```

### 19.说说vue的响应式如何实现的，优势是什么？


### 20.vue2如何实现的数组变化进行的监听？








