滴滴可能问到的面试题

1. css标签继承与权重
id 选择器 #id 100
类选择器 .class 10
标签选择器 div 10
后代选择器 li a 0
2. 对于选择器的选择应该是：标签选择器/伪元素选择器>类选择器/属性选择器>id选择器>内联样式

3. flex：1 1 0px这三个属性的含义
第一个参数表示：flex-grow 定义了项目的放大比例默认为0，也就是如果存在剩余空间，也不放大
第二个参数表示：flex-shrink定义了项目的缩小比例，默认为1， 如果空间不足，该项目缩小
第三个参数表示：flex-basis给上面两个属性分配多余空间之前，计算是否有多余空间，默认为auto

4. 九种跨域方式实现原理 https://juejin.cn/post/6844903767226351623

5.  vue3 的 watch 和 watchEffect 的区别

> watchEffect 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。
它接收两个参数。
第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。
第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。
而
> watch 我倒是一直就知道，它的作用就是侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。

6. vue-router你使用过吗？使用过 history 方式吗？使用过 hash 方式吗？使用过abstract方式吗？能不能说一下它路由的原理。
hash: 早期前端路由的实现就是基于location.hash来实现的，其实实现原理很简单，location.hash的值就是URL中#后面的内容。
它的实现原理是通过监听 window 下的 hashchange 事件，判断改变的 pathname 属于已记录的哪几个 router 地址，对应的 router-view 容器就渲染相应的路由代码如下：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>
            <a href="#/home">首页</a>
        </li>
        <li>
            <a href="#/about">关于</a>
        </li>
    </ul>

    <!-- 渲染对应的UI -->
    <div id="routerView"></div>

    <script>
        let routerView = document.getElementById('routerView')
        window.addEventListener('hashchange',onHashChange)

        //控制渲染对应的ui
        function onHashChange(){
            switch(location.hash){
                case '#/home':routerView.innerHTML='首页'
                braek;
                case '#/about':routerView.innerHTML='关于'
                break;
                default:return
            }
        }
    </script>
</body>
</html>
```
history: HTML5提供了History API来实现URL的变化，其中最主要的两个API有以下两个
history.pushState()和history.replaceState()。这两个API可以在不进行刷新的情况下，操作浏览器的历史记录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录
而 history 对比 hash 不同的是通过阻塞浏览器 url 地址栏更改之后的跳转，然后将其 pathname 拼接上去，实现路由，具体代码实现如下：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>
            <a href="/home">首页</a>
        </li>
        <li>
            <a href="/about">关于</a>
        </li>
    </ul>

    <!-- 渲染对应的UI -->
    <div id="routerView"></div>
    <script>
        let routerView = document.getElementById('routerView')

        // window.addEventListener('popstate',()=>{
        //     console.log(13)
        // })

        // window.onpopstate = function(){
        //     console.log(13)
        // }

        window.addEventListener('DOMContentLoaded',onLoad)
        // window.addEventListener('popstate',PoPState)          //浏览器的前进后退能匹配
        function onLoad(){
            PoPState()
            let links = document.querySelectorAll('li a[href]')
            links.forEach(a=>{
                a.addEventListener('click',(e)=>{
                    e.preventDefault();      //阻止a标签的href标签
                    
                    history.pushState(null,'',a.getAttribute('href'))
                    PoPState()
                })
            })
        }
        onLoad()
        function PoPState(){
            console.log(location.pathname)
            switch(location.pathname){
                case '/home':
                    routerView.innerHTML = '<h2>home page</h2>'
                    return
                case '/about':
                    routerView.innerHTML = '<h2>about page</h2>'
                    return
                default:
                    return
            }
        }
    </script>
</body>
</html>
```


7. 怎么让对象上的属性成为不可更改的属性
vue2 上的这个字段有这个样一个属性
Object.defineProperty 上有一个 writable 属性设置为 false 可以使其对象上的属性不可修改。
对象冻结：Object.freeze(obj),使被冻结的对象不可被修改，不可添加新属性，不可修改值，不可删除
对象密封：Object.seal(obj),使被密封的对象不可添加，不可以改动键值，但能改value
阻止扩展：Object.preventExtensions(obj),阻止对象增加属性，但不会阻止其它操作


8. 遍历嵌套对象
编写函数获得对象中的值666，必须使用到 str = 'a.b.c';
```js
// 方法一
const obj = {
    a:{
        b:{
            c:666
        }
    }
}
 
var str = 'a.b.c';
const getData = ()=>{
  var newArr =  str.split('.').reduce((o,s)=>{ return  o[s]},obj)
    return newArr
}
console.log( getData());


// 方法二
const obj = {
    a:{
        b:{
            c:666
        }
    }
}
 
var str = 'a.b.c';
const getData=(obj,str)=>{
 str.split('.').forEach(element =>{ 
     obj= obj[element]
})    
return obj;
}
console.log(getData(obj,str));

```


9. webpack 原理
大致就是：

* 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
* 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
* 确定入口：根据配置中的 entry 找出所有的入口文件；
* 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
* 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
* 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
* 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

10. babel 原理
babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：

ES6代码输入
babylon 进行解析得到 AST
plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树
用 babel-generator 通过 AST 树生成 ES5 代码

11. 有哪些方法可以判断类型
```js
当时我一时紧张，只记起来了两种方式，一种 typeof ,另外一种则是 instanceof ，第三种的是模模糊糊的回答上 Object.prototype.toString 。
typeof 特点：可以准确的判断出原始类型的种类，但是会对 null 判断成 Object ,算是 JS 历史残留问题，引用类型除了 function 能够准确判断出来，其它类型一律会被判断成 Object 类型。
instanceof 特点：可以准确判断出任意数据类型，但不能判断数据类型 null ，且由于原型链可能被修改，就会导致检测结果不准确。
Object.prototype.toString 特点：看名字它是用来将一个值转为字符串的，但其实并不是，它是一个专门检测数据类型的方法。它返回的值是一个形如 [object Object] 的字符串，且什么类型都可以准确判断。
当然，肯定还有其他方法，不过当时我确实是不记得了，后面回想起来一些，也再查了一下，其他方法如下：constructor、Symbol.toStringTag、Object.prototype.isPrototypeOf、Array.isArray、Number.isNaN等等......
```

12. 如何判断当前对象的属性
Object.prototype.hasOwnProperty()

13. nextTick在哪里使用？原理是？
> nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
> 在修改数据之后立即使用这个方法，获取更新后的 DOM
> 主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法
nextTick 方法主要是使用了宏任务和微任务,定义了一个异步方法.多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。所以这个 nextTick 方法就是异步方法
```
回答范例
nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM
Vue有个异步更新策略，意思是如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick

开发时，有两个场景我们会用到nextTick

created中想要获取DOM时
响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度
nextTick签名如下：function nextTick(callback?: () => void): Promise<void>

所以我们只需要在传入的回调函数中访问最新DOM状态即可，或者我们可以await nextTick()方法返回的Promise之后做这件事

在Vue内部，nextTick之所以能够让我们看到DOM更新后的结果，是因为我们传入的callback会被添加到队列刷新函数(flushSchedulerQueue)的后面，这样等队列内部的更新函数都执行完毕，所有DOM操作也就结束了，callback自然能够获取到最新的DOM值
```

14. 那vue中是如何检测数组变化的呢？
数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。

是用来函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新。
数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测）

vue3：改用 proxy ，可直接监听对象数组的变化。

15. 为什么Vue采用异步渲染呢？
Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。
 dep.notify（） 通知 watcher进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一tick中刷新watcher队列（异步）。

 16. vue和react的却别
 ```
  1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
 2.数据渲染：大规模的数据渲染，react更快
 3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
 4.开发风格：react推荐做法jsx + inline style把html和css都写在js了
      vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
```


##  滴滴打车

### 1. 聊聊你的项目吧，有做过哪些数据上报的内容，有做过什么性能优化吗

性能优化：减少http请求
图片类型修改由png/jpg修改成webp
设置合理的缓存
资源合并或者压缩，这一般是webpack做的事情

页面加载时间的方法
1. 压缩css/js文件
2. 合并js/css文件，减少http请求
3. 外部js/css放在底部
4. 减少dom操作，尽可能用变量替代不必要的dom操作

### 2. 你对webpack有什么了解，你知道webpack与vite有什么区别吗


1.开发模式不同

Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。

2.打包效率不同

Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。

3.插件生态不同

Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。

4.配置复杂度不同

Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。

5.热更新机制不同

Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度。

### 3.你对node有什么了解？，说说node
### 4.微前端是什么，介绍一下微前端呗

我了解的微前端技术有：
iframe
single-spa
qiankun 基于 single-spa 方案实现, 更强大更易上手
webpack5 ModuleFederationPlugin（EMP）
microApp

### 5. [{ key: 'x', value: '2' }, { key: 'x', value: '2' }, { key: 'x', value: '3' }]如何去重
### 6. abcd，aba，adbd，如何判断他是不是回文

### 6.请找出abdcdasd这里面的最长不重复的字符串，请返回他的长度

```ts
[{ key: 'x', value: '2' }, { key: 'x', value: '2' }, { key: 'x', value: '3' }]

const fun = (arr) => {
    let obj = {}
    let newSet = new Set();
    let arr = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr.has(i)) {

        } else {

        }
    }
    for () {
        //下次循环就拿到对应的新的arr
    }
}

const fun = (sting) => {
    const stringArray = string.split('');
    const center = Math.ceil(stringArray.length / 2);
    if (let i = 0; i < center; i++) {
        if (stringArray[i].toLocaleUpperCase() !== stringArray[stringArray.length - i].toLocaleUpperCase()) {
            return false;
        }
    }
    return true;
}

const fun1=(string)=>{

}
```
express
koa


### 博研智通

1. 高阶函数用过吗？了解过arguments对象吗？

2. HTTP状态码与304状态码介绍一下

3. pinia和vuex区别介绍一下

4. vue中$set用法详细讲解

5. 详解require和import有什么区别介绍一下

6. forEach方法如何跳出循环？

7. rpc框架了解么？问问你们app是如何通信的

8. app的登陆是如何做的，介绍一下？如何判断当前环境是否是app的环境呢？

9. 中间件有了解吗，做过中间件吗？

10. 如何使用链式进行父子组件传入参数

## 百度一面

1. 请讲讲盒子模型有哪几种，他的区别是什么

有两种盒模型，分别是IE盒模型（border-box） 和 W3C标准盒模型（content-box）。
答：IE盒模型，它的元素width、height的值的计算方式包含了content、border和padding等属性的数值，也就是说它的基本宽高大小等于 content + padding + border。

再来说W3C标准盒模型，它的元素width，height的计算方式只包含内容了content 这一个属性的数值，不包含 border 和 padding 元素

2. 请问package.json 与package.lock.json版本不一致在安装过程中应该以那个依赖为主
还是以package.lock.json为主，除非你把这个配置文件删除了否则安装的依赖版本还是package.lock.json上的版本

3. 请说说vue的生命周期，并讲讲父子组件的生命周期是什么样的

1.vue生命周期
每个vue实例都有一个生命周期 一共分为八个阶段
创建前后： beforeCreate/created 渲染前后： beforeMount/mounted
更新前后： beforeUpdate/updated 销毁前后： beforeDestroy/destroyed

在created周期的时候 就可以访问到this了 也可以调用异步的方法去获取后台的数据
在mounted周期的时候 就能够访问到DOM结构 对dom结构进行一些增删改查的操作 因为在这个时候 dom结构已经渲染完成并挂载在vue实例上面了
当data变化时，会触发beforeUpdate和updated方法
在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。
2.父子组件的生命周期顺序
加载渲染过程：
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
子组件更新过程：父beforeUpdate->子beforeUpdate->子updated->父updated
父组件更新过程：父beforeUpdate->父updated
销毁过程：父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

4. 请说说promise对象与async await的区别


5. 请说说vue的双向绑定是什么样的（响应式）

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。
> vue3.0使用的是proxy拦截器实现的数据双向绑定

6. 请说说vue的响应式？？

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。
> vue3.0使用的是proxy拦截器实现的数据双向绑定


7. 如果你有一段代码发现推到远程了，你想重置掉远程代码，但是要保留本地代码，有哪些方法？

面试的时候我说的是，在你的开发分支拉出来一个分支，作为备份分支，

然后git reset --hard
git push origin dev


```
git pull 拉最新代码，提交之类，保证本地代码最新且无修改

git log  查看提交日志

git reset --hard  2ea5c6b311d8c45d62acdd6061a038950ea81b19  回退到要修改这个, --hard 会删除本地未提交的代码，回退回某一个版本，之间的代码不会在暂存区有记录

git reset 6df0437277dd01c29362c690b9448a3f0e72b1ce   再回退到它的上一次提交 ，暂存区会有这次回退之间的内容

git diff  可查看这些内容，可能需要去项目中解决冲突之类

git add . 有修改的话add下

git stash save 权限框     保存2ea5c6b311d8c45d62acdd6061a038950ea81b19提交的内容，至此需要修改的内容就存了下来。

 
git pull  拉下远端代码

git revert 6df0437277dd01c29362c690b9448a3f0e72b1ce 重置要修改的此次提交

git status 查看当前状态

git add .   修改错误后提交

git commit

git push 

git stash list    查看之前存下来的内容。

git stash apply stash@{0}  本地应用保存起来的修改，这样，重置的修改就在本地了
```


7. 请介绍一下你的项目吧，有哪些你觉得好的点

8. 项目重构为了什么，为什么要项目重构

9. 请介绍一下回流重绘吧，有哪些注意的点

10. 请说明一下如何隐藏一个元素，有哪些方式，并且他们的差异点有哪些

方法有三个：
display:none; 这个属性用于定义建立布局时元素生成的显示框类型,而none属性可以让元素隐藏

visibility:hidden；这个属性是能见度的意思，使用hidden属性值后可以让元素“隐藏”

opacity:0; 这个属性是透明度的意思，为零即透明度为0，也可以做到隐藏元素的作用


虽然上面三个属性都可以让元素实现“隐藏”的效果但是有的是真的让元素隐藏起来了，但有的只是假的让元素元素“隐藏”起来了，
display:none; 可以直接让元素“消失”而且在页面中不会占元素隐藏前该占的位置

visibility:hidden；和 opacity:0; 虽然也能让元素实现“隐藏”效果，但是他们让元素隐藏后在页面上该占的位置是不会变的，

打个比喻display可以做到让一个元素真真正正的消失，不管他之前占了什么位置有多大，而另外两个更像是让元素隐身起来了，该有的属性是一点不变，只是看不见而已，

那么他们都能用于什么场景呢，比如你想在一个元素上面做一个按钮，让点击这个元素的时候实现按钮一样的效果，但是这个按钮很丑，而且影响客户视觉效果，这时候就可以使用opacity，visibility两个属性了，这样虽然按钮是隐藏的但是功能并不会消失


把[1,2,3,4,5,6,7,8,9,0]变成三个三个的二维数组

1. loadsh的chunk方法
2. 手写一个方法
```js
const convertTo =(arr,size)=>{
    let result=[];
    for(let i=0;i<arr.length;i+=size){
        result.push(arr.slice(i,i+size));
    }
    return result;
}
```


实现一个斐波那契数列
```js
const fib=(n)=>{
    if(n===0||n===1){
        return 1;
    }
    return fib(n-1)+fib(n-2);
}
```

算法优化：dp[i]=dp[i-1]+dp[i-2]
```js
const fib=(n){
    if(n<=1)return n;
    let fib=[0,1];
    for(let i=2;i<=n;i++){
        fib[i]=fib[i-1]+fib[i-2];
    }
    return fib[n];
}
```


## 美团一面

1. 请说说点击小程序到底发生了什么
2. 请说说小程序的线程会发生哪些操作

3. 如何判断一个链表是否有环

4. 手写promise.all
const PromiseAll = (iterator) => {
  const promises = Array.from(iterator); // 对传入的数据进行浅拷贝，确保有遍历器
  const len = promises.length; // 长度
  let index = 0; // 每次执行成功+1,当等于长度时，说明所有数据都返回，则可以resolve
  let data = []; // 用来存放返回的数据数组
  return new Promise((resolve, reject) => {
    for (let i in promises) {
      promises[i]
        .then((res) => {
          data[i] = res;
          if (++index === len) {
            resolve(data);
          }
        })
        .catch((err) => {
          reject(err);
        });
    }
  });
};

const promise1 = Promise.resolve('promise1');
const promise2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 2000, 'promise2');
});
const promise3 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 1000, 'promise3');
});

PromiseAll([promise1, promise2, promise3]).then(function(values) {
    console.log(values);
});

# 推想医疗一面

手写promise.all
```ts
const promiseAll = (arr) => {
    const result = [];
    const tempArr = Array.from(arr);
    let resultNumber = 0;
    return new Promise((resole, reject) => {
        tempArr.forEach((item, index) => {
            if (item) {
                // 解析的操作

                result[index] = item;
                resultNumber++;
            }
            if (resultNumber === tempArr.length) {
                resole(result);
            }
        });
        if (resultNumber !== tempArr.length) {
            return reject();
        }
    })
}
```

1. 介绍一下type和interface的区别

> type 和 interface 是 TypeScript 中用于定义类型的关键字。它们在定义对象类型、函数类型和类型组合等方面有一些区别。type 更灵活，支持联合类型和交叉类型，并且可以使用类型别名来简化复杂的类型定义；而 interface 支持继承和类的实现。你可以根据具体的使用场景选择合适的方式。

> 

2. 介绍一下你的项目

3. 请说说以下打印是什么样的
```ts
for(const i=0; i<6; i++){
    console.log(i);
}

for(let i=0; i<6; i++){
    console.log(i);
}

for(var i=0; i<6; i++){
    console.log(i);
}

for(var i=0; i<6; i++){
    setTimeout(()=>{
        console.log(i);
    },0)
}

// 如果想要打印0-5我应该如何修改
```

4. 请介绍一下settimeout与promise的打印顺序

5. 请说说png和webp的区别吧

 
WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。


结论：建议原创表情尽量控制颜色数在 256 色以内，采用无损压缩性价比最高。
小于 256 色：以图标，图形，剪贴画为代表，最适合采用 WebP 无损压缩，精细度完美，体积大幅减少；
大于 256 色：以多数表情图，广告图为代表，最适合采用 WebP 有损压缩，选择较高压缩比（建议压缩质量为 100% ~ 75%）
远大于 256 色：以风景照，视频截图为代表，最适合采用 WebP 有损压缩，选择适中压缩比（建议压缩质量为 75% 以下）

6. 请介绍一下你在项目中做过哪些优化点呢

7. 介绍一下虚拟列表的实现思路吧

8. 聊聊你参与的项目的基础构建做了哪些吧？




