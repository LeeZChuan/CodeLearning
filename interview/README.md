作者：AmbitionC
链接：https://www.nowcoder.com/discuss/258810
来源：牛客网

一、JavaScript
1. 原始值和引用值类型及区别

在 JavaScript 中数据类型分两种，一类是基本类型的值，另一类是复杂数据类型，基本数据类型包括 7 种：undefined，null，boolean，string,number,bigInt,Symbol,复杂数据类型在 JavaScript 中主要是对象类型，在这之中又包含许多子类型，比如普通对象，数组，函数，Math，正则等等

然后就是存储方式，基本类型一般存的原始值，复杂数据类型一般是引用值，具体的含义就是，原始值的话，当你引用它是值拷贝的方式，一般存储在栈中，引用类型的值引用它时只是引用了一个指向它的内存地址的指针，这个指针存在栈中，这就会导致一个共享内存的问题，当把一个复杂数据类型赋值给另一个变量，由于是将其指针进行了拷贝，所以当修改其中一个对象的，所有值为这个指针的对象都会发生相应的改变

::: tip 关于数据类型这一块，还可以讲讲关于数据类型的判断，类型转换 :::

2. 判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor

typeof 适合用来判断基本数据类型，对于基本类型一般会返回对应的数据类型的字符换，而对于复杂数类型除 function 外一般会返回 Object，用 typeof 判断 function 会返回字符串 function，基本数据类型中 null 是个例外，typeof 判断 null 会返回 object，这是因为 JavaScript 中不同的对象在底层都表示为二进制，当二进制前三位全为 0 时会被判断为 object，null 的二进制表示全 0，自然前三位也是 0，typeof 就会将其判断位 Object，但这不影响 null 是基本数据类型，这只是语言本身的 bug

instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，所以这这个操作符的本质就是基于原型链查找，会沿着 left 得原型链查找，若找到了 right 就返回 true，所以 instance 实现的话大致就是在一个循环中不断获取 left 得原型，并检查是否与 right 相等，left 为对象，right 为函数，我们还可以在一个类上自定义 instanceof ，Symbol.hasInstance 用于判断某对象是否为构造器的实例,所以这样就可以在内部使用 typeof 来判断基本数据类型了
```javascript
class Array1 {
  static [Symbol.hasInstance](instance) {
    return typeof instance === "number";
  }
}
console.log(111 instanceof Array1);
```

Object.toString.call(),是调用了 Object 上的 toString 方法，之所以任何数据类型都可以调用该方法是因为，JavaScript 中基本数据类型会先转为包装对象，然后所有对象最终的原型指向都是 Object，所以可以调用 toString 方法，调用该方法后会返回一个[object 数据类型]的字符串，这个方法对基本数据类型和复杂数据类型都有效，这种方法的一个缺点是对于自定义对象总是返回[object Object],所以该方法常用来判断内置对象

constructor 也可以用来判断数据类型，constructor 属性返回创建此对象的数组函数的引用，不能对 null 和 undefined 使用


3. 类数组与数组的区别与转换

类数组是指写法上跟数组一样，但不是数组，她的原型是 Object，而数组的原型是 Array

类数组一般有 arguments , HTMLCollection, NodeList

关于 arguments 对象，他是函数的参数对象，通过 Object.prototype.toString.call()返回的结果是[object arguments],这个对象里面有一个 calle 属性可以返回函数本身，该属性从 es5 严格模式删除了

HTMLCollection 是 html dom 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型也是类数组对象，随文档中的 dom 变化而变化

NodeList 对象是节点的集合，通常由 querySelect 返回也是一种类数组，虽然不是一个数组但可以用 for of 迭代，也是一个实时集合

关于转换类数组，因为类数组并没有自带一些数组的方法，一般可以使用 call 来借用 Array 原型链上的方法来操作，比如 slice，concat，也可以使用扩展运算符来装换



1. 数组的常见API
   
数组常见的 API 大致可以分为三种一种是改变数组自身的方法，然后是不改变数组自身即返回一个新数组的方法，还有就是遍历的方法

改变数组自身的方法有：push,pop,shift,unshift,reverse,splice,fill,copyWithin

不改变数组自身的方法有：slice,concat,join,toString,toLocalString(根据本地时间把 Date 对象转换为字符串),indexof,lastIndexof,includes

遍历方法有：forEach,map,some,eveny,filter,reduce,find,findIndex 还有对象原型上的一些方法 keys,values,entries

::: tip 这一块还有一些 API 的实现：map，splice,pop,push,reduce,filter :::


5. bind、call、apply的区别

这三个方法都是在 Function 的原型上的，都用来显示的绑定 this，call 和 reply 可以由函数调用，然后第一个参数传入要绑定的上下文，后面的参数为要传给函数参数，apply 是将后续的这些参数写入到一个数组然后作为第二个参数，call 是将这些参数一个一个的作为 call 的后续参数，所以他们两个的区别就是对传入给函数的参数的传入形式不一样，最终的效果是一样的，而 bind 并不是想刚才哪两个一样直接执行函数，他先进行显示绑定 this，然后返回一个函数，然后可以自由的去调用这个函数，传入给函数参数的形式和 call 一样

6. new的原理

当我们执行了一个 new 操作，它内部会执行四个步骤，一是先创建一个空对象，第二是将构造函数的作用域赋值给新对象，也就是将 this 指向新对象，通过 Object 的原型上的 create 方法，第三个是执行构造函数，第四个是返回这个对象，其中若构造函数又返回一个对象那么就返回这个对象，否则返回前面创建的那个对象

7. 如何正确判断this？

关于 this 有显示绑定和隐式绑定，显示得很好判断，因为自己使用 call,apply,bind 来绑定，隐式的话若不考虑箭头函数那么 this 指向哪是由他在哪运行决定的，也就是 this 指向当前调用它的上下文，如果找不到就指向全局，而箭头函数和他很不一样的一点就是它内部 this 的执行是由他在哪里定义决定的，而不有运行时决定，也可以说她的 this 指向当前离他最近的非箭头函数的 this

举个例子，比如说，在函数里面有一个函数函数内获取 this，如果通过这个对象直接调用这个函数那么这是 this 指向这个对象，而如果把这个对象单独赋值给一个全局变量，这时 this 就指向全局，浏览器里是 window，nodejs 环境下为 global，严格模式选为 undefined

上面说了两种关于运行时决定 this 的指向，还有就是比如全局定义一个函数的，这是函数的 this 指向全局，通过构造函数 new 了一个实例，此时构造函数的 this 指向这个实例，还有比如浏览器中的监听事件 onclick，addEventListen，默认指向绑定的元素，IE 的话比较奇怪，使用 attachEvent 里面的 this 指向 undefined

还有一些比较特殊的情况，就是数组的遍历 API，第一个参数通常为回调函数，第二个参数可以显示绑定 this；还有就是函数中的 this 是不会传递的，比如函数里嵌套函数，外层函数的 this 有运行时所在的上下文决定，这个上下文不会传递给嵌套的函数，最后就是类中的 this 指向，类中的 this 指向类本身，但还是 this 有运行时的上下文决定，若将类中的方法赋值给全局变量，然后在全局进行调用，由于 class 内部默认采用严格模式，所以 this 并不会指向全局而是指向 undefined


8. 闭包及其作用

闭包是基于作用域链的，是当前作用域可以访问到父级作用域，针对的是函数，一个嵌套另一个函数，当里面的函数引用了外层函数的变量就形成了当前作用域访问到了父级作用域，此时就形成了闭包，这是嵌套的函数同时保存了当前作用域和父级作用域

产生闭包一般有函数内返回返回另一个函数，函数作为参数进行传递，立即执行函数，比如 js 中经常会在 setTimeout，事件监听中中使用回调函数，这也是闭包，还有 webpack 打包后的结果是一个立即执行函数，这也是闭包

闭包的优点就是可以访问并保存父级作用域，这样就可以形成私有变量，同时由于保存了父级作用域，自然父级作用域就不会被垃圾回收，这样也会产生一个缺点就是，当这种操作很多的话，由于许多父级作用域被引用，并不会被垃圾回收，就会导致内存泄漏

闭包的另一个优点是他可以用来实现模块化，从而避免全局变量的一个污染，因为立即执行函数就为模块提供了私有空间，具体做法就是将每个模块成员都放到一个立即执行函数所形成的私有作用域中，而对于需要暴露给外部的成员，可以挂载到全局对象上，因为立即执行函数保存当前父级也就是全局作用域

还有一种模块的方式就是函数返回一个有许多函数组成的对象，这个模块其实是暴露给了全局

闭包的用途除了刚刚说的私有作用域模块化之外还有，可以实现单例模式，还有比较经典的循环里打印下标

9.  原型和原型链

avaScript 是一门基于原型的语言，原型可以分为隐式原型和显式原型，比如我声明一个空对象，这是通过 Object.getPrototypeOf()就可以获取到这个对象的隐式原型，当然也可以直接访问这个对象的proto,但这个不在规范中，官方也不推荐使用，显式原型的就是比如我声明一个构造函数，那么这个构造函数就有 prototype 属性指向这个构造函数的显式原型，我们是可以往这个显示原型的挂在一些方法和属性，这样通过这个构造函数 new 的实例就可以访问到这个原型上的属性，做实例的隐式原型也指向构造函数的显式原型

原型链的话就是，构造函数的原型也拥有自己的原型，同时这个原型也肯有自己的原型，这样当我们在这个构造函数的一个实例上访问一个属性，会先在自身查找，找不到去原型上查找，还找不到去原型的原型上查找，知道找到为止，所有对象的原型都会指向 Object，找到最后没找到就会报找不到的错误，这样就形成了一条原型链，属性和方法也可以基于原型链查找，这也就是为什么 Object.prototype.toString.call()，可以判断基本数据类型和复杂数据类型的原因，所有对象在其原型链上都可找到 Object，自然可以调用该方法，基本数据类型通过 Object()被转为包装对象，自然也可以调用这个方法

原型链的作用一个是属性和方法的查找，还有一个是可以用来实现基于原型链继承

10. prototype与__proto__的关系与区别

实例的__proto__,指向构造函数的 prototype,或者说实例的隐式原型指向构造函数的显式原型

区别就是一个针对实例的，一个是针对构造函数的，__proto__不是标准中规范的，可以使用 Object.getProtoType()代替


11. 继承的实现方式及比较

继承的实现方式大致有五种：

第一种是通过原型链来实现继承，做法就是在子类的原型上挂载一个父类实例，这样就可以访问到父类的属性和方法，这种继承的问题在于对于引用数据类型内存空间是共享的，一个实例发送改变会引起其他实力也发生改变

第二种是通过构造函数来实现继承，具体做法就是在子类面通过 call，在在子类的上下文中执行父类，这样可以解决内存空间共享的问题，因为每个子类实例都是一个新的内存空间，但这样这样做的缺点是如果父类在原型上有方法，那么子类会继承不了

将上面两种方式结合形成第三种继承方式，组合式集成，但这样带来的问题是父类的的构造函数执行了两次，一次在子类的构造函数中，另一次是在网子类原型上挂在时，造成了一次不必要的开销，一个优化是直接将父类的原型挂载到子类原型上，这样少了一次开销，但同时引入了新的问题，子类的构造函数变成了父类，正常来说应该是子类

第四种是通过对象关联这样一种形式，通过 Object.create()来基于父类的原型创建子类，这叫做原型式继承，这样做的的缺点是内存空间共享问题

使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力在进行增强就形成了寄生式继承，但依然存在内存空间共享的问题

第五种就是寄生式组合继承，在构函数里调用父类来解决内存空间共享，通过 Objec.create()来会的目标对象的一份浅拷贝，这就是最优的一种继承实现方式，既没有内存空间共享问题，也没有两次调用父类造成不必要开销的问题，并且 es6 中的 class 的 extend 也是基于这种方式实现的继承

关于继承的这几种实现代表了两种设计思想，一种通过继承的设计思想即父类子类这样，另一种是通过行为委托，并没有父子类之说，而是兄弟关系，JavaScript 的原型机制本身也就是行为委托，对象关联可以通过行为委托来实现

12. 深拷贝与浅拷贝

看面试记录文档

13. 防抖和节流

看面试记录文档

14. 作用域和作用域链、执行期上下文

作用域就是可以访问的代码中的变量和函数的范围

作用域链的作用是保证变量和函数的一个有序访问，通过作用域链，我们可以访问到外层的变量和函数，她的本质是一个指向变量对象的变量指针，变量对象包含了执行环境中的所有变量和函数，作用域链的始端指向当前作用域，终端指向全局作用域，当查找一个变量时，会现在当前作用域查找，找不到就沿着作用域链向上查找，作用域链的创建过程和执行上下文有关

执行上下文可以理解成一个对象，这个对象分三部分：变量对象，作用域链，this 指向，类型包含全局上下文，函数上下文和 eval 上下文

执行上下文其实是代码的一个执行环境，一段代码执行过程中，遇到了函数，会将函数上下文依次压入到执行占中，当函数执行完便会将这个函数上线文从执行栈中弹出，

15. DOM常见的操作方式

dom 中的操作主要分为添加，删除，移动，复制，创建和查找

创建节点的方式主要有:createDocumentFragMent()创建一个 Dom 片段，createElement()创建一个具体的元素，createTextNode()创建一个文本节点

appendChild()添加操作，removeChild()删除操作,replaceChild()替换操作,insertBefore()插入

查找方法有:getElementById(),getElementByName(),getElementByTagName(),getElemenetByClassName(),querySeletor(),querySleectorAll()

属性操作：getAttribute(key),setAttribute(key, value),hasAttribute(key),removeAttribute()

16. Array.sort()方法与实现机制

Array,sort()，在不同的浏览器里底层是用的排序方法是不一样的，以 V8 为例，根据排序的元素个数会采用不同的排序方法：

当n <= 10时，采用差如排序，当 n > 10采用快速排序，当10<n<=1000,使用中位数作为哨兵元素，当n>1000每隔 200-215 个元素，放入到一个新数组中，对他排序，找到中间位置的数，以此作为中位数

元素少是使用插入排序因为插入排序在最好的情况下时间复杂度为 o(n),尽管平均复杂度为 o(n^2),快速排序平均复杂度为 o(nlogn),实际情况下两者的前面都一个系数，对于插入排序，若 n 足够小，速度会超过快排，插入排序在经过优化以后，对于小数据集会有非常优越的性能，所以这是选择插入排序是个不错的选择

快速排序的性能瓶颈在与递归的深度，最坏的情况是每次的哨兵都是最小的元素会最大的元素，在进行 partiton（一边是小于哨兵的元素，一边是大于哨兵的元素）那么就会有一边是空的，这么排下去递归层数就为元素的个数 n，时间复杂度会退化为 o(n^2),通过让哨兵元素尽肯能处于中间位置，减少最大或最小的情况，这就是 v8 对快速排序的一种优化

17. Ajax的请求过程

使用 ajax 步骤大概是:

* 创建 XMLHttpRequest 对象，这是一个异步调用对象
* 然后创建一个新的 http 请求的方法，并指定该 HTTP 请求的方法，URL 及验证信息
* 设置响应 http 请求状态变化的函数
* 发送 http 请求
* 获取异步返回的数据
* 使用 JavaScript 和 Dom 实现局部刷新
* 如果是 post 可以通过xhr.setRequestHeader("Content-type","application/x-www-from-urlencoded")设置请求头

关于上面第三部的 http 的请求状态 readState，0 表示未初始化，1 表示服务器已建立连接，2 表示请求已收到，3 表示请求处理中，4 表示请求以完成，且响应已就绪

18. JS的垃圾回收机制

js 中数据存储的位置有两种，一种是在栈中，另一种是在堆中，由于栈中的数据量都比较小，所以栈中的垃圾回收由操作系统来完成，js 中的垃圾回收机制只要针对的是堆内存

js 中有两个垃圾回收器，一个是副垃圾回收器，一个是主垃圾回收器，前者负责新生代中的垃圾回收，后者负责老生代中的垃圾回收

新生代中的垃圾回收机制是这样的，他主要回收哪些生命周期比较短的内存对象，所以需要一个效率非常高的算法，这个算法是一个牺牲空间来换取时间的算法，在占用空间不大的场景下非常适用，这个算法将内存分为两部分，一个 from space 一个是 to space，对 from space 中的活动对象进行标记，然后移动到 to space，并将这些对象有序的排列起来，然后将 from space 中的非活动对象进行释放，完成之后交换这两块，使得新生代中的这两块区域可以重复利用

新生代中的对象会通过晋升然后移动到老生代，在新生代中进一步划分了两个子区域，当我们第一次对内存进行分配时会被分配到其中一个子区域中，如果下一次垃圾回收这个对象还在新生代中，则会被移动到另一个子区域中，如果下一次垃圾回收这个对象还在新生代中，则这个对象会被移动到老生代

老生代中不能使用新生代中的垃圾回收算法，因为新生代中的算法为复制算法，重复复制活动对象效率低下，且是牺牲空间换时间的算法，老生带中的支持很大的容量，会出现资源浪费，所以老生代中主要使用标记清除和标记整理的算法

标记清除算法中先对老生代进行一次扫描，标记活动对象，然=然后进行第二次扫描，清理掉这些未被标记的对象，及非活动对象，这样会造成一个问题，被清除的对象遍布于各内存地址，产生了很多碎片，当需要分配一个很大的对象时，这些碎片空间无法完成分配，就会提前触发垃圾回收，而这次垃圾回收是不必要的，因此就有了标记整理的算法，他会将所有活动对象移项一端，然后直接清理掉边界外的内存

上面的垃圾回收当中当标记整理算法在移动活对象时可能对象比较多，她的执行速度不是很快，为了避免 js 的应用逻辑和垃圾回收器的资源竞争导致不一致的问题，这时垃圾回收器会将整个 JavaScript 应用暂停，这个过程叫做全停顿，而在新生代中由于空间小，存活对象较少，新生代的算法效率较快，所以全停顿并不影响，而老生带中活动对象较多，垃圾回收器全停顿的时间较长就会导致页面卡顿

为了解决上面那种卡顿 v8 通过增量标记和惰性清除，以及并发并行来降低主线程的挂在时间

增量标记就是将标记的过程穿插在 JavaScript 应用逻辑之间，允许标记的时间为 5~10ms，增量标记达到一定的阈值时才会启动，启动之后每当一定量的内存分配之后脚本的执行就会停顿进行一次增量标记

惰性清除用来真正释放内存，当增量标记完之后，加入当前的可用内存足以让我们的代码快速执行，其实我们是没有必要进行立即的清理内存的，可以将这个清理的过程延迟一下，让 js 代码先执行，也无需进行一次性的清理完所有非活动对象，垃圾回收器会逐一进行清理，直到所有都清理完毕

虽然增量标记和惰性清除是的主线程的最大停顿时间大大减少，也让用户与浏览器的交互过程流畅许多，但是每个小的标记之间执行了 js 代码堆中的变量的指针的可能发生了变化需要使用写屏障技术来保证这些引用关系的一致性，这就是增量标记的缺点：并没有减少主线程的总暂停时间甚至略微增加，由于写屏障技术机制的成本，增量标记可能会降低应用程序的吞吐量

并行式的 gc 可以使得辅助线程同时执行同样的 gc 工作，让辅助现成来分担主线程 gc 的工作，使得垃圾回收的耗时等于总时间除以参与线程的数量

目前 v8 的垃圾回收机制就是，副垃圾回收器使用并行机制，讲 from space 移动到 to space 时开启多个辅助线程，并行的进行整理，这会导致资源竞争，所以需要在每个对象复制完成后都去维护这个复制这个活动对象后的指针转发地址，以便于其他辅助线程可以找到该活动对象后判断该活动对象是否已被复制；对于主垃圾回收器，当堆中的内存大小超过阈值后，会并发的进行标记任务，每个辅助线程都会去追踪每个标记到的对象以及这个对象的引用，js 代码执行时，并发标记也会在后台的辅助线程中执行，当对象被修改时写入屏障技术会在辅助线程进行并发标记时进行追踪，当标记或动态分配的内存达到极限的时候，主线程会进行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次进行扫描确保所有对象都完成了标记，由于辅助线程已经标记过了活动对象，这次的扫描只是进行一次 check 操作，确认完成之后，有辅助线程进行内存的整理和清除，由于都是并行的，所以并不会影响主线程的执行

19. JS中的String、Array和Math方法

String : split,slice,substr,trim,concat,indexOf ,lastIndexOf

Array:····

Math：有一些常量和一些方法，都是与数学运算有关的

20. addEventListener和onClick()的区别

onclick 是 Dom0 的绑定事件的方式，而 addEventLister 是 Dom2 绑定事件的方式，使用 onclick 绑定的事件解绑需要将 onclick 设为 null，而 addEventListener 绑定的事件解绑需要 removeEventListerk 来解绑

onclick 绑定事件有点有：简洁，处理事件 this 指向当前元素，缺点是不能对事件进行捕获和冒泡进行控制，只能使用事件冒泡而不能使用事件捕获，并且一次只能对一个元素绑定一个事件处理程序，当使用 window.onload 时，会覆盖采用相同方法所绑定的事件

addEventListener 的优点就是支持捕获与冒泡，通过最后一个参数来设置，默认值为 false 表示事件冒泡，设置为 true 表示事件捕获，她的 this 和 onclick 一样，事件处理函数中，event 对象总是作为第一个可用参数，可以绑定多个事件而不会发生覆盖，缺点是 ie8 不支持

21. new和Object.create的区别

new 操作所做的工作有：

创建一个对象
对新对象进行原型操作，指向构造函数的原型
将 this 绑定到新对象上
如果构造函数返回了一个对象，就返回这个对象，否则返回新对象
object.create 所做的工作有：

该方法有两个参数，第一个参数作为新建对象的原型，第二个参数是一个对象，该对象的属性名称是新创建的对象的属性名称

创建一个新对象
将新对象的__proto__指向传入的参数
将传入的对象属性复制到新对象并返回新对象
从他们的内部所做的工作可以看出 new 是保留了构造函数，而 object.create()没有，原型链方面，new 保留了原构造函数的 prototype 属性，而 object.create 就是原构造函数或对象本身，new 作用的对象只能是函数，而 object.create 可以是函数也可以是对象

22. DOM的location对象

window.location 是一个只读属性，返回一个 location 对象，其中包含有文档当前的位置信息，包括 hash，search,host,hostname,href,origin 等等,还有一些方法比如 reload，replace，assign

尽管他是一个只读对象，仍然可以赋值给他一个 DOMString，这意味着可以再大多数情况下处理 location，就像它是一个字符串一样：

window.location = 'http://www.example.com'，是 window.location.href = 'http://www.example.com'的同义词

reload 强制从服务器从新加载当前页面，replace 重新加载页面，assign 使用新的 url 加载页面

23. 浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）

> 网络层面，
1. 首先，域名是对 ip 地址的映射，所以这里也有一个 DNS 解析的过程，DNS 也会存在缓存，
2. 首先是浏览器缓存，然后是系统缓存，然后是路由器缓存，然后是运营商缓存，根域名服务器，再到顶级域名服务器，主域名服务器逐一读取，DNS 的查询方式有两种一种是递归查询，从客户端到 DNS 服务器是属于递归查询的，而 DNS 服务器之间的交互查询是迭代查询，然后会建立 tcp 链接经历三次握手，
3. 然后进行 http 链接，构建请求构建请求行，GET / HTTP/1.1,查找强缓存，强缓存失效，使用协商缓存，得到服务端的响应，到这网络层面结束

> 解析层面，
1. 浏览器收到服务端传过来的 html 文件的字节流，先进行字节流的一个解码，这样才能看到字符串，然后进行输入流预处理，主要是生成规范化的字符流数据，
2. 然后是令牌化，将字符流解析成标签和文本节点，然后根据上一步的操作进行 Dom 树的构建，在这当中若遇到 script 标签会根据 script 加载的方式进行不同的处理，当 script 标签中改变了 DOM 的结构，则会将这些改变的代码加入到字符流重新进行解析，dom 树构建完会进行 CSSOM 树的构建

> 渲染方面，
1. 有了 cssom 树和 dom 树会计算布局，并生成布局树，然后对于一些复杂的场景比如动画，会有层叠上下文，这是会进行图层树得构建，接下来渲染引擎会将图层拆分成一个一个绘制指令，生成绘制列表，然后由合成线程进行绘制，考虑到视口很大不可能一下子绘制完，所以会对图层进行分块，渲染进程还会专门维护一个栅格化线程池专门负责把图块转换成位图数据，这个过程要进入到 GPU 当中进行加速并生成位图然后返回给合成线程，由于上传 GPU 会比较慢，chrom 采取了一个优化首屏加载速度操作，回先展示一个分辨率比较低的图片，最后显示器显示内容，合成线程生成绘制指令，发送给浏览器进程，浏览器受到这个命令把页面内容绘制到内存，也就是生成了页面，再把这部分内存发送给显卡，显卡接收到后会合成相应的图像，并将图像保存到缓冲区

所以当动画过多占用大量内存，浏览器生成图像变慢，传递给显卡不及时，显示器以不变的频率刷新，就会出现掉帧现象

24.  跨域、同源策略及跨域实现方式和原理

跨域之所以出现是因为浏览器为了保证安全而制定的一个同源策略，浏览器之外是不存在跨域的，同源策略是一个域去访问另一个域中的资源是会被禁止，同源要求 ur 协议，主机名，端口都相同

解决跨域一般有四种方式：第一种是通过跨域资源共享，这种是在服务端进行解决，第二种是使用 jsonp，这种方式的缺点是只能发 get 请求，不能捕获服务端的错误，并且请求过程无法终止，是利用了浏览器对 script 标签没有同源策略的限制来实现的，第三种是通过 webscort 来解决跨域，这是因为他是个全双工协议，不是同源策略限制，最后一种是通过代理转发的方式，比如 webpack 的 devserve，nginx 配置 proxy_pass

还有一种跨域是父子页面的跨域，例如使用 iframe 来进行父子页面之间的通信，这是可以使用，postMessage 来进行通信，也可以用过改域的方式来解决，将 document.domain 改成更高的父域

25. 浏览器的回流（Reflow）和重绘（Repaints）

重绘是渲染树中一些元素需要更新属性，而这些属性只影响外观，风格，不会影响布局的操作，比如背景色这样的操作成为重绘

回流当渲染树中一部分因为尺寸，规模，布局，隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称之为回流

重绘由于没有影响到布局，所以只进行了样式计算而跳过了布局树和建图层树的过程，直接生成绘制列表，然后继续进行分块，生成位图等后面一些类操作

回流会将样式计算后一系列操作重新执行一遍，开销是比较大的，并且回流一定会重绘，但重绘不一定会回流

那么避免回流可以这样组：

使用 transfrom 代替 top
进行防抖节流处理
DOM 离线修改，使用 documentFragment 对象在内存中操作 Dom
避免频繁使用 style，而是使用 class
添加 will-change:transform,让渲染进程单独实现一个图层，仅仅利用合成线程去处理，不牵涉到主线程，大大提高渲染效率

26. JavaScript中的arguments

他是一个类数组，使用 typeof 返回 [object argumengt],他作为函数的参数对象，内部有 callee 返回函数本身，可以使用显示绑定 this 的方式借用数组上的方法，也可以将它转换成数组

27. EventLoop事件循环

js 是单线程的语言，在代码执行时，通过将不同函数的执行下文压入执行栈中来保证代码的有序执行，在执行同步代码的时候遇到到了异步代码，js 引擎并不会一致等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务，当异步任务执行完毕后再将异步事件回调加入到与当前执行栈不同的另一个任务队列等待执行

任务队列可分为宏任务和微任务，当前执行栈中的函数之心完毕后会先判断为任务队列中是否有任务可以执行，如果有就将微任务队列的任务依次压入执行性栈中，当微任务执行完毕后再去判断宏任务中的队列，同时开启新的一轮事件循环

浏览器中事件循环是依靠浏览器完成的异步操作

nodejs 中底层使用 libuv 库实现多线程

以前版本的 nodejs 和浏览器的事件循环还是很不一样的，浏览器中的微任务会在每个相应宏任务中执行，而 nodejs 中微任务是在每个阶段之间执行的，当 nodejs 版本大于 11 后，nodejs 和浏览器表现一致

28. 宏任务与微任务

宏任务常见的有 setTimeout，setInterval，setImmediate，requestAnimationFrame，这些事件会在开启新的一轮事件循环时去执行

微任务常见的有 Promise，MutiationObserver，process.nextTick,微任务的引入是为了解决异步回调的问题，对于异步回调 js 采取的是将异步回调放到当前宏任务的末尾，这样可以保证回调函数及时得到执行，不会造成卡顿，如果把回调函数进行宏任务的入队操作，当宏任务队列非常长的时候回调函数会迟迟得不到执行

微任务中的 Process.nextTick 是一个独立于事件循环的任务队列，每一个轮事件循环结束后回去检查这个队列，如果有，会让其优于微任务执行

29. BOM属性对象方法

对象：Window，document，location，screen，history，navigator。

方法：Alert()，confirm()，prompt()，open()，close()

30. 函数柯里化及其通用封装

函数柯里化是指将多个参数的函数装化成一系列使用一个参数的函数，一个简单的函数柯里化实现：

```javascript
function curry(fn, args) {
  let length = fn.length;
  args = args || [];
  return function() {
    let subArgs = args.slice(0);
    for (let i = 0; i < arguments.length; i++) {
      subArgs.push(arguments[i]);
    }
    if (subArgs.length >= length) {
      return fn.apply(this, subArgs);
    } else {
      return curry.call(this, fn, subArgs);
    }
  };
}
```
使用函数柯里化可以实现参数复用，提前返回，延迟计算或执行，js 中的 bind 是延迟函数的执行


31. JS的map()和reduce()方法

map 方法主要来遍数组，返回一个新数组不会对原数组产生影响，第一个参数为回调函数，用来对数组的元素进行处理，其中回调函数的参数第一个为当前数组元素，第二个为当前下标，第三个为遍历的数组，第二参数 this 的显示绑定

reduce 方法也用来遍历数组，第一个参数为回调函数，第二个参数为初始值，回调函数的第一个参数为累机器，第二个为当前元素，第三个为当前索引，第四个为遍历的数组

32. “==”和“===”的区别

==在进行判断时会进行隐式的数据类型转换，而===在进行比较是不会进行数据类型转换

==的转换规则为：

字符串与数字比较，将字符串转为数字在比较
其他类型与 boolen 进行比较，先将布尔转换为数字，在应用其他规则进行比较
null 和 undefined 比较，结果为真，他们和其他值比较均为假
对象和非对象进行比较，对象会进行转换的操作，然后在进行比较
如果有一个为 NaN,返回 false
若两个都是对象，判断他们是否指向同一个对象，是的话为 true，否为为 false
Object.is(),也可以用来进行比较，他主要是修复了一些特殊情况下的 bug，比如正 0 等于负零，NaN 不等于 NaN

33. setTimeout用作倒计时为何会产生误差？

setTimeout 属于宏任务，如果当前执行栈的执行时间很长大于定于定时器的时间，那定时器的回调在宏任务里来不及去调用，这个时候就会产生误差，另外一种，是在上一轮事件循环中将 setTimeout 推入到宏任务队列中，若上一轮事件循环也需要很长的时间执行，也会造成误差，所以 setTimeout 的倒计时只是保证在这个倒计时之前不会被执行，但不能保证倒计时结束之后一定被执行

二、ES6
1. let、const和var的概念与区别
2. 变量提升与暂时性死区
3. 变量的结构赋值
4. 箭头函数及其this问题
5. Symbol概念及其作用
6. Set和Map数据结构
7. Proxy
8. Reflect对象
9. Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法）
10. Iterator和for...of（Iterator遍历器的实现）
11. 循环语法比较及使用场景（for、forEach、for...in、for...of）
12. Generator及其异步方面的应用
13. async函数
14. 几种异步方式的比较（回调、setTimeout、Promise、Generator、async）
15. class基本语法及继承
16. 模块加载方案比较（CommonJS和ES6的Module）
17. ES6模块加载与CommonJS加载的原理
三、HTML/CSS
1. CSS权重及其引入方式
2. <a></a>标签全部作用
3. 用CSS画三角形
4. 未知宽高元素水平垂直居中（方案及比较）
5. 元素种类的划分
6. 盒子模型及其理解
7. 定位方式及其区别（文档流）
8. margin塌陷及合并问题
9. 浮动模型及清除浮动的方法
10. CSS定位属性
11. display及相关属性
12. IFC与BFC
13. 圣杯布局和双飞翼布局的实现
14. Flex布局
15. px、em、rem的区别
16. Less预处理语言
17. 媒体查询
18. vh与vw
19. H5的语义化作用及语义化标签
20. Web Worker和Web Socket
21. CSS3及相关动画
22. 如何实现响应式布局
23. SEO的概念及实现
24. HTML5的新特性
25. Less和Sass使用



四、HTTP与计算机网络


1. TCP/IP协议分层管理


2. 三次握手四次挥手机制及原因

三次握手 第一次握手是让服务端知道客户端具有发送能力，第二次握手是让客户端知道服务端具有接受和发送的能力，但此时服务端并不知道客户端是否收到了自己发送的消息，所以第三次握手起到了这个作用，经过了三次握手后服务端和客户端都确认了双方的接收和发送能力 不是两次是因为无法确认客户端的接受能力，大于等于三次都可以，只是再多用处不大，第三次握手是可以携带数据的，前两次不可以，因为有人想攻击服务器，在第一次握手中放了大量数据，那么服务端必定会消耗更多的时间和内存去处理这些数据，大大增加了服务端被攻击的风险 第一次握手，客户端处于 close 状态，服务端处理 listening 状态，客户端给服务端发送了一个 SYN 报文并指明了客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态 第二次握手，服务端接收到 SYN 报文后，会以自己的 SYN 报文作为应答，并且也指定了自己的初始化序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务端处于 SYN_REVD 状态 第三次握手，当客户端接收到 SYN 报文后，会发送一个 ACK 报文，也把 ISN + 1 作为 ACK 的值，表示客户端接收到了服务端的 SYN 报文，此时客户端处于 establish 的状态，服务端接收到 ACK 报文后也处于 established 状态，此时双方成功建立起链接 四次挥手 为什么链接需要三次而断开需要四次：当服务端接收到客户端的 FIN 报文后，发送的 ACK 报文还是用来应答，并不表示服务端也希望立即关闭连接，只有当服务端把所有的报文都发送完了，才会发送 FIN 报文，告诉客户端可以断开连接了，因此这就是需要四次挥手的原因 第一次挥手，在挥手之前，两端都处于 established 的状态，客户端发送一个 FiN 报文，用来关闭客户端到服务端的数据传输，此时客户端处于 FIN_WAIT_1 状态。 第二次挥手，当服务端收到 FIN 报文后，会发送 ACK 报文，并把客户端的序列号值加 1 作为 ACK 报文的序列号，表明已经收到客户端的报文了，此时服务端处于 close_wait 状态 第三次挥手，如果服务端同意关闭连接，则会向客户端发送一个 FIN 报文，并指定一个序列号，此时服务端处于 LAST_ACK 的状态 第四次挥手，当客户端收到 ACK 后，处于 FIN_WAIT_2 状态，待收到 FIN 报文时发送一个 ACK 报文作为应答，并且把服务端的序列号值+1 作为自己的 ACK 报文的序列号值，是客户端处于 TIME_WAIT 状态，等待一段时间后会进入 closed 状态，当服务端接收到 ACK 值后，也会变为 closed 状态，此时连接正式关闭


3. HTTP方法
   GET:通常用来获取资源 
   HEAD：获取资源的元信息
    POST：提交数据，即上传数据 
    PUT：修改数据 
    DELETE：删除数据 
    CONNECT：建立连接隧道，用于代理服务器 
    OPTIONS:列出可对资源实行的请求方法，用来跨域请求 
    TRACE：追踪请求-响应的传输路径

4. GET和POST的区别

最直观的是语义上的区别，往细了说： 从缓存角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 post 请求不会 从编码角度，get 请求只能进行 URL 编码，只能收到 ASCII 字符，而 POST 没有限制。 从参数角度，get 请求一般会放到 URL 中，因此不安全，post 请求放在请求体中，更适合传输敏感信息 从幂等性角度，get 是幂等性的，而 post 不是（幂等性是指执行相同的操作，结果也是相同的） 从 TCP 的角度，get 请求会吧请求报文一次性的发出去，而 Post 会分为两个 TCP 数据包，首先发送 header 部分，如果服务器响应 100，然后发 boy（火狐浏览器除外，她的 post 请求只发一个 TCP 包）

5. HTTP建立持久连接的意义

HTTP 建立持久连接是在 HTTP1.1 版本中才有的，HTTP1.0 通过设立头部字段来进行不同类型文件的传输，随着互联网的发展，HTTP1.0 已经无法满都需求，最核心的问题就是连接问题，具体来说就是每进行一次通信都要进行建立连接，传输数据，断开连接的过程三个阶段，当一个页面引用了较多的外部文件时，这个建立连接和断开连接的过程就会增加大量的网阔开销 为了解决这个问题，http1.1 版本增加了一个创建之持久连接的方法，实现了每当一个连接传输完成时，并不是马上进行关闭，而是继续复用他传输其他请求，这个链接直到浏览器或者服务器要求断开为止


6. HTTP报文的结构

http 报文结构是 header+body 的结构，大致为起始行+头部+空行+实体 起始行对于请求报文来说是请求方法 路径 http版本，对于响应报文是http版本 状态码 原因，起始行中每两个部分之间用空格隔开，最后一个部分后面接一个换行符 不管是请求头韩式响应头，其中的字段是相当多的，牵扯到 http 非常多的特性，格式方面： 字段名不区分大小写 字段名不允许出现空格，不可以出现下划线 字段名后面必须紧跟着: 空行很重要，用来区分头部和实体，如果故意在头部中间加一个空行，那么空行后面的内容会全部被视为实体 最后实体就是 body 部分了，请求报文对应请求体，响应报文对应响应体

7. HTTP状态码

http 状态码为三位数，被分为 5 类： 
1xx 表示目前是协议的中间状态，还需要后续操作 
2xxx 表示成功状态 
3xx 是重定向状态，资源位置发生变动，需要重新请求 
4xx 是请求报文有误 
5xx 是服务端发生错误 
常见的状态码有这些： 
200 表示成功的状态码 
204 表示请求成功但响应头后没有 body 数据 
206 表示部分内容，使用场景为 http 分块下载和断点续传，当然也会带上相应的响应头部字段 Content-Range 
301 永久重定向，
302 临时重定向 
304 表示命中协商缓存 
400 笼统的提示一下，并不知道哪里出错了 
403 表示服务器禁止访问 
404 表示未在服务器上找到资源 
405 表示请求方法不被允许 
406 表示资源无法满足客户端的条件 
408 表示服务器等待时间过长 
409 表示多个请求发生了冲突
413 表示请求体数据过大
414 表示请求行里的 URL 太大 
429 表示客户端发送的请求过多
431 表示请求字段内容太大 
500 表示服务器出错了，但不知道出了什么错 
501 表示客户端请求的功能还不支持 
502 表示服务器本身正常，但访问时出错了，具体什么错误不知道 
503 表示服务器当前很忙，暂时无法响应服务


8. Web服务器及其组成

Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以处理浏览器等 Web 客户端的请求并返回相应响应，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载，目前最主流的三个 Web 服务器是 Apache、 Nginx 、IIS Web 服务器有以下几个部分组成： 服务器初始化部分，这部分主要完成初始化的工作，比如建立守护进程，创建 TCP 套接字，绑定端口，等待接收客户端的连接 接收客户端请求，http1.x 中以文本行的形式接收，因为请求头是以文本行的方式实现的 解析客户端请求，解析出请求方法，url 目标，可选的查询信息以及表单信息，如果请求方法为 HEAD，则简单的返回响应首部即可；如果方法是 GET，则首先返回响应首部，然后将客户端请求的 URL 目标文件从服务器磁盘上读取，再发送给客户端；如果是 POST，则比较麻烦，首先要调用相应的 CGI 程序，然后将用户表单信息传给 CGI 程序，CGI 程序根据表单内容完成相应的工作，并将结果数据返回 发送响应信息后，关闭与客户端的链接 # HTTP 的特点

9.  HTTP报文首部

灵活扩展，语义上很自由，没有严格的语法限制，传输形式多样 可靠传输，将 TCP 的这一特性继承了下来 请求-应答，一收一发，有来有回 无状态，指的是通信过程中的上下文信息，每次 http 请求都是独立，无关的，默认不需要保留状态信息 缺点： 无状态，在长链接中，需要保存大量的上下文信息，一面传输大量的重复信息，这时无状态就成了缺点，而少量的数据传输不需要保存上下文信息，无状态减少了网络开销，就是无状态的优点 明文传输，报文都是文本形式，而不是使用的二进制形式，报文信息暴露给外界，方便调试的同时也给了攻击者方便，比如 wifi 陷阱 队头阻塞问题，当开启长连接，多个请求共用一个 TCP，同一时刻只能处理一个请求，那么如果当前请求耗时过长，其它请求就只能处于阻塞状态

10.  HTTP通用首部字段
11.  
12. HTTP请求首部字段、响应首部字段、实体首部字段
13. Cookie相关首部字段
14. HTTPS与HTTP区别及实现方式
15. Cookie与Session
16. 基于HTTP的功能追加协议（SPY、WebSocket、HTTP）
17. 常见的Web攻击分类
18. TCP与UDP区别
19. 存储机制localStorage、sessionStorage与Cookie存储技术
20. XSS攻击及防御
21. CSRF攻击及防御
五、前端工程化
1. 前端工程化的流程（架构选型、业务开发、测试、打包构建、部署上线、项目监控）
2. Webpack基本概念与配置
3. loader与plugin原理与实现
4. Webpack的模块热替换及实现
5. Webpack的优化问题
6. SPA及其优缺点
7. SSR实现及优缺点
8. 设计模式（工厂模式、单例模式、原型模式、***模式、适配器模式、观察者模式等...）
六、React
1. React自身特点及选型时考虑
2. React与VUE的异同
3. Virtual DOM
4. React生命周期
5. Diff算法
6. 受控组件与非受控组件
7. 高阶组件
8. Flux架构模式（涉及MVC/MVVM、Flux）
9. Redux设计概念、设计原则、方法、redux实现异步流的库
10. 纯组件（Pure Component）与shouldComponentUpdate关系
11. Redux中的<Provider/>组件与connect函数
12. React Fiber架构
13. React Hooks的作用及原理
七、NodeJS
1. NodeJS基本概念与特点
2. CommonJS规范、核心模块
3. Node的异步I/O
4. Node的内存控制
5. Node构建网络服务（TCP、HTTP、Web Socket服务等）
6. Node的进程
八、需要会手撕的代码部分
1. Promise（A+规范）、then、all方法
2. Iterator遍历器实现
3. Thunk函数实现（结合Generator实现异步）
4. async实现原理（spawn函数）
5. class的继承
6. 防抖和节流
7. Ajax原生实现
8. 深拷贝的几种方法与比较
9. 继承的几种实现与比较
10. 未知宽高的元素水平垂直居中
11. 三栏布局的实现
12. 两栏布局的实现
13. React高阶组件
14. 数组去重
15. 几种排序算法的实现及其复杂度比较
16. 前序后序遍历二叉树（非递归）
17. 二叉树深度遍历（分析时间复杂度）
18. 跨域的实现（JSONP、CORS）
九、数据可视化
1. Canvas和SVG的区别
2. 在考虑设计可视化图表时，结合Canvas和SVG特性会怎么取舍
3. 常见的可视化组件库
4. 可视化组件库如Echarts的设计思路
5. 一些偏向底层的可视化组件库和前端框架结合方面需要考虑哪些问题
6. 可视化组件如何做到数据驱动？
十、计算机基础
1. 计算机系统
2. 线程与进程
3. 常见的git指令
4. Linux相关指令
5. 其他类型的编程语言（如Java）
6. 数据库