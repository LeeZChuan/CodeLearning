- [杭州数澜科技一面](#杭州数澜科技一面)
  - [自我介绍](#自我介绍)
  - [项目介绍](#项目介绍)
  - [1.用过svg吗，讲讲svg与canvas](#1用过svg吗讲讲svg与canvas)
  - [2.讲解一下如何利用d3实现柱状图从0-100的移动](#2讲解一下如何利用d3实现柱状图从0-100的移动)
  - [3.](#3)
- [杭州智能涂鸦一面](#杭州智能涂鸦一面)
  - [自我介绍](#自我介绍-1)
  - [项目介绍](#项目介绍-1)
  - [1.用过css的什么，知道浮动窗口吗，如何实现的，](#1用过css的什么知道浮动窗口吗如何实现的)
  - [2.讲一下你的简历中的项目，流程是什么样的，](#2讲一下你的简历中的项目流程是什么样的)
  - [3.讲一下es6的var与let](#3讲一下es6的var与let)
  - [4.讲一下js的闭包，是什么？（谈谈对闭包的理解，闭包的用途，闭包的缺点）](#4讲一下js的闭包是什么谈谈对闭包的理解闭包的用途闭包的缺点)
  - [5.知道es6的promise函数吗？讲解一下](#5知道es6的promise函数吗讲解一下)
  - [6.知道那些有关前端的安全问题，如何防范？](#6知道那些有关前端的安全问题如何防范)
- [杭州数澜科技二面](#杭州数澜科技二面)
- [杭州数澜科技三面](#杭州数澜科技三面)
- [菜鸟裹裹](#菜鸟裹裹)
  - [类组件与函数组件生命周期有何区别，分别解释一下](#类组件与函数组件生命周期有何区别分别解释一下)
  - [useMemo与useCallback解释一下](#usememo与usecallback解释一下)
  - [什么情况下会遇到跨域，描述一下，前端常见的处理跨域的几种方式](#什么情况下会遇到跨域描述一下前端常见的处理跨域的几种方式)

## 杭州数澜科技一面

### 自我介绍

### 项目介绍

### 1.用过svg吗，讲讲svg与canvas

### 2.讲解一下如何利用d3实现柱状图从0-100的移动

### 3.


## 杭州智能涂鸦一面

### 自我介绍

### 项目介绍

### 1.用过css的什么，知道浮动窗口吗，如何实现的，


   float 是一种选择，但是使用 inline-block 会更简单。让我们看下使用这两种方法的例子：

* 试用float方法
```css
.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
.after-box {
  clear: left;
  /* 取消浮动 */
}

```

* 容易的方式（使用 inline-block）你可以用 display 属性的值 inline-block 来实现相同效果。

```css
.box2 {
  display: inline-block;
  width: 200px;
  height: 100px;
  margin: 1em;
}
```

    

### 2.讲一下你的简历中的项目，流程是什么样的，

### 3.讲一下es6的var与let

### 4.讲一下js的闭包，是什么？（谈谈对闭包的理解，闭包的用途，闭包的缺点）

+ 闭包是指有权访问另外一个函数作用域中的变量的函数
+ 闭包的用途：
1. 设计私有的方法和变量。
2. 匿名函数最大的用途是创建闭包，并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。
+ 闭包的缺点：
1. 闭包会使得函数中的变量都被保存在内存中，滥用闭包可能导致内存泄漏。解决方法是在函数退出之前，将不使用的局部变量全删了。
2. 闭包会在父函数外部，改变父函数内部变量的值。

![prototype](../img/JavaScript/js-prototype.png)

### 5.知道es6的promise函数吗？讲解一下

### 6.知道那些有关前端的安全问题，如何防范？


## 杭州数澜科技二面

项目组leader聊团队氛围以及团队分工

## 杭州数澜科技三面

薪资待遇以及之前的工作情况

## 菜鸟裹裹

### 类组件与函数组件生命周期有何区别，分别解释一下

   类组件，通过es6类的编写形式去编写组件，必须继承React.component，想要访问父组件传递过来的参数，可通过this.props访问
   在组件中必须实现render方法，在return中返回react对象

   函数组件，使用函数的形式编写一个react组件，


* 两类react组件，其区别主要分为以下几个方向：
* 编写形式
* 状态管理
* 生命周期
* 调用方式
* 获取渲染的值

1. 编写形式：

```javascript
// 函数组件：
function get(props){
  return <h1>props.name</h1>
}

//类组件：
class get extends React.Component{
  //构造器
  constructor(props){
    super(props)
  }
  render(){
    return<h1>this.props.name</h1>
  }
}

```
2. 状态管理：
  
```javascript
// 函数组件：在hooks出来之前，函数组件是没有状态组件的，不能保管组件的状态，不像类组件调用setstate
//出来usestate后，就可以实现如同类组件一样的效果使用状态
const[state,setstate]=useState(0);
//在使用hooks的情况下，一般函数组件调用state，则需要创建一个类组件或者state提升到你的父组件中，然后通过props对象传递到子组件


//类组件：本身就存在状态管理的情况
```

3. 生命周期

* 在函数组件中，并不存在生命周期，因为这些生命周期函数钩子都来自继承的React.Component
* 所以，如果用到生命周期，就只能使用类组件
* 但是函数组件使用的useEffect也能够代替生命周期的作用，

```javascript
//下面这段对应componentDidMount生命周期
const Demo=()=>{
  useEffect(()=>{
    console.log('hi')
  },[]);
  return<h1>hello!</h1>
}

//这段对应componentWillUnmount生命周期
const Demo=()=>{
  useEffect(()=>{
    return()=>{
      console.log("bye")
    }
  },[]);
  return<h1>bye!</h1>
}
//下面这段模拟componentDidUpdate
//在此之前需要使用useRef这个hooks
const flag = React.useRef(null)
React.useEffect(() => {
	if(!flag.current){
		flag.current = true
	} else {
		console.log("更新了")
	}
})
//在官网的文档有提到在useeffect钩子函数最后的第二参数，用于监听那个状态的变化，如果变化则执行内部函数：
//在这里我们没有传第二个参数，也就是说他默认监听所有状态，只要有状态发生改变，他就会执行，
```

4. 取出渲染的值

* 类组件与函数组件功能基本一致，但是在类组件中，输出this.props.user,Props在react中是不可变的，但是this总是可变的，以便您可以在render和生命周期函数中读取新版本
* 
### useMemo与useCallback解释一下

### 什么情况下会遇到跨域，描述一下，前端常见的处理跨域的几种方式
1. 浏览器有几种缓存方式，分别介绍一下
2. 深拷贝与浅拷贝
3. Promise函数传来了几个参数
4. 钩子函数传参类型分别有那些
