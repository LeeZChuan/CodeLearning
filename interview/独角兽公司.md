- [杭州数澜科技一面](#杭州数澜科技一面)
  - [自我介绍](#自我介绍)
  - [项目介绍](#项目介绍)
  - [1.用过svg吗，讲讲svg与canvas](#1用过svg吗讲讲svg与canvas)
  - [2.讲解一下如何利用d3实现柱状图从0-100的移动](#2讲解一下如何利用d3实现柱状图从0-100的移动)
  - [3.](#3)
- [杭州智能涂鸦一面](#杭州智能涂鸦一面)
  - [自我介绍](#自我介绍-1)
  - [项目介绍](#项目介绍-1)
  - [1.用过css的什么，知道浮动窗口吗，如何实现的，](#1用过css的什么知道浮动窗口吗如何实现的)
  - [2.讲一下你的简历中的项目，流程是什么样的，](#2讲一下你的简历中的项目流程是什么样的)
  - [3.讲一下es6的var与let](#3讲一下es6的var与let)
  - [4.讲一下js的闭包，是什么？（谈谈对闭包的理解，闭包的用途，闭包的缺点）](#4讲一下js的闭包是什么谈谈对闭包的理解闭包的用途闭包的缺点)
  - [5.知道es6的promise函数吗？讲解一下](#5知道es6的promise函数吗讲解一下)
  - [6.知道那些有关前端的安全问题，如何防范？](#6知道那些有关前端的安全问题如何防范)
- [杭州数澜科技二面](#杭州数澜科技二面)
- [杭州数澜科技三面](#杭州数澜科技三面)
- [菜鸟裹裹](#菜鸟裹裹)
  - [类组件与函数组件生命周期有何区别，分别解释一下](#类组件与函数组件生命周期有何区别分别解释一下)
  - [useMemo与useCallback解释一下](#usememo与usecallback解释一下)
  - [什么情况下会遇到跨域，描述一下，前端常见的处理跨域的几种方式](#什么情况下会遇到跨域描述一下前端常见的处理跨域的几种方式)
  - [浏览器有几种缓存方式，分别介绍一下](#浏览器有几种缓存方式分别介绍一下)
  - [深拷贝与浅拷贝](#深拷贝与浅拷贝)
  - [Promise函数传来了几个参数](#promise函数传来了几个参数)
  - [钩子函数传参类型分别有那些](#钩子函数传参类型分别有那些)
- [浩晶科技](#浩晶科技)
  - [js中有多少个数据类型](#js中有多少个数据类型)
  - [for...in与for...of的区别](#forin与forof的区别)
  - [NaN是什么类型的（typeof(NaN)）](#nan是什么类型的typeofnan)
  - [介绍一下let const 与var](#介绍一下let-const-与var)
  - [给你两个对象分别是5和6，让你不用第三方变量进行交换，如何实现](#给你两个对象分别是5和6让你不用第三方变量进行交换如何实现)
  - [闭包是什么，有什么特性，对页面有什么影响](#闭包是什么有什么特性对页面有什么影响)
  - [箭头函数](#箭头函数)
  - [react生命周期介绍一下](#react生命周期介绍一下)
  - [react-router的hash模式和history模式有何区别](#react-router的hash模式和history模式有何区别)
  - [webpack的loader和plugin的区别](#webpack的loader和plugin的区别)
  - [webpack的构建流程](#webpack的构建流程)

## 杭州数澜科技一面

### 自我介绍

### 项目介绍

### 1.用过svg吗，讲讲svg与canvas

### 2.讲解一下如何利用d3实现柱状图从0-100的移动

### 3.


## 杭州智能涂鸦一面

### 自我介绍

### 项目介绍

### 1.用过css的什么，知道浮动窗口吗，如何实现的，


   float 是一种选择，但是使用 inline-block 会更简单。让我们看下使用这两种方法的例子：

* 试用float方法
```css
.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
.after-box {
  clear: left;
  /* 取消浮动 */
}

```

* 容易的方式（使用 inline-block）你可以用 display 属性的值 inline-block 来实现相同效果。

```css
.box2 {
  display: inline-block;
  width: 200px;
  height: 100px;
  margin: 1em;
}
```

    

### 2.讲一下你的简历中的项目，流程是什么样的，

### 3.讲一下es6的var与let

### 4.讲一下js的闭包，是什么？（谈谈对闭包的理解，闭包的用途，闭包的缺点）

+ 闭包是指有权访问另外一个函数作用域中的变量的函数
+ 闭包的用途：
1. 设计私有的方法和变量。
2. 匿名函数最大的用途是创建闭包，并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。
+ 闭包的缺点：
1. 闭包会使得函数中的变量都被保存在内存中，滥用闭包可能导致内存泄漏。解决方法是在函数退出之前，将不使用的局部变量全删了。
2. 闭包会在父函数外部，改变父函数内部变量的值。

![prototype](../img/JavaScript/js-prototype.png)

### 5.知道es6的promise函数吗？讲解一下



### 6.知道那些有关前端的安全问题，如何防范？


## 杭州数澜科技二面

项目组leader聊团队氛围以及团队分工

## 杭州数澜科技三面

薪资待遇以及之前的工作情况

## 菜鸟裹裹

### 类组件与函数组件生命周期有何区别，分别解释一下

   类组件，通过es6类的编写形式去编写组件，必须继承React.component，想要访问父组件传递过来的参数，可通过this.props访问
   在组件中必须实现render方法，在return中返回react对象

   函数组件，使用函数的形式编写一个react组件，


* 两类react组件，其区别主要分为以下几个方向：
* 编写形式
* 状态管理
* 生命周期
* 调用方式
* 获取渲染的值

1. 编写形式：

```javascript
// 函数组件：
function get(props){
  return <h1>props.name</h1>
}

//类组件：
class get extends React.Component{
  //构造器
  constructor(props){
    super(props)
  }
  render(){
    return<h1>this.props.name</h1>
  }
}

```
2. 状态管理：
  
```javascript
// 函数组件：在hooks出来之前，函数组件是没有状态组件的，不能保管组件的状态，不像类组件调用setstate
//出来usestate后，就可以实现如同类组件一样的效果使用状态
const[state,setstate]=useState(0);
//在使用hooks的情况下，一般函数组件调用state，则需要创建一个类组件或者state提升到你的父组件中，然后通过props对象传递到子组件


//类组件：本身就存在状态管理的情况
```

3. 生命周期

* 在函数组件中，并不存在生命周期，因为这些生命周期函数钩子都来自继承的React.Component
* 所以，如果用到生命周期，就只能使用类组件
* 但是函数组件使用的useEffect也能够代替生命周期的作用，

```javascript
//下面这段对应componentDidMount生命周期
const Demo=()=>{
  useEffect(()=>{
    console.log('hi')
  },[]);
  return<h1>hello!</h1>
}

//这段对应componentWillUnmount生命周期
const Demo=()=>{
  useEffect(()=>{
    return()=>{
      console.log("bye")
    }
  },[]);
  return<h1>bye!</h1>
}
//下面这段模拟componentDidUpdate
//在此之前需要使用useRef这个hooks
const flag = React.useRef(null)
React.useEffect(() => {
	if(!flag.current){
		flag.current = true
	} else {
		console.log("更新了")
	}
})
//在官网的文档有提到在useeffect钩子函数最后的第二参数，用于监听那个状态的变化，如果变化则执行内部函数：
//在这里我们没有传第二个参数，也就是说他默认监听所有状态，只要有状态发生改变，他就会执行，
```

4. 取出渲染的值

* 类组件与函数组件功能基本一致，但是在类组件中，输出this.props.user,Props在react中是不可变的，但是this总是可变的，以便您可以在render和生命周期函数中读取新版本
* 
### useMemo与useCallback解释一下



### 什么情况下会遇到跨域，描述一下，前端常见的处理跨域的几种方式


### 浏览器有几种缓存方式，分别介绍一下


### 深拷贝与浅拷贝


### Promise函数传来了几个参数


### 钩子函数传参类型分别有那些


## 浩晶科技

### js中有多少个数据类型

number

string

boolean

null

undefined

symbol (ES6)

bigint (ES10)

### for...in与for...of的区别

* for...in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。
* for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()和for ... of，那么for ... in的到底有什么用呢？

>  它最常用的地方应该是用于调试，可以更方便的去检查对象属性（通过输出到控制台或其他方式）。尽管对于处理存储数据，数组更实用些，但是你在处理有key-value数据（比如属性用作“键”），需要检查其中的任何键是否为某值的情况时，还是推荐用for ... in。


```javascript
var obj = {a:1, b:2, c:3};

for (var prop in obj) {
  console.log("obj." + prop + " = " + obj[prop]);
}

// Output:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
```

* for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

```javascript
const array1 = ['a', 'b', 'c'];

for (const element of array1) {
  console.log(element);
}

// expected output: "a"
// expected output: "b"
// expected output: "c"
```


**for...of与for...in的区别**

> 无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。

> for...in 语句以任意顺序迭代对象的可枚举属性。

> for...of 语句遍历可迭代对象定义要迭代的数据。

> 以下示例显示了与Array一起使用时，for...of循环和for...in循环之间的区别。

```javascript
Object.prototype.objCustom = function() {};
Array.prototype.arrCustom = function() {};
//每个对象将继承objCustom属性，并且作为Array的每个对象将继承arrCustom属性，因为将这些属性添加到Object.prototype (en-US)和Array.prototype。由于继承和原型链，对象iterable继承属性objCustom和arrCustom。
let iterable = [3, 5, 7];
iterable.foo = 'hello';

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i); // logs 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
```
### NaN是什么类型的（typeof(NaN)）

* NaN是Number类型

### 介绍一下let const 与var

es5 提出了var 对象，分别在es6提出了let 与const对象

**区别：**
1. 是否存在变量提升
* 变量提升：变量可以在申明之前使用。

* var 声明的变量存在变量提升，全局作用域下是 window 属性。

```javascript
console.log(a);//undefined,a 变量提升到前面，相当于 var a;a = 10;
var a = 10;
console.log(a);//报错 Cannot access 'a' before initialization
//变量无法提升;
let a = 10;

console.log(b);//报错 Cannot access 'b' before initialization
//变量无法提升;
const b = 10;

```

2. 能否重复声明

* var 能重复声明，而let与const都不能重复声明

3. 变量值能否修改
   
* var 和 let 声明的值可以修改，而const声明是常量不能修改，但如果声明的是引用类型，可以修改其属性，例如echarts的option

4. 是否必须设置初始值

* var 和 let 声明时可以不用设置初始值，const 声明时必须设置初始值，不能使用 null 占位。

5. 是否存在块级作用域

* 块级作用域：申明的变量只在该块级作用域内有效。
* var 没有块级作用域,另外两个存在块级作用域

6. 是否存在暂时性死区

* var 不存在暂时性死区，另外两个存在

|  区别   | var  | let | const |
|  ----  | ----  |  ----  | ----  |
|  是否存在变量提升  | 是  | 否 | 否 |
|  是否能重复声明  | 是  | 否 | 否 |
|  变量值能否修改  | 能  | 能 | 否 |
|  是否必须设置初始值  | 否  | 否 | 是 |
|  是否存在块级作用域  | 否 | 是 | 是 |
|  是否存在暂时性死区  | 否  | 是 | 是 |

### 给你两个对象分别是5和6，让你不用第三方变量进行交换，如何实现

> 方法一:
> 使用加减乘除运算，让一个数+到另一个数上然后再做差，同理，一个数×到另一个数上依然做除法就可以交换

>方法二：


###  闭包是什么，有什么特性，对页面有什么影响

* 闭包是什么？

> 闭包是指有权访问另一个函数作用域中变量的函数

* 怎么创建闭包 ?在函数内部嵌套使用函数

```javascript
function fn() {
    for (var i = 0; i < 2; i++) {
        (function() {
            var variate = i;
            setTimeout(function() {
                console.log("setTimeout执行后:" + variate);
            }, 1000);
        })(); //闭包,立即执行函数,匿名函数
    }
    console.log(i); //2
    console.log(variate); //variate is not defined
}
fn();

```

* 为什么用闭包

> 因为在闭包内部保持了对外部活动对象的访问,但外部的变量却无法直接访问内部,避免了全局污染;
可以当做私有成员,弥补了因js语法带来的面向对象编程的不足;
可以长久的在内存中保存一个自己想要保存的变量.

* 闭包的缺点
> 可能导致内存占用过多,因为闭包携带了自身的函数作用域
闭包只能取得外部包含函数中得最后一个值

### 箭头函数

1.  箭头函数是匿名函数，不能作为构造函数，不能使用new
2.  箭头函数不绑定arguments，取而代之用rest参数...解决

```javascript
function A(a){
  console.log(arguments);
  //arguments 是一个类数组对象。代表传给一个function的参数列表。
}
A(1,2,3,4,5,8);  //  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]


let B = (b)=>{
  console.log(arguments);
}
B(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined


let C = (...c) => {
  console.log(c);
}
C(3,82,32,11323);  // [3, 82, 32, 11323]
```

3. 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
4. 箭头函数没有原型属性

```javascript
var a = ()=>{
  return 1;
}

function b(){
  return 2;
}

console.log(a.prototype);  // undefined
console.log(b.prototype);   // {constructor: ƒ}
```

5. 箭头函数不能当做Generator函数,不能使用yield关键字

### react生命周期介绍一下

### react-router的hash模式和history模式有何区别

> 区别一：打开页面的路径的url中：hash带有#，history没有。


> 区别二：



* react官方推荐：browserHistory 是使用 React-Router 的应用推荐的 history方案。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/list/123这样真实的 URL 。
* 因为是使用真实的浏览器history，就像HTML网页间的跳转一样，和浏览器的操作配合完美（浏览器自带的“后退”，“前进”，“刷新” 按钮，浏览器会记录浏览history）
  
[官方解释：https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html](https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html)


* 另外：此处需要解释一下单页面应用（SPA）和多页面应用（MPA）：
  

1. 多页面模式（MPA  Multi-page Application）： 多页面跳转需要刷新所有资源，每个公共资源(js、css等)需选择性重新加载
2. 页面跳转：使用window.location.href = "./index.html"进行页面间的跳转；
3. 数据传递：可以使用path?account="123"&password=""路径携带数据传递的方式，或者localstorage、cookie等存储方式
4. 单页面模式（SPA  Single-page Application）： 只有一个Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次
5. 页面跳转：使用js中的append/remove或者show/hide的方式来进行页面内容的更换；
6. 数据传递：可通过全局变量或者参数传递，进行相关数据交互

多页面模式，就是多个HTML页面之间的操作，浏览器会通过自身的history处理好页面间的操作，

单页面模式，对于浏览器来说只有一个HTML页面，任何操作都在同一个页面内，浏览器无法监控到页面跳转（实际只是内容改变，路径没变）


### webpack的loader和plugin的区别

1. 从功能作用的角度区分：

* loader：

     loader从字面的意思理解，是 加载 的意思。

      由于webpack 本身只能打包commonjs规范的js文件，所以，针对css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。

      loader虽然是扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。

      loader是运行在NodeJS中。

      仅仅只是为了打包，仅仅只是为了打包，仅仅只是为了打包，重要的话说三遍！！！

       

如：css-loader和style-loader模块是为了打包css的

      babel-loader和babel-core模块时为了把ES6的代码转成ES5

      url-loader和file-loader是把图片进行打包的。

* plugins

plugin也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。

      插件可以携带参数，所以在plugins属性传入new实例。

如：

1）、针对html文件打包和拷贝（还有很多设置）的插件：html-webpack-plugin。

       不但完成了html文件的拷贝，打包，还给html中自动增加了引入打包后的js文件的代码（<script src=""></script>），还能指明把js文件引入到html文件的底部等等。
2. 从运行时机的角度区分

*  loader运行在打包文件之前（loader为在模块加载时的预处理文件）
* plugins在整个编译周期都起作用。

### webpack的构建流程

从启动构建到输出结果一系列过程：

（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。

（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。

（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。

（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。

（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。

（6）输出完成：输出所有的chunk到文件系统。

注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。