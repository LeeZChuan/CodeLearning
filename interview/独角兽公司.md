- 准备时间8月1日
- 
- [杭州数澜科技一面](#杭州数澜科技一面)
  - [自我介绍](#自我介绍)
  - [项目介绍](#项目介绍)
  - [1.用过svg吗，讲讲svg与canvas](#1用过svg吗讲讲svg与canvas)
  - [2.讲解一下如何利用d3实现柱状图从0-100的移动](#2讲解一下如何利用d3实现柱状图从0-100的移动)
  - [3.](#3)
- [杭州智能涂鸦一面](#杭州智能涂鸦一面)
  - [自我介绍](#自我介绍-1)
  - [项目介绍](#项目介绍-1)
  - [1.用过css的什么，知道浮动窗口吗，如何实现的，](#1用过css的什么知道浮动窗口吗如何实现的)
  - [2.讲一下你的简历中的项目，流程是什么样的，](#2讲一下你的简历中的项目流程是什么样的)
  - [3.讲一下es6的var与let](#3讲一下es6的var与let)
  - [4.讲一下js的闭包，是什么？（谈谈对闭包的理解，闭包的用途，闭包的缺点）](#4讲一下js的闭包是什么谈谈对闭包的理解闭包的用途闭包的缺点)
  - [5.知道es6的promise函数吗？讲解一下](#5知道es6的promise函数吗讲解一下)
  - [6.知道那些有关前端的安全问题，如何防范？](#6知道那些有关前端的安全问题如何防范)
- [杭州数澜科技二面](#杭州数澜科技二面)
- [杭州数澜科技三面](#杭州数澜科技三面)
- [菜鸟裹裹](#菜鸟裹裹)
  - [类组件与函数组件生命周期有何区别，分别解释一下](#类组件与函数组件生命周期有何区别分别解释一下)
  - [useMemo与useCallback解释一下](#usememo与usecallback解释一下)
  - [什么情况下会遇到跨域，描述一下，前端常见的处理跨域的几种方式](#什么情况下会遇到跨域描述一下前端常见的处理跨域的几种方式)
  - [浏览器有几种缓存方式，分别介绍一下](#浏览器有几种缓存方式分别介绍一下)
  - [深拷贝与浅拷贝](#深拷贝与浅拷贝)
  - [Promise函数传来了几个参数(作用是什么)](#promise函数传来了几个参数作用是什么)
  - [钩子函数传参类型分别有那些](#钩子函数传参类型分别有那些)
- [浩鲸科技（外包）](#浩鲸科技外包)
  - [js中有多少个数据类型](#js中有多少个数据类型)
  - [for...in与for...of的区别](#forin与forof的区别)
  - [NaN是什么类型的（typeof(NaN)）](#nan是什么类型的typeofnan)
  - [介绍一下let const 与var](#介绍一下let-const-与var)
  - [给你两个对象分别是5和6，让你不用第三方变量进行交换，如何实现](#给你两个对象分别是5和6让你不用第三方变量进行交换如何实现)
  - [闭包是什么，有什么特性，对页面有什么影响](#闭包是什么有什么特性对页面有什么影响)
  - [箭头函数](#箭头函数)
  - [react生命周期介绍一下](#react生命周期介绍一下)
  - [react-router的hash模式和history模式有何区别](#react-router的hash模式和history模式有何区别)
  - [webpack的loader和plugin的区别](#webpack的loader和plugin的区别)
  - [webpack的构建流程](#webpack的构建流程)
  - [防抖函数](#防抖函数)
  - [节流函数](#节流函数)
  - [useEffect传入的参数可以使用对象吗](#useeffect传入的参数可以使用对象吗)
  - [组件间通信可以使用那些方法](#组件间通信可以使用那些方法)
  - [原型原型链是什么](#原型原型链是什么)
  - [ES6有哪些新特性](#es6有哪些新特性)
  - [数据间通信有哪些方式总结一下](#数据间通信有哪些方式总结一下)
  - [浏览器输入url发生了什么描述一下](#浏览器输入url发生了什么描述一下)
- [上海小公司](#上海小公司)
  - [聊聊你做过那些自定义的hooks](#聊聊你做过那些自定义的hooks)
  - [HOC了解吗，实现过那些](#hoc了解吗实现过那些)
  - [使用useEffect钩子函数的时候object对象是否可以作为被监听的对象](#使用useeffect钩子函数的时候object对象是否可以作为被监听的对象)
  - [如何判断一个对象是空对象](#如何判断一个对象是空对象)
- [木链科技](#木链科技)
  - [讲讲项目如何实现](#讲讲项目如何实现)
  - [讲讲如何实现多数据页面展示卡顿的处理](#讲讲如何实现多数据页面展示卡顿的处理)
  - [聊聊时间定时器应该选择那个？settimeout还是settimeinterval](#聊聊时间定时器应该选择那个settimeout还是settimeinterval)
  - [讲讲d3.js与three.js的区别与异同](#讲讲d3js与threejs的区别与异同)
  - [讲讲浮动float](#讲讲浮动float)
  - [讲讲事件循环机制event loop](#讲讲事件循环机制event-loop)
- [有赞](#有赞)
  - [new string赋值给a，a的类型是什么](#new-string赋值给aa的类型是什么)
  - [es6有哪些类型（基本数据类型、复杂数据类型）](#es6有哪些类型基本数据类型复杂数据类型)
  - [聊聊es6的symbol](#聊聊es6的symbol)
  - [如何知道一个对象上的属性是否可以枚举](#如何知道一个对象上的属性是否可以枚举)
  - [promise聊聊](#promise聊聊)
  - [函数内部的this指向以及如何改变函数内部的指向](#函数内部的this指向以及如何改变函数内部的指向)
  - [promise.all与.race的区别](#promiseall与race的区别)
  - [聊聊promise.finally()](#聊聊promisefinally)
  - [javascript的map与object的区别](#javascript的map与object的区别)
  - [object的key值有哪些类型](#object的key值有哪些类型)
  - [flex布局的默认方向,什么参数可以修改](#flex布局的默认方向什么参数可以修改)
  - [组件优化渲染的方法有哪些](#组件优化渲染的方法有哪些)
  - [react渲染中的key你知道吗，](#react渲染中的key你知道吗)
  - [webpack与babel一起使用吗，聊聊之间的关系](#webpack与babel一起使用吗聊聊之间的关系)
  - [node.js做什么的，简单聊聊](#nodejs做什么的简单聊聊)
  - [git操作暂存区和工作区是什么做什么的](#git操作暂存区和工作区是什么做什么的)
  - [git如何将工作区储存到暂存区](#git如何将工作区储存到暂存区)
  - [代码：](#代码)
- [博彦科技](#博彦科技)
  - [react生命周期](#react生命周期)
  - [js的作用域与作用域链](#js的作用域与作用域链)
  - [const定义的属性可否被改变](#const定义的属性可否被改变)
  - [了解es6吗，聊聊有哪些新特性](#了解es6吗聊聊有哪些新特性)
  - [空对象是真还是假](#空对象是真还是假)
  - [了解apply,call,bind（）吗，讲讲](#了解applycallbind吗讲讲)
  - [讲讲let与const](#讲讲let与const)
  - [原型与原型链](#原型与原型链)

## 杭州数澜科技一面

### 自我介绍

### 项目介绍

### 1.用过svg吗，讲讲svg与canvas

canvas（相当于ps）：字面意思就是画布，canvas通过结合javascript来绘制各种图形

1. 使用js动态生成
2. 基于位图（像素），不要随便放大缩小
3. 修改后重绘

svg（画布相当于ai）：
1. 使用xml静态描绘
2. 基于矢量（公式）
3. 修改后不需要重绘


### 2.讲解一下如何利用d3实现柱状图从0-100的移动

### 3.


## 杭州智能涂鸦一面

### 自我介绍

### 项目介绍

### 1.用过css的什么，知道浮动窗口吗，如何实现的，


   float 是一种选择，但是使用 inline-block 会更简单。让我们看下使用这两种方法的例子：

* 试用float方法
```css
.box {
  float: left;
  width: 200px;
  height: 100px;
  margin: 1em;
}
.after-box {
  clear: left;
  /* 取消浮动 */
}

```

* 容易的方式（使用 inline-block）你可以用 display 属性的值 inline-block 来实现相同效果。

```css
.box2 {
  display: inline-block;
  width: 200px;
  height: 100px;
  margin: 1em;
}
```

    

### 2.讲一下你的简历中的项目，流程是什么样的，

### 3.讲一下es6的var与let

es5 提出了var 对象，分别在es6提出了let 与const对象

**区别：**
1. 是否存在变量提升
* 变量提升：变量可以在申明之前使用。

* var 声明的变量存在变量提升，全局作用域下是 window 属性。

```javascript
console.log(a);//undefined,a 变量提升到前面，相当于 var a;a = 10;
var a = 10;
console.log(a);//报错 Cannot access 'a' before initialization
//变量无法提升;
let a = 10;

console.log(b);//报错 Cannot access 'b' before initialization
//变量无法提升;
const b = 10;

```

2. 能否重复声明

* var 能重复声明，而let与const都不能重复声明

3. 变量值能否修改
   
* var 和 let 声明的值可以修改，而const声明是常量不能修改，但如果声明的是引用类型，可以修改其属性，例如echarts的option

4. 是否必须设置初始值

* var 和 let 声明时可以不用设置初始值，const 声明时必须设置初始值，不能使用 null 占位。

5. 是否存在块级作用域

* 块级作用域：申明的变量只在该块级作用域内有效。
* var 没有块级作用域,另外两个存在块级作用域

6. 是否存在暂时性死区

* var 不存在暂时性死区，另外两个存在

| 区别               | var | let | const |
| ------------------ | --- | --- | ----- |
| 是否存在变量提升   | 是  | 否  | 否    |
| 是否能重复声明     | 是  | 否  | 否    |
| 变量值能否修改     | 能  | 能  | 否    |
| 是否必须设置初始值 | 否  | 否  | 是    |
| 是否存在块级作用域 | 否  | 是  | 是    |
| 是否存在暂时性死区 | 否  | 是  | 是    |


### 4.讲一下js的闭包，是什么？（谈谈对闭包的理解，闭包的用途，闭包的缺点）

+ 闭包是指有权访问另外一个函数作用域中的变量的函数
+ 闭包的用途：
1. 设计私有的方法和变量。
2. 匿名函数最大的用途是创建闭包，并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。
+ 闭包的缺点：
1. 闭包会使得函数中的变量都被保存在内存中，滥用闭包可能导致内存泄漏。解决方法是在函数退出之前，将不使用的局部变量全删了。
2. 闭包会在父函数外部，改变父函数内部变量的值。

![prototype](../img/JavaScript/js-prototype.png)

### 5.知道es6的promise函数吗？讲解一下

* 目的：
* 为了解决回调地狱的问题，之后社区提出了 Promise 的解决方案，ES6 又将其写进了语言标准，采用 Promise 的实现方式在一定程度上解决了回调地狱的问题


* Promise 到底是什么，简单来说它就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。

Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理

### 6.知道那些有关前端的安全问题，如何防范？

一、XSS(Cross Site Scripting)跨站JS脚本攻击，如何防范？

* 针对接口进行 XSS攻击，即把js脚本或者带恶意js脚本的html标签，作为GET或者POST参数提交到服务器，然后服务器解释并响应
* 防范方式：
* 1）提交数据前前端要做数据校验，对用户输入的信息(js代码及dom节点)进行过滤。
* 2）对重要的cookie设置为httponly（服务器端可设置此字段），客户端就没有操作此cookie的权限。
* 3）服务器端也要数据合法性校验
针对DOM本身进行 XSS攻击，如果本身页面代码中使用了window.eval来执行代码。eval本身会把一段字符串变成可执行的js代码，这是非常危险的。还有拼接html字符串后直接显示DOM时也会遇到同样的问题。防范方式：尽量避免使用eval，拼接html字符串时应校验字符串的合法性，过滤非法元素节点与属性节点,如iframe,script标签，onerror事件, style, src, href等。
 
* 可能产生危害：泄露了个人的cookie信息，身份认证被套取后，被用作非法用途

* 非法字符过滤可以使用第三方的过滤库如：HTMLParser.js及he.js

二、CSRF(Cross-site request forgery)跨站请求(GET和POST)伪造攻击，如何防范？ 

* 由于浏览器一般都是可同时打开多标签的。举个例了，现浏览器同时打开了两个标签，一个是已被合法登录并保持登录状态的网站A，另外一个是已被欺骗打开的含恶意代码的网站B（不一定是来源于非法网站，也可能藏在各大合法论坛上的一些非法链接被你打开了），则可以通过在恶意网站B上静态或者动态创建img,script等标签发起GET或者POST请求，发出的恶意请求是身份认证后的，这就构成CSRF攻击了。将其src属性指向发起对A网站的接口请求（如一个GET请求：api.a.com/blog/del?id=1）。通过标签的方式发起的请求不受同源策略的限制。

* 可能产生危害：模拟表单提交盗取用户资金，篡改目标网站上的用户数据，盗取用户隐私数据

* 防范方式：
* 1）后端接口要对接口请求来源如（* Referer:）字段进行合法校验。
* 2）添加token，带token请求。


三、SQL注入，攻击如何防范？

1. 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双"-"进行转换等。

2. 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。

3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

4. 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。

5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装

6. sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky,网站平台就有亿思网站安全平台检测工具。


四、接口访刷问题，前端如何与后端配合？

* 在IT行业混得有一点资历的人估计都会遇到过接口被刷的情况了。如：听说搞某某活动，大奖瞬间被刷走。某某营销活动，奖品瞬间被抢光了。某某平台，短信验证码几天被刷到欠费。

认真去查查记录，发现这些行为都是人家用机器写程序自动刷你接口的。现在还有卡商有各种短信接码平台，专业批量接发验证码的。

如何能更好的做接口防刷：

1. 发送请求之前前端这边要做人机识别。（如微信的静默授权返回一次唯一码，小程序的wx.login接口返回的code，可供后端二次验证，还有发送短信验证码前要手动先输入验证码，或者使用拖动方块填充缺块那种人机识明系统）

2. 接口传参要带加密签名。

五、前端常用的加密方式有哪些？

sha1，base64，md5，SHA256，SHA512，RMD160等

常用开源库有：

https://github.com/blueimp/JavaScript-MD5

https://github.com/h2non/jshashes

https://github.com/dankogai/js-base64

## 杭州数澜科技二面

项目组leader聊团队氛围以及团队分工

## 杭州数澜科技三面

薪资待遇以及之前的工作情况

## 菜鸟裹裹

### 类组件与函数组件生命周期有何区别，分别解释一下

   类组件，通过es6类的编写形式去编写组件，必须继承React.component，想要访问父组件传递过来的参数，可通过this.props访问
   在组件中必须实现render方法，在return中返回react对象

   函数组件，使用函数的形式编写一个react组件，


* 两类react组件，其区别主要分为以下几个方向：
* 编写形式
* 状态管理
* 生命周期
* 调用方式
* 获取渲染的值

1. 编写形式：

```javascript
// 函数组件：
function get(props){
  return <h1>props.name</h1>
}

//类组件：
class get extends React.Component{
  //构造器
  constructor(props){
    super(props)
  }
  render(){
    return<h1>this.props.name</h1>
  }
}

```
2. 状态管理：
  
```javascript
// 函数组件：在hooks出来之前，函数组件是没有状态组件的，不能保管组件的状态，不像类组件调用setstate
//出来usestate后，就可以实现如同类组件一样的效果使用状态
const[state,setstate]=useState(0);
//在使用hooks的情况下，一般函数组件调用state，则需要创建一个类组件或者state提升到你的父组件中，然后通过props对象传递到子组件
//类组件：本身就存在状态管理的情况
```

3. 生命周期

* 在函数组件中，并不存在生命周期，因为这些生命周期函数钩子都来自继承的React.Component
* 所以，如果用到生命周期，就只能使用类组件
* 但是函数组件使用的useEffect也能够代替生命周期的作用，

```javascript
//下面这段对应componentDidMount生命周期
const Demo=()=>{
  useEffect(()=>{
    console.log('hi')
  },[]);
  return<h1>hello!</h1>
}

//这段对应componentWillUnmount生命周期
const Demo=()=>{
  useEffect(()=>{
    return()=>{
      console.log("bye")
    }
  },[]);
  return<h1>bye!</h1>
}
//下面这段模拟componentDidUpdate
//在此之前需要使用useRef这个hooks
const flag = React.useRef(null)
React.useEffect(() => {
	if(!flag.current){
		flag.current = true
	} else {
		console.log("更新了")
	}
})
//在官网的文档有提到在useeffect钩子函数最后的第二参数，用于监听那个状态的变化，如果变化则执行内部函数：
//在这里我们没有传第二个参数，也就是说他默认监听所有状态，只要有状态发生改变，他就会执行，
```

4. 取出渲染的值

* 类组件与函数组件功能基本一致，但是在类组件中，输出this.props.user,Props在react中是不可变的，但是this总是可变的，以便您可以在render和生命周期函数中读取新版本
* 
### useMemo与useCallback解释一下


   function useMemo<T>(factory: () => T, deps: DependencyList | undefined): T; 
   function useCallback<T extends (...args: any[]) => any>(callback: T, deps: DependencyList): T;

> useCallback和useMemo的参数跟useEffect一致，他们之间最大的区别有是useEffect会用于处理副作用，而前两个hooks不能。
> useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。

讲完了useMemo，接下来是useCallback。useCallback跟useMemo比较类似，但它返回的是缓存的函数。我们看一下最简单的用法：

> const fnA = useCallback(fnB, [a])
> 上面的useCallback会将我们传递给它的函数fnB返回，并且将这个结果缓存；当依赖a变更时，会返回新的函数。既然返回的是函数，我们无法很好的判断返回的函数是否变更，所以我们可以借助ES6新增的数据类型Set来判断，具体如下：

多谈一点
useEffect、useMemo、useCallback都是自带闭包的。也就是说，每一次组件的渲染，其都会捕获当前组件函数上下文中的状态(state, props)，所以每一次这三种hooks的执行，反映的也都是当前的状态，你无法使用它们来捕获上一次的状态。对于这种情况，我们应该使用ref来访问。

### 什么情况下会遇到跨域，描述一下，前端常见的处理跨域的几种方式

广义上：
1.  资源跳转： A链接、重定向、表单提交
2.  资源嵌入： <link>、<script>、<img>、<frame>等dom标签，还有样式中background:url()、@font-face()等文件外链
3.  脚本请求： js发起的ajax请求、dom和js对象的跨域操作等

跨域解决方案
1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域

### 浏览器有几种缓存方式，分别介绍一下

浏览器有强制缓存与协商缓存两种方式，

* 强制缓存
  
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)：

不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：

![强制缓存](../img/JavaScript/强制缓存.jpg)

* 协商缓存
  
当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。

### 深拷贝与浅拷贝

- 浅拷贝，**如果被拷贝的属性是基本类型，拷贝的就是基本类型的值；如果数据属性是引用类型，拷贝的就是内存地址**
- 由于引用是指针上的引用，没有改变对象的储存地址，当在引用对象进行了修改，原始数据上也会进行修改


- 而深拷贝，从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。
- 当拷贝完成，那么你在修改新的对象的时候，并不会出现原始对象也被修改的情况
- 内存中有栈区和堆区，基本类型数据直接存在栈中，而引用类型（new出来的）是在堆中存储，在栈中保存堆中的地址。


- 也就是说引用类型中在栈中存的不是数据，而是地址。赋值其实就是拷贝。在基本类型数据赋值的时候，没有深浅拷贝的区别，因为直接赋予的是数据。
- 但在引用类型数据赋值的时候，实际上是把原来的地址复制给了新的，并没有实际复制其中的数据，所以这是一个浅拷贝（拷贝的深度不够），

1. 浅拷贝与赋值的区别：
- 赋值：当我们把一个对象赋值给一个新的变量时，赋值的其实时该对象在栈中的地址，而不是堆中的数据，也就是两个对象指向的时同一个储存空间，无论那个对象发生改变，其实改变的都是储存空间的内容
- 浅拷贝：重新在堆中创建内存，拷贝哦前后对象的基本数据类型互不影响(Undefined、Null、Boolean、Number和String是基本数据类型)，但拷贝前后对象的引用类型因共享一块内存，会互相影响。(引用数据类型也就是对象数据类型object，比如：object、array、function、data等；)
- 深拷贝：从堆内存中开辟一块新的区域存放新对象，堆对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。

2. 浅拷贝的实现方式：

- Object.assign()，es5
- lodash里面中的_.clone
- ...展开运算符，es6
- Array.prototype.concet()
- Array.prototype.slice()


1. 深拷贝的实现方式：
   
- JSON.parse(JSON.stringify())-->有弊端，会让Date，function都会消失
- 递归的操作
- cloneDeep
- Jquery.extend()


```javascript
//浅拷贝
function shallowCopy(obj){
  var target={}
  for(var i in obj){
    if(obj.hasOwnProperty(i)){
      //hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。
      target[i]=obj[i]
    }
  }
  return target
}

//深拷贝
function deepClone(obj){
  if (obj instanceof Array) {
        cloneObj = [];
    } else {
        cloneObj={};
    }
//A instanceof B 意思就是B的prototype是否在A的原型链上
if(obj instanceof Date) return new Date(obj)
if(obj instabceof RegExp) return new RegExp(obj)
  //或者使用instamceof进行类型判断
  for(var i in obj){
    if(obj.hasOwnProperty(i)){
      target[i]=deepClone(obj[i])
    }
  }
  return cloneObj;
}
```

1. 深拷贝的实现方式
   
```javascript
function deepCopy(obj) {
    if (typeof obj !== 'object' || obj == null) {
        return obj;
    }
    let result;
    if (obj instanceof Array) {
        result = [];
    } else {
        result = {};
    }
    //开始拷贝
    for (let key in obj) {
        // result[key] = obj[key];//深拷贝核心--一层克隆
        if(obj.hasOwnProperty(key)){
              //hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。
            result[key]=deepCopy(obj[key]);//递归调用嵌套对象就不会被影响到
        }
    }
    return result;
}

//对于数组对象的深拷贝则有两个方法

//（1）for循环实现数组的深拷贝
//（2）concat 方法实现数组的深拷贝

concat() 方法用于连接两个或多个数组。

//(3)slice 方法实现数组的深拷贝

arrayObject.slice(start,end)

//（4）ES6扩展运算符实现数组的深拷贝
// ...扩展运算符是ES6的语法，使用起来非常的方便简洁，相信在写ES6的时候也是备受欢迎的。但是需要注意的是：用扩展运算符对数组或者对象进行拷贝时，只能扩展和深拷贝第一层的值，对于第二层极其以后的值，扩展运算符将不能对其进行打散扩展，也不能对其进行深拷贝，即拷贝后和拷贝前第二层中的对象或者数组仍然引用的是同一个地址，其中一方改变，另一方也跟着改变。

1 var arr1 = [1, 2, 3];
2 var [...arr2] = arr1;
3 arr1[0] = 4;
4 console.log(arr1); //4, 2, 3
5 console.log(arr2); //1, 2, 3
```


### Promise函数传来了几个参数(作用是什么)




### 钩子函数传参类型分别有那些



## 浩鲸科技（外包）

### js中有多少个数据类型

number

string

boolean

null

undefined

symbol (ES6)

bigint (ES10)

### for...in与for...of的区别

* for...in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。
* for … of遍历获取的是对象的键值,for … in 获取的是对象的键名
* for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()和for ... of，那么for ... in的到底有什么用呢？

>  它最常用的地方应该是用于调试，可以更方便的去检查对象属性（通过输出到控制台或其他方式）。尽管对于处理存储数据，数组更实用些，但是你在处理有key-value数据（比如属性用作“键”），需要检查其中的任何键是否为某值的情况时，还是推荐用for ... in。


```javascript
var obj = {a:1, b:2, c:3};

for (var prop in obj) {
  console.log("obj." + prop + " = " + obj[prop]);
}

// Output:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
```

* for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

```javascript
const array1 = ['a', 'b', 'c'];

for (const element of array1) {
  console.log(element);
}

// expected output: "a"
// expected output: "b"
// expected output: "c"
```


**for...of与for...in的区别**

> 无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。

> for...in 语句以任意顺序迭代对象的可枚举属性。

> for...of 语句遍历可迭代对象定义要迭代的数据。

> 以下示例显示了与Array一起使用时，for...of循环和for...in循环之间的区别。

```javascript
Object.prototype.objCustom = function() {};
Array.prototype.arrCustom = function() {};
//每个对象将继承objCustom属性，并且作为Array的每个对象将继承arrCustom属性，因为将这些属性添加到Object.prototype (en-US)和Array.prototype。由于继承和原型链，对象iterable继承属性objCustom和arrCustom。
let iterable = [3, 5, 7];
iterable.foo = 'hello';

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i); // logs 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
```
### NaN是什么类型的（typeof(NaN)）

* NaN是Number类型

### 介绍一下let const 与var

es5 提出了var 对象，分别在es6提出了let 与const对象

**区别：**
1. 是否存在变量提升
* 变量提升：变量可以在申明之前使用。

* var 声明的变量存在变量提升，全局作用域下是 window 属性。

```javascript
console.log(a);//undefined,a 变量提升到前面，相当于 var a;a = 10;
var a = 10;
console.log(a);//报错 Cannot access 'a' before initialization
//变量无法提升;
let a = 10;

console.log(b);//报错 Cannot access 'b' before initialization
//变量无法提升;
const b = 10;

```

2. 能否重复声明

* var 能重复声明，而let与const都不能重复声明

3. 变量值能否修改
   
* var 和 let 声明的值可以修改，而const声明是常量不能修改，但如果声明的是引用类型，可以修改其属性，例如echarts的option

4. 是否必须设置初始值

* var 和 let 声明时可以不用设置初始值，const 声明时必须设置初始值，不能使用 null 占位。

5. 是否存在块级作用域

* 块级作用域：申明的变量只在该块级作用域内有效。
* var 没有块级作用域,另外两个存在块级作用域

6. 是否存在暂时性死区

* var 不存在暂时性死区，另外两个存在

| 区别               | var | let | const |
| ------------------ | --- | --- | ----- |
| 是否存在变量提升   | 是  | 否  | 否    |
| 是否能重复声明     | 是  | 否  | 否    |
| 变量值能否修改     | 能  | 能  | 否    |
| 是否必须设置初始值 | 否  | 否  | 是    |
| 是否存在块级作用域 | 否  | 是  | 是    |
| 是否存在暂时性死区 | 否  | 是  | 是    |

### 给你两个对象分别是5和6，让你不用第三方变量进行交换，如何实现

> 方法一:
> 使用加减乘除运算，让一个数+到另一个数上然后再做差，同理，一个数×到另一个数上依然做除法就可以交换

>方法二：


###  闭包是什么，有什么特性，对页面有什么影响

* 闭包是什么？

> 闭包是指有权访问另一个函数作用域中变量的函数

* 怎么创建闭包 ?在函数内部嵌套使用函数

```javascript
function fn() {
    for (var i = 0; i < 2; i++) {
        (function() {
            var variate = i;
            setTimeout(function() {
                console.log("setTimeout执行后:" + variate);
            }, 1000);
        })(); //闭包,立即执行函数,匿名函数
    }
    console.log(i); //2
    console.log(variate); //variate is not defined
}
fn();

```

* 为什么用闭包

> 因为在闭包内部保持了对外部活动对象的访问,但外部的变量却无法直接访问内部,避免了全局污染;
可以当做私有成员,弥补了因js语法带来的面向对象编程的不足;
可以长久的在内存中保存一个自己想要保存的变量.

* 闭包的缺点
> 可能导致内存占用过多,因为闭包携带了自身的函数作用域
闭包只能取得外部包含函数中得最后一个值

### 箭头函数

1.  箭头函数是匿名函数，不能作为构造函数，不能使用new
2.  箭头函数不绑定arguments，取而代之用rest参数...解决

```javascript
function A(a){
  console.log(arguments);
  //arguments 是一个类数组对象。代表传给一个function的参数列表。
}
A(1,2,3,4,5,8);  //  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]


let B = (b)=>{
  console.log(arguments);
}
B(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined


let C = (...c) => {
  console.log(c);
}
C(3,82,32,11323);  // [3, 82, 32, 11323]
```

3. 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
    箭头函数根本就没有this指针，是最外层代码块的this：也就是继承父执行的上下文中的this
4. 箭头函数没有原型属性

```javascript
var a = ()=>{
  return 1;
}

function b(){
  return 2;
}

console.log(a.prototype);  // undefined
console.log(b.prototype);   // {constructor: ƒ}
```

5. 箭头函数不能当做Generator函数,不能使用yield关键字

### react生命周期介绍一下

### react-router的hash模式和history模式有何区别

> 区别一：打开页面的路径的url中：hash带有#，history没有。


> 区别二：



* react官方推荐：browserHistory 是使用 React-Router 的应用推荐的 history方案。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/list/123这样真实的 URL 。
* 因为是使用真实的浏览器history，就像HTML网页间的跳转一样，和浏览器的操作配合完美（浏览器自带的“后退”，“前进”，“刷新” 按钮，浏览器会记录浏览history）
  
[官方解释：https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html](https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html)


* 另外：此处需要解释一下单页面应用（SPA）和多页面应用（MPA）：
  

1. 多页面模式（MPA  Multi-page Application）： 多页面跳转需要刷新所有资源，每个公共资源(js、css等)需选择性重新加载
2. 页面跳转：使用window.location.href = "./index.html"进行页面间的跳转；
3. 数据传递：可以使用path?account="123"&password=""路径携带数据传递的方式，或者localstorage、cookie等存储方式
4. 单页面模式（SPA  Single-page Application）： 只有一个Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次
5. 页面跳转：使用js中的append/remove或者show/hide的方式来进行页面内容的更换；
6. 数据传递：可通过全局变量或者参数传递，进行相关数据交互

多页面模式，就是多个HTML页面之间的操作，浏览器会通过自身的history处理好页面间的操作，

单页面模式，对于浏览器来说只有一个HTML页面，任何操作都在同一个页面内，浏览器无法监控到页面跳转（实际只是内容改变，路径没变）


### webpack的loader和plugin的区别

1. 从功能作用的角度区分：

* loader：

      loader从字面的意思理解，是加载的意思。

      由于webpack 本身只能打包commonjs规范的js文件，所以，针对css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。

      loader虽然是扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。

      loader是运行在NodeJS中。

      仅仅只是为了打包，仅仅只是为了打包，仅仅只是为了打包，重要的话说三遍！！！

       

如：css-loader和style-loader模块是为了打包css的

      babel-loader和babel-core模块时为了把ES6的代码转成ES5

      url-loader和file-loader是把图片进行打包的。

* plugins

plugin也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。

      插件可以携带参数，所以在plugins属性传入new实例。

如：

1）、针对html文件打包和拷贝（还有很多设置）的插件：html-webpack-plugin。

       不但完成了html文件的拷贝，打包，还给html中自动增加了引入打包后的js文件的代码（<script src=""></script>），还能指明把js文件引入到html文件的底部等等。
2. 从运行时机的角度区分

*  loader运行在打包文件之前（loader为在模块加载时的预处理文件）
* plugins在整个编译周期都起作用。

### webpack的构建流程

从启动构建到输出结果一系列过程：

（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。

（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。

（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。

（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。

（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。

（6）输出完成：输出所有的chunk到文件系统。

注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。

### 防抖函数

* 防抖函数

> 当持续触发事件，一定时间内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时
> 触发事件 一段时间内 没有触发 事件执行 肯定是定时器
> (在设定的时间内 没有触发 事件执行 肯定事定时器)
> (那么意味着上一次还没有结束的定时器要清除掉 重新开始)

```js
function debounce(delay,value){
   let timer
 clearInterval(timer)
//我们想清楚的是setTimeout 我们应该储存这个timer的变量
//timer变量需要一直保存在内存当中
  timer=setTimeout(function(){
    console.log(value)
},delay)
}

//我需要做的是，首先，输入框的结果只出现一次，是在我键盘抬起不在输入的1秒之后打印
input.addEventListener('keyup',function(e){
  debounce(1000,e.target.value)
})  

//这里需要用到闭包 
function debounce(delay){
  let timer
  return function(value){
    clearTimeout(timer)
    timer=setTimeout(function(){
    // console.log(value)
    //使用回调函数将数值进行输出
    callback(value)
    },delay)
  }
}
//需要在这里进行位置输出，应该需要回调函数
function callback(value){
  console.log(value);
}

var debounceFunc=debounce(1000)
input.addEventListener('keyup',function(e){
  debounceFunc (e.target.value)
}) 
```

* 实际应用

> 使用echarts时，改变浏览器宽度的时候，希望重新渲染echarts的图像，可以使用该函数，提升性能。（虽然echarts里面有自带的resize函数）
> 典型案例就是输入搜索：输入结束n秒后才进行搜索请求，n秒内又输入内容，就重新计时。解决搜索的bug

### 节流函数

* 一段时间内只做一件事情，实际应用，表单的提交：典型的案例就是鼠标不断点击的触发，规定在n秒多次点击只有一次生效

```javascript
//节流函数实现
function thro(func,waittime){
  let timerOut//判断
  return function(){
    if(!timerOut){
      timerOut=setTimeout(function(){
        func();
        timerOut=null
      },waittime)
    }
  }
}

function handle(){
  console.log(Math.random())
}

document.getElementById('button').onclick=thro(handle,2000)

```

### useEffect传入的参数可以使用对象吗

不可以

### 组件间通信可以使用那些方法

### 原型原型链是什么

### ES6有哪些新特性

1. let。const。var
2. 解构赋值
3. 箭头函数
4. for in
5. set map weakset weakmap
6. promise

### 数据间通信有哪些方式总结一下

### 浏览器输入url发生了什么描述一下

首先，我们假设输入的url的请求为最简单的Http请求，以GET请求为例，大致分以下几个步骤：

1. 用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。

2. 浏览器根据输入的URL地址解析出主机名。

3. 浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考DNS查找域名的过程。

4. 拿到ip地址后，浏览器再从URL中解析出端口号。

5. 拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是三次握手。传 送门：[完整的tcp链接](https://www.cnblogs.com/xsilence/p/6034361.html)。

6. 浏览器向服务器发送一条HTTP请求报文。

7. 服务器向浏览器返回一条HTTP响应报文。

8. 关闭连接（四次挥手） 浏览器解析文档。

如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。

以上步骤简述了浏览器从输入url到最后页面呈现的大致过程，但这并不很具体，比如浏览器请求报文类型是什么，会遇到哪些错误场景、浏览器又是如何解析响应报文等等都没具体描述。


## 上海小公司

### 聊聊你做过那些自定义的hooks

* 当我们想要在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和hook都是函数，所以也同样适用这种方式
* 自定义hook是一个函数，其名称以use开头，函数内部可以调用其他的hook，与react普通所写的组件不同的时，自定义个hook不需要特殊的标识，我们可以自由的决定他的参数时什么，以及他应该返回什么。换句话说就是他是一个正常的函数，但是他的名字始终应该以use开头，这样可以一眼看出其符合hook的规则。
* 以react官网为例，进行提取了以friendID作为参数，并返回这位好友的在线状态的原因

### HOC了解吗，实现过那些

### 使用useEffect钩子函数的时候object对象是否可以作为被监听的对象

不可以，因为监听函数是

### 如何判断一个对象是空对象

1. 将json对象转化为json字符串，再判断该字符串是否为"{}"
```javascript
var data = {};

var b = (JSON.stringify(data) == "{}");

alert(b);//true
```


2. for in 循环判断

```javascript
var obj = {};

var b = function() {
for(var key in obj) {
return false;
}
return true;
}
alert(b());//true
```
3. Object.getOwnPropertyNames()方法

此方法是使用Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的length来判断此对象是否为空

注意：此方法不兼容ie8，其余浏览器没有测试
```javascript
var data = {};

var arr = Object.getOwnPropertyNames(data);

alert(arr.length == 0);//true
```

4. 使用ES6的Object.keys()方法

与4方法类似，是ES6的新方法, 返回值也是对象中属性名组成的数组
```javascript
var data = {};

var arr = Object.keys(data);

alert(arr.length == 0);//true
```

## 木链科技

### 讲讲项目如何实现

### 讲讲如何实现多数据页面展示卡顿的处理

### 聊聊时间定时器应该选择那个？settimeout还是settimeinterval


    因为setTimeout(表达式,延时时间)在执行时,是在载入后延迟指定时间后,去执行一次表达式,记住,次数是一次
    而setInterval(表达式,交互时间)则不一样,它从载入后,每隔指定的时间就执行一次表达式
    所以,完全是不一样的

    setTimeout和setInterval都属于JS中的定时器，可以规定延迟时间再执行某个操作，不同的是setTimeout在规定时间后执行完某个操作就停止了，而setInterval则可以一直循环下去。

    在上述代码中，无论是setTimeout还是setInterval，在使用函数名作为调用句柄时不能带参数，使用字符串调用时可以带参数。例如：setTimeout(‘fun(name)’,1000);

    在上述代码中，setTimeout和setInterval的区别就是setTimeout延迟一秒弹出’hello’,之后便不再运行；而setInterval则会隔一秒弹出’hello’,直至用clear来清除定时器的语法。

    总之就是如果需要不断循环那么就是用setInterval，否则使用settimeout

### 讲讲d3.js与three.js的区别与异同

### 讲讲浮动float

1. 浮动特点1 — 脱离标准流，不占位置脱离标准文档流，不占位置就说明后面的元素可以"无视"它，顶替它的位置但不是所有元素都能"无视"它，行块元素(inline-block)和内联元素(inline)不会占掉它的位置这也是为什么多个元素同时浮动，不会在视觉上堆叠成一个元素

2. 浮动特点2 — 浮动的元素一排显示，如果父亲装不下了，默认另起一行显示。浮动的元素之间默认无缝隙。

3. 浮动特点3 — 任何元素都可以添加浮动，无论它是块元素还是行内元素，浮动后可以直接设置宽高，默认类似于行内块特性，不需要display转换。


### 讲讲事件循环机制event loop

浏览器中的事件循环 
JS 本身是单线程的，它依靠事件循环机制完成的异步操作和多线程

大体有三个部分组成：

1. 调用栈call stack
2. 消息队列message queque
3. 微任务队列microtask queque

* 对于所有执行属性，当前执行流程结束他就会弹出调用栈，

* 但对于fetch，事件回调，settimeout，setinterval会入队到消息队列中，消息会在调用栈清空的情况下执行，这也就是为什么settimeout中的时间是延迟的最小参数的原因

* 使用promise、async、await的异步操作都会加入到微任务队列中，他会在调用栈情况的情况下立即执行，
* 所以在这里如果出现消息队列与微任务队列同时出现的情况下，先是微任务队列先执行完毕后，再执行消息队列的任务

## 有赞

### new string赋值给a，a的类型是什么

### es6有哪些类型（基本数据类型、复杂数据类型）

### 聊聊es6的symbol

### 如何知道一个对象上的属性是否可以枚举

### promise聊聊

### 函数内部的this指向以及如何改变函数内部的指向

### promise.all与.race的区别

.all()是全都为真，才返回为真

.race()有真就返回真

### 聊聊promise.finally()



### javascript的map与object的区别

### object的key值有哪些类型

### flex布局的默认方向,什么参数可以修改

> flex-direction属性决定主轴的方向（即项目的排列方向）
> row（默认值）：主轴为水平方向，起点在左端。
> row-reverse：主轴为水平方向，起点在右端。
> column：主轴为垂直方向，起点在上沿。
> column-reverse：主轴为垂直方向，起点在下沿。
> justify-content属性定义了项目在主轴上的对齐方式。
> align-items属性定义项目在交叉轴上如何对齐。
> align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
> order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。


### 组件优化渲染的方法有哪些

### react渲染中的key你知道吗，

### webpack与babel一起使用吗，聊聊之间的关系

### node.js做什么的，简单聊聊

### git操作暂存区和工作区是什么做什么的

### git如何将工作区储存到暂存区

### 代码：

```javascript
// 
// - 实现 debounce
// 

function debounce(fn, delay) {
    let setTime;
    return function () {
        if(setTime)
        {
            clearTimeout(setTime);
        }
        
        setTime = setTimeout(function () {
            fn();
        }, delay)
    }

}

const a = {
    count: 1,
    log: debounce(function () {
        console.log('debouce count:', this.count++)
    }, 50)
}

a.log() // 'debouce count: 1'
a.log()
setTimeout(() => {
    a.log() // 'debouce count: 2'
}, 150)


/**
 * 比较两个版本号的大小，如果 v1 版本比 v2 高，就返回 1，相等为 0，低于为 -1
 * @param {string} v1
 * @param {string} v2
 * @returns {number}
 */

// 示例：
// compareVersion('2.0.1', '2.0.5') => -1
// compareVersion('2.0.1', '2.0.0.1') => 1

function compareVersion(v1, v2) {

}

// console.log('compareVersion:', compareVersion('2.0.1', '2.0.5'))
// console.log('compareVersion:', compareVersion('2.0.1', '2.0.0.10'))
// console.log('compareVersion:', compareVersion('2.0.0.0.5', '2.0.0.0.5'))


/**
 * 实现 getValue 函数，安全的获取目标对象指定 path 的值
 * @params {object | array} value 指定对象
 * @params {string} path
 */

const object = { 'a': [{ 'b': { 'c': 3 } }] }; // path: 'a[0].b.c'
const array = [{ "a": { b: [1] } }]; // path: '[0].a.b[0]'

function getValue(obj, path) {


}

// console.log('getValue:', getValue(object, 'a[0].b.c'))
// console.log('getValue:', getValue(array, '[0].a.b[0]'))
// console.log('getValue:', getValue(array, '[0].a.d'))
```

## 博彦科技

### react生命周期

### js的作用域与作用域链

* ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域

> 重点聊聊：块级作用域：块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：
1. 在一个函数内部
2. 在一个代码块（由一对花括号包裹）内部
3. let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。

> 作用域链:当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找,如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就报错。这种一层一层的关系，就是 作用域链 。
> 要到创建这个函数的那个域”。 作用域中取值,这里强调的是“创建”，而不是“调用”

* 作用域与执行上下文
* JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：
* 解释阶段:1.词法分析2.语法分析3.作用域规则确定
* 执行阶段：1.创建执行上下文 2.执行函数代码 3.垃圾回收

> JavaScript解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。
>作用域和执行上下文之间最大的区别是：**执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。**
>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。



### const定义的属性可否被改变

* 初始化定义的const他的指针是确定不可进行修改的，如果你想要const a与b，让他俩进行相互赋值这是不可能的

### 了解es6吗，聊聊有哪些新特性

### 空对象是真还是假

### 了解apply,call,bind（）吗，讲讲

* apply,call,bind都是js给函数内置的一些api,调用他们可以为函数指定this的执行,同时也可以传参.
* apply和call就是传参不一样,apply传一个数组，而call传递展开的数组,但是两个都是会在调用的时候同时执行调用的函数,但是bind则会返回一个绑定了this的函数.

```javascript
//apply 
func.apply(thisArg, [argsArray])

//call
fun.call(thisArg, arg1, arg2, ...)

//bind
const newFun = fun.bind(thisArg, arg1, arg2, ...)
newFun()
```

* bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。

### this指针的指向

1. 默认绑定：默认绑定一般发生在回调函数,函数直接调用;
2. 隐式绑定：这个通俗点用一句话概括就是谁调用就是指向谁
3. 显示绑定call,apply,bind

### 讲讲let与const

### 原型与原型链 

## 火石创造

### 讲讲几种类型判断

1. typeof
2. instanceof
3. object.prototype.tostring().call()
4. constral构造器

### 继承如何实现

### 数组头部添加元素有哪几种方式

1. array.push()
2. unshift() 头部添加
3. concet()

### 事件循环机制

### 数组遍历的方法

1. for循环
2. forEach方法：默认没有返回值。
3. map方法：默认返回一个数组，这个新数组的每一个元素都是原数组元素执行了回调函数之后的返回值。
4. for of方法
5. some、every方法

### 数组如何去重


### foreach与map的区别

### call，bind，apply

### 项目优化的心得

1. 加载和执行：

> 节流 资源压缩、按需加载 同域名内的文件充分的进行压缩，比如：本来2M的资源，如果压缩到1M以下（去除空格，gzip等）速度的提升就是50%；再有现在spa是将文件合并后进行压缩和打包，如果文件总体并不大，性能不会有太大影响；一旦开发中引入的UI库或第三方插件多了，总文件体量也不在少数；就有了：按需加载、延时加载的用武之地。比如在webpack打包的时候从template的html中单独加入某个css或js；更有webpack-http-require的库。
当然，图片也需要做很多相应的处理

    css实现效果（按钮、阴影等）
    压缩尺寸和size
    sprite合并
    svg、toff字体图
    canvas绘制大图（地图相关）

2. 阻塞性优化:

>js文件加载后是否要立即执行？立即执行是否会影响页面渲染？过去浏览器在加载和执行js文件时是阻塞状态，就是按照栈原理一个个来；所以，原来要求把js文件放到html代码底部前，现代浏览器某种程度上解决了并行加载的问题，也可以进行预加载，但是执行之后会否对页面造成重排？所以要灵活应用dns-prefetch、preload和defer|async，当然defer和async不是所有浏览器都生效，webkit核心的就没生效。

3. js执行优化:

> 作用域优化，变量层级不要太深或嵌套太多，最好是本级；大家在看各大框架或库的时候，经常可以看到这种写法：
> 循环优化 循环是编程中最常见的结构，优化循环是性能优化过程中很重要的一部分。一个循环的基本优化步骤如下：
减值迭代——大多数循环使用一个从0开始，增加到某个特定值的迭代器。在很多情况下，从最大值开始，在循环中不断减值的迭代器更加有效。 简化终止条件——由于每次循环过程都会计算终止条件，故必须保证它尽可能快，即避免属性查找或其它O(n)的操作。 简化循环体——循环体是执行最多的，故要确保其被最大限度地优化。确保没有某些可以被很容易移出循环的密集计算。 使用后测试循环——最常用的for和while循环都是前测试循环，而如do-while循环可以避免最初终止条件的计算，因些计算更快

4. 数组存储:

>计算机科学中有个经典问题：通过改变数据存储的位置来获得最佳的读写性能，数据存储的位置关系到代码执行过程中数据的检索速度。在JS中这个问题相对简单，因为只有4种方案。

* 作用域:理解作用域概念是JS和核心关键，不仅从性能还得从功能的角度。简单说：生效的范围（域），哪些变量可以被函数访问，this的赋值，上下文（context）的转换。说到作用域就不能绕开作用域链。理解了作用域链和标识符就理解了作用域。
* 作用域链和标识符解析:

### vue的v-show与v-if

### vue的computed与watch的区别

### vue中的data为什么不是对象而是返回方法

### vue的组件通信的方式