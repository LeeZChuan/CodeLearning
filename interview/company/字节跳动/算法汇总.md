算法题：
1. LRU 实现，加了个过期时间，优先剔除过期数据，get 的时候如果过期了就返回 null（加个判断而已，反正满了踢数据直接踢链表头部管他过没过期也不影响）
2. 求一个二叉树的最大宽度（就是找出节点最多的那个层）
3. 事件循环promise async 看代码说输出，顺便问了async/await原理
4. isEqual 函数，递归判断对象或者数组
5. lc原题 662 二叉树最大宽度
算法：
6. 写一个快排
7. 长度 nn 的数组，划分成 mm 个子集，要求每个子集的和相等，求最大的 mm


8. 编写一个算法来判断一个数 n 是不是快乐数。

9. 「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。
https://leetcode.cn/problems/happy-number/solution/

10. 算法题 题目424，给你一个只包含大写英文字母的字符串，有K次修改的机会，每次能修改一个字符串
求能得到的最大重复字串的长度？
例如str="CDFBEBBBB" K=1 输出 6


11. 判断一个图中有没有环
12. 页面置换算法

代码：
手撕lru算法

13. 给出下面的一个list
[
[1, 3, 2],
[2, 5, 1, 7, 8],
[4, 3],
...
]
List 长度为N，里面每一个元素都是一个 List, 长度不固定;
从上述 List 里面的每一个子 List 选出一个可以组成长度为 N 的List, 例如 [1, 2, 4]
求出所有这样的 List

剑指 Offer 24. 反转链表:https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/


25. K 个一组翻转链表:https://leetcode.cn/problems/reverse-nodes-in-k-group/
```ts
// 先实现反转[a, b)的函数，最后返回的节点为[b-1, a]。
// 将链表以k长度反转，起点为a，终点为b前进k次。
// 反转后a节点即为反转后的尾节点，尾节点的next指向下一次反转的头节点，即反转[a, b)函数的结果。

function reverse(a ,b){
    let pre = null, current = a, next = a;
    while(current !== b){
        next = current.next;
        current.next = pre;
        pre = current;
        current = next;
    }
    return pre;
}

function reverseKGroup(head: ListNode | null, k: number): ListNode | null {
    if(head === null) return null;

    let a = head, b = head;
    for(let i = 0;i < k;i++){
        if(b === null) return head;
        b= b.next;
    }

    const newHead = reverse(a, b);

    a.next = reverseKGroup(b, k);

    return newHead;
};
```
26.  分发饼干
剑指 Offer 48. 最长不含重复字符的子字符串
1.   二叉树的右视图

路径求和https://leetcode.cn/problems/path-sum/

// 标题：斜45度打印二维矩阵
// 对于一般的m * n矩阵a
// 第一条45度斜边：a0
// 第二条45度斜边：a0, a1
// ………
// 最后一条45度斜边：am - 1
// 例如：
input = [[ 1, 2, 3, 4, 5],
         [ 6, 7, 8, 9, 10],
         [11, 12, 13, 14, 15]]
// output = 1, 2, 6, 3, 7, 11, 4, 8, 12, 5, 9, 13, 10, 14, 15
let input = [[ 1, 2, 3, 4, 5],
         [ 6, 7, 8, 9, 10],
         [11, 12, 13, 14, 15]]
let printMatrix = (input) => {
    const ans = []
    let rowLen = input[0].length - 1
    let colLen = input.length - 1
    let rowIndex = 0, colIndex = 0
    for (let i = 0; i < rowLen+1; i++) {
        rowIndex = 0
        colIndex = i
        while (colIndex >= 0 && rowIndex <= colLen) {
            ans.push(input[rowIndex][colIndex])
            rowIndex++
            colIndex--
        }
    }
    for (let j = 1; j < colLen+1; j++) {
        rowIndex = j
        colIndex = rowLen
        while (colIndex >= j && rowIndex <= colLen) {
            ans.push(input[rowIndex][colIndex])
            rowIndex++
            colIndex--
        }
    }
    return ans.join(', ')
}
console.log(printMatrix(input));
算法
200.岛屿数量
