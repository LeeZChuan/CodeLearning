一轮电话面试，
## 缓存，


## react16新特性，
## 前端路由服务端配置，
## ES6.promise，
## 异步，
## React优化，
# 受控组件，
* 在随后的用户输入中，能够控制表单中输入元素的组件被称为受控组件，**即每个状态更改都有一个相关联的处理程序**。例如，我们使用下面的 handleChange 函数将输入框的值转换成大写：

* 非受控组件：非受控组件是在内部存储其自身状态的组件，当需要时，可以使用 ref 查询 DOM 并查找其当前值。这有点像传统的 HTML。
在下面的 UserProfile 组件中，我们通过 ref 引用name输入框：
## await async generator 对比，
## redux异步， 
## 数组的方法
1. slice():slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
* end 可选
提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。
2. slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。
如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。
如果 end 被省略，则 slice 会一直提取到原数组末尾。
如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。
3. map():该方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。你不该使用map: A)你不打算使用返回的新数组，或/且 B) 你没有从回调函数中返回值。
4. forEach()：该方法对数组的每个元素执行一次给定的函数。arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
5. concat()：两个或者多个数组的链接
6. splice():**该方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。**，分别是三个函数，第一个start从第几个元素开始，第二个deleteCount是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素，第三个：要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。

7. fliter()，该方法创建一个新数组, 其包含所有回调函数callback函数实现的测试的所有元素。 
8. //map将返回值组装成一个数组
9. //filter返回的也是一个数组，但是返回的数组结构与原数组结构一致，可以说返回的数组是基于原数组的

## for of与for in
for…in 用于遍历所有的可枚举属性，功能类似于 Object.keys()，但是遍历不到 constructor、length 这样的不可枚举属性。

缺点：

数组的键名为数字，但是 for…in 循环是以字符串作为键名"0",“1”,“2”

for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。

for…of for…of 是 ES6 新增的遍历方式，它提供了统一的遍历机制。所有实现了[Symbol.iterator]接口的对象都可以被遍历。for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、Generator 对象，以及字符串

for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()和for ... of

## 问了数据类型
* 基础数据类型：null是object、undefined、number、boolean、string、es6的symbool与bigint (ES10)其他都是他本身
* 复杂数据类型（说里面详细的类型）：function这个类型是funcation、array、object这两个类型都是object
* 
## 说一下typeof判断的值
> 基础数据类型除了null是Object，剩下的都是本身，复杂数据类型除了function是function都是Object，
> 再说一下null为什么是Object:为什么会出现这种情况呢？
> 因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。
> 为了避免这种问题，我们可以通过 Object.prototype.toString.call(xx)进行判断类型
> 例如
> console.log(Object.prototype.toString.call(function(){}));//[object Function]
> console.log(Object.prototype.toString.call([]));//[object Array]
> console.log(Object.prototype.toString.call(new Date));//[object Date]


### 判断一个对象得类型可以使用typeof、instanceof,如果想要准确判断请用object原型链上的tostring.call方法进行判断
* typeof判断类型的缺点是，因为这个判断一个对象是否是想要的对象，是不可能得，因为null 的结果也是 object，数组的结果也是 object，


## typeof NaN是什么

NaN是number

##  判断这个对象是数组的方法

* Array.isArray()如果是true那就是数组, 
* instanceof,instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
* Object.prototype.toString().call()


##  apply, call, bind的的区别

apply第二个参数是数组，call的第二个参数后是数组的解构，bind返回的是一个function，其他两个返回的是对象

##  ES6的新特性

let const , [...arr]解构，`${}`, for in for of, Promise，箭头函数（有补充的下面说）

## Promise除了 .then .catch .all .race 还有什么

么比了，考虑了20秒，说不清楚

## async awit 的优势
当时说的是 await 就是 generator 加上 Promise 的语法糖，没有一大堆的Promise.then的链式调用，简洁明了，面试官问还有么，考虑了10秒左右， 想不到

## ES6中把箭头函数和普通函数进行对比
this(这个着重问了)，没有arguments，匿名函数没有new (不全可以补充)

## css中的grid的属性


二轮视频coding，在线编程，有赞前端必不可少环节，编程题涉及 深克隆相关，代码不仅要实现功能，还要优雅，合理控制时间。

PS：考察原始类型和对象类型在内存不同形式、对象key遍历、字符串和数组互转，toUpperCase(),hasOwnProperty(),递归等，
为了面试而出的一道题，实际工作中意义不大。
const testData = {    a_bbb: 123,    a_g: [1, 2, 3, 4],    a_d: {        s: 2,        s_d: 3    },    a_f: [1, 2, 3, {        a_g: 5    }],    a_d_s: 1}/** * 将一个json数据的所有key从下划线改为驼峰 *  * @param {object | array} value 待处理对象或数组 * @returns {object | array} 处理后的对象或数组 */function mapKeysToCamelCase(data) {//写代码}


# 有赞社招一面

## Q2 说说从输入URL到看到页面发生的全过程，越详细越好。



首先，我们假设输入的url的请求为最简单的Http请求，以GET请求为例，大致分以下几个步骤：

1. 用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。

2. 浏览器根据输入的URL地址解析出主机名。

3. 浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考DNS查找域名的过程。

4. 拿到ip地址后，浏览器再从URL中解析出端口号。

5. 拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是三次握手。传送门：[完整的tcp链接](https://www.cnblogs.com/xsilence/p/6034361.html)。

6. 浏览器向服务器发送一条HTTP请求报文。

7. 服务器向浏览器返回一条HTTP响应报文。

8. 关闭连接（四次挥手） 浏览器解析文档。

如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。

以上步骤简述了浏览器从输入url到最后页面呈现的大致过程，但这并不很具体，比如浏览器请求报文类型是什么，会遇到哪些错误场景、浏览器又是如何解析响应报文等等都没具体描述。

实际上在http请求方式不同、有无代理、有无负载均衡等不同场景下访问服务器的细节流程也会有一些差别，但这并不影响我们对整个访问环节的理解，有兴趣的同学可网上自行详细了解，在此不做详述。

Q3 你刚刚说了三次握手，四次挥手，那你描述一下？

Q4 刚刚Q2中说的CSS和JS的位置会影响页面效率，为什么？

## Q5 现在有一个函数A和函数B，请你实现B继承A

```javascript
// 方法一：
function A1(){}
function B1(){}
B1.prototype = new A1()
// 方法二：
function A2(){}
function B2(){
  A2.call(this)
}
```

Q6 刚刚你在Q5中说的几种继承的方式，分别说说他们的优缺点

Q7 说说CSS中几种垂直水平居中的方式

Q8 Q7中说的flex布局，垂直水平居中必须知道宽度吗？

Q9 描述一下this

## Q10 说一下浏览器的缓存机制

浏览器缓存有强制缓存与协商缓存
1. 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;

2. 协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。

* 缓存中header的参数：

1. 强制缓存

Expires：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。

**Cache-Control：**当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

cache-control除了该字段外，还有下面几个比较常用的设置值：

**-no-cache：**不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。

**-no-store：**直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。

**-public：**可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

**-private：**只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

2. **协商缓存**

Last-Modify/If-Modify-Since：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存

**Etag：**web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

**If-None-Match：**当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定是否命中协商缓存；


> ETag和Last-Modified的作用和用法，他们的区别：

1. Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；

2. 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；

3. 在优先级上，服务器校验优先考虑Etag。

>浏览器缓存过程

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求

3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；；

4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

> 常见问题

用户行为对浏览器缓存的影响

> 解决方案

点击刷新按钮或者按F5

浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match,这就意味着服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200.

用户按Ctrl+F5（强制刷新）

浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是200.

地址栏回车

浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

## Q11 ETag是这个字符串是怎么生成的？



Q12 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？

Q13 你觉得你做过的你觉得最值得炫耀的项目 ？

## 14解释下浮动和它的工作原理？清除浮动的技巧

浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

浮动元素引起的问题和解决办法？

浮动元素引起的问题：

父元素的高度无法被撑开，影响与父元素同级的元素
与浮动元素同级的非浮动元素（内联元素）会跟随其后
若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：
```css
.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}
.clearfix{display: inline-block;} /* for IE/Mac */
```

清除浮动的几种方法：

1，额外标签法，

2，使用after伪类

3，设置`overflow`为`hidden`或者auto

## 15用过媒体查询，针对移动端的布局吗？

16使用CSS 预处理器吗？喜欢那个？

17、CSS3有哪些新特性？

18、经常遇到的CSS的兼容性有哪些？原因，解决方法是什么？

19、介绍一下CSS的盒子模型？

20、对WEB标准以及W3C的理解与认识？

21、XHTML和HTML有什么区别？

22、Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?

23、 行内元素有哪些?块级元素有哪些?CSS的盒模型?

24、CSS引入的方式有哪些? link和@import的区别是?

25、 CSS选择符有哪些?哪些属性可以继承?优先级 算法 如何计算?内联和important哪个优先级高?


# 杭州 有赞 前端 一面 1h 20min

## 1. 栈和堆的理解

1、栈：栈用于维护函数调用的上下文，离开栈函数调用就会无法实现。栈通常在用户空间的最高地址处分配，通常有数兆字节。

2、堆:堆用来容纳应用程序动态分配的内存区域，我们使用malloc 或者new分配内存时，得到的内存来自堆里。堆通常存于栈的下方（低地址方向），堆一般比栈大很多，可以有几十至数百兆字节的容量。

栈是由高地址向低地址增长。

堆是由低地址向高地址增长。

上方例子得知，当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是传值与传址的区别。

因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。



1. 进程和线程

2. JS是单线程还是多线程

单线程

3. TCP和UDP的区别？

4. HTTP状态码？

5. HTTPS 和 HTTP2.0了解吗？HTTPS 如何加密能说一下吗？

6. 事件循环机制

7.  css、less、sass的区别

CSS全称Cascading Style Sheets （层叠样式表）是一门历史悠久的标记性语言，同 HTML 一道，被广泛应用于万维网（World Wide Web）中。HTML 主要负责文档结构的定义，CSS 负责文档表现形式或样式的定义

Less全称Leaner Style Sheets 是一门向后兼容的 CSS 扩展语言，是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。Less 可以运行在 Node 或浏览器端

它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能

1.  call、apply区别

2.  ES6知道吗？Map、weakMap用过吗？

3.  Vue的 源码 看过吗？双向数据绑定用什么？

4.  Vue生命周期说一下

5.  Vue两个子组件通讯有什么方式？

6.  如何优化首屏渲染提高速度，有哪些方法？

7.  CDN知道吗？

8.  为什么选择 前端 ？

9.  平时怎么规划时间？

10. 手写一个节流。

* 一段时间内只做一件事情，实际应用，表单的提交：典型的案例就是鼠标不断点击的触发，规定在n秒多次点击只有一次生效

```javascript
//节流函数实现
function thro(func,waittime){
  let timerOut//判断
  return function(){
    if(!timerOut){
      timerOut=setTime(function(){
        func();
        timerOut=null
      },waittime)
    }
  }
}

function handle(){
  console.log(Math.random())
}

document.getElementById('button').onclick=thro(handle,2000)

```

11. 代码题。

将一天24小时按每半小划分成48段，我们用一个位图表示选中的时间区间，例如`110000000000000000000000000000000000000000000000`，

表示第一个半小时和第二个半小时被选中了，其余时间段都没有被选中，也就是对应00:00~01:00这个时间区间。一个位图中可能有多个不连续的

时间区间被选中，例如`110010000000000000000000000000000000000000000000`，表示00:00-1:00和02:00-02:30这两个时间区间被选中了。

要求：写一个函数timeBitmapToRanges，将上述规则描述的时间位图转换成一个选中时间区间的数组。

示例输入：`"110010000000000000000000000000000000000000000000"`
示例输出：`["00:00~01:00", "02:00~02:30"]`
