- [一轮电话面试，](#一轮电话面试)
  - [缓存，](#缓存)
  - [react16新特性，](#react16新特性)
  - [前端路由服务端配置，](#前端路由服务端配置)
  - [ES6.promise，](#es6promise)
  - [异步，](#异步)
  - [React优化，](#react优化)
- [受控组件，](#受控组件)
  - [await async generator 对比，](#await-async-generator-对比)
  - [redux异步，](#redux异步)
  - [数组的方法](#数组的方法)
  - [for of与for in](#for-of与for-in)
  - [问了数据类型](#问了数据类型)
  - [说一下typeof判断的值](#说一下typeof判断的值)
    - [判断一个对象得类型可以使用typeof、instanceof,如果想要准确判断请用object原型链上的tostring.call方法进行判断](#判断一个对象得类型可以使用typeofinstanceof如果想要准确判断请用object原型链上的tostringcall方法进行判断)
  - [typeof NaN是什么](#typeof-nan是什么)
  - [判断这个对象是数组的方法](#判断这个对象是数组的方法)
  - [apply, call, bind的的区别](#apply-call-bind的的区别)
  - [ES6的新特性](#es6的新特性)
  - [Promise除了 .then .catch .all .race 还有什么](#promise除了-then-catch-all-race-还有什么)
  - [async awit 的优势](#async-awit-的优势)
  - [ES6中把箭头函数和普通函数进行对比](#es6中把箭头函数和普通函数进行对比)
  - [css中的grid的属性](#css中的grid的属性)
- [有赞社招一面](#有赞社招一面)
  - [Q2 说说从输入URL到看到页面发生的全过程，越详细越好。](#q2-说说从输入url到看到页面发生的全过程越详细越好)
  - [Q4 刚刚Q2中说的CSS和JS的位置会影响页面效率，为什么？](#q4-刚刚q2中说的css和js的位置会影响页面效率为什么)
  - [Q5 现在有一个函数A和函数B，请你实现B继承A](#q5-现在有一个函数a和函数b请你实现b继承a)
  - [Q10 说一下浏览器的缓存机制](#q10-说一下浏览器的缓存机制)
  - [Q11 ETag是这个字符串是怎么生成的？](#q11-etag是这个字符串是怎么生成的)
  - [14解释下浮动和它的工作原理？清除浮动的技巧](#14解释下浮动和它的工作原理清除浮动的技巧)
  - [15用过媒体查询，针对移动端的布局吗？](#15用过媒体查询针对移动端的布局吗)
  - [16使用CSS 预处理器吗？喜欢那个？](#16使用css-预处理器吗喜欢那个)
  - [17、CSS3有哪些新特性？](#17css3有哪些新特性)
  - [18、经常遇到的CSS的兼容性有哪些？原因，解决方法是什么？](#18经常遇到的css的兼容性有哪些原因解决方法是什么)
  - [19、介绍一下CSS的盒子模型？](#19介绍一下css的盒子模型)
  - [20、对WEB标准以及W3C的理解与认识？](#20对web标准以及w3c的理解与认识)
  - [21、XHTML和HTML有什么区别？](#21xhtml和html有什么区别)
  - [22、Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?](#22doctype-严格模式与混杂模式-如何触发这两种模式区分它们有何意义)
  - [23、 行内元素有哪些?块级元素有哪些?CSS的盒模型?](#23-行内元素有哪些块级元素有哪些css的盒模型)
  - [24、CSS引入的方式有哪些? link和@import的区别是?](#24css引入的方式有哪些-link和import的区别是)
  - [25、 CSS选择符有哪些?哪些属性可以继承?优先级 算法 如何计算?内联和important哪个优先级高?](#25-css选择符有哪些哪些属性可以继承优先级-算法-如何计算内联和important哪个优先级高)
- [杭州 有赞 前端 一面 1h 20min](#杭州-有赞-前端-一面-1h-20min)
  - [1. 栈和堆的理解](#1-栈和堆的理解)
  - [1. 进程和线程](#1-进程和线程)
  - [2. JS是单线程还是多线程](#2-js是单线程还是多线程)
  - [3. TCP和UDP的区别？](#3-tcp和udp的区别)
  - [4. HTTP状态码？](#4-http状态码)
  - [5. HTTPS 和 HTTP2.0了解吗？HTTPS 如何加密能说一下吗？](#5-https-和-http20了解吗https-如何加密能说一下吗)
  - [6. 事件循环机制](#6-事件循环机制)
  - [7.  css、less、sass的区别](#7--csslesssass的区别)
  - [1.  call、apply区别](#1--callapply区别)
  - [2.  ES6知道吗？Map、weakMap用过吗？](#2--es6知道吗mapweakmap用过吗)
  - [6.  如何优化首屏渲染提高速度，有哪些方法？](#6--如何优化首屏渲染提高速度有哪些方法)
  - [7.  CDN知道吗？](#7--cdn知道吗)
  - [8.  为什么选择 前端 ？](#8--为什么选择-前端-)
  - [9.  平时怎么规划时间？](#9--平时怎么规划时间)
  - [10. 手写一个节流。](#10-手写一个节流)
  - [11. 代码题。](#11-代码题)
- [重点关注的模拟](#重点关注的模拟)
  - [有了解echarts本身吗？](#有了解echarts本身吗)
  - [不用echarts类的工具，怎么绘制图表？](#不用echarts类的工具怎么绘制图表)
  - [svg了解吗](#svg了解吗)
  - [object.defineProperty本身有什么限制？](#objectdefineproperty本身有什么限制)
  - [object.breeze()内部是怎么实现的？](#objectbreeze内部是怎么实现的)
  - [es6了解吗](#es6了解吗)
  - [let和const和var的区别](#let和const和var的区别)
  - [什么是块级作用域](#什么是块级作用域)
  - [除了函数还有哪些块级作用域](#除了函数还有哪些块级作用域)
  - [哪些方法判断值的类型](#哪些方法判断值的类型)
  - [instanceof的底层实现机制](#instanceof的底层实现机制)
  - [css有哪些方法？](#css有哪些方法)
  - [怎么实现垂直水平居中](#怎么实现垂直水平居中)
  - [position的值](#position的值)
  - [绝对定位怎么实现水平居中](#绝对定位怎么实现水平居中)
  - [流式布局知道哪些](#流式布局知道哪些)
  - [为什么用let定义变量](#为什么用let定义变量)
  - [js本身的 排序 api](#js本身的-排序-api)
  - [说一下filter、map、forEach、every、some](#说一下filtermapforeacheverysome)
  - [手写深度拷贝，并且把对象的属性改成驼峰类型](#手写深度拷贝并且把对象的属性改成驼峰类型)
  - [get和post有什么区别？](#get和post有什么区别)
  - [tcp三次握手说一下](#tcp三次握手说一下)
  - [http2.0有了解吗](#http20有了解吗)


# 一轮电话面试，
## 缓存，
## react16新特性，
## 前端路由服务端配置，
## ES6.promise，
## 异步，
## React优化，
# 受控组件，
* 在随后的用户输入中，能够控制表单中输入元素的组件被称为受控组件，**即每个状态更改都有一个相关联的处理程序**。例如，我们使用下面的 handleChange 函数将输入框的值转换成大写：

* 非受控组件：非受控组件是在内部存储其自身状态的组件，当需要时，可以使用 ref 查询 DOM 并查找其当前值。这有点像传统的 HTML。
在下面的 UserProfile 组件中，我们通过 ref 引用name输入框：
## await async generator 对比，
## redux异步， 

## 数组的方法
1. slice():slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
* end 可选
提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。
2. slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。
如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。
如果 end 被省略，则 slice 会一直提取到原数组末尾。
如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。
3. map():该方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。你不该使用map: A)你不打算使用返回的新数组，或/且 B) 你没有从回调函数中返回值。
4. forEach()：该方法对数组的每个元素执行一次给定的函数。arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
5. concat()：两个或者多个数组的链接
6. splice():**该方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。**，分别是三个函数，第一个start从第几个元素开始，第二个deleteCount是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素，第三个：要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。

7. fliter()，该方法创建一个新数组, 其包含所有回调函数callback函数实现的测试的所有元素。 
8. //map将返回值组装成一个数组
9. //filter返回的也是一个数组，但是返回的数组结构与原数组结构一致，可以说返回的数组是基于原数组的

## for of与for in
for…in 用于遍历所有的可枚举属性，功能类似于 Object.keys()，但是遍历不到 constructor、length 这样的不可枚举属性。

缺点：

数组的键名为数字，但是 for…in 循环是以字符串作为键名"0",“1”,“2”

for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。

for…of for…of 是 ES6 新增的遍历方式，它提供了统一的遍历机制。所有实现了[Symbol.iterator]接口的对象都可以被遍历。for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、Generator 对象，以及字符串

for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()和for ... of

## 问了数据类型
* 基础数据类型：null是object、undefined、number、boolean、string、es6的symbool与bigint (ES10)其他都是他本身
* 复杂数据类型（说里面详细的类型）：function这个类型是funcation、array、object这两个类型都是object
* 
## 说一下typeof判断的值
> 基础数据类型除了null是Object，剩下的都是本身，复杂数据类型除了function是function都是Object，
> 再说一下null为什么是Object:为什么会出现这种情况呢？
> 因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。
> 为了避免这种问题，我们可以通过 Object.prototype.toString.call(xx)进行判断类型
> 例如
> console.log(Object.prototype.toString.call(function(){}));//[object Function]
> console.log(Object.prototype.toString.call([]));//[object Array]
> console.log(Object.prototype.toString.call(new Date));//[object Date]


### 判断一个对象得类型可以使用typeof、instanceof,如果想要准确判断请用object原型链上的tostring.call方法进行判断
* typeof判断类型的缺点是，因为这个判断一个对象是否是想要的对象，是不可能得，因为null 的结果也是 object，数组的结果也是 object，


## typeof NaN是什么

NaN是number

##  判断这个对象是数组的方法

* Array.isArray()如果是true那就是数组, 
* instanceof,instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
* Object.prototype.toString().call()


##  apply, call, bind的的区别

apply第二个参数是数组，call的第二个参数后是数组的解构，bind返回的是一个function，其他两个返回的是对象

##  ES6的新特性

let const , [...arr]解构，`${}`, for in for of, Promise，箭头函数（有补充的下面说）

## Promise除了 .then .catch .all .race 还有什么

么比了，考虑了20秒，说不清楚

## async awit 的优势
当时说的是 await 就是 generator 加上 Promise 的语法糖，没有一大堆的Promise.then的链式调用，简洁明了，面试官问还有么，考虑了10秒左右， 想不到

## ES6中把箭头函数和普通函数进行对比
this(这个着重问了)，没有arguments，匿名函数没有new (不全可以补充)

## css中的grid的属性


二轮视频coding，在线编程，有赞前端必不可少环节，编程题涉及 深克隆相关，代码不仅要实现功能，还要优雅，合理控制时间。

PS：考察原始类型和对象类型在内存不同形式、对象key遍历、字符串和数组互转，toUpperCase(),hasOwnProperty(),递归等，
为了面试而出的一道题，实际工作中意义不大。
const testData = {    a_bbb: 123,    a_g: [1, 2, 3, 4],    a_d: {        s: 2,        s_d: 3    },    a_f: [1, 2, 3, {        a_g: 5    }],    a_d_s: 1}/** * 将一个json数据的所有key从下划线改为驼峰 *  * @param {object | array} value 待处理对象或数组 * @returns {object | array} 处理后的对象或数组 */function mapKeysToCamelCase(data) {//写代码}


# 有赞社招一面

## Q2 说说从输入URL到看到页面发生的全过程，越详细越好。


首先，我们假设输入的url的请求为最简单的Http请求，以GET请求为例，大致分以下几个步骤：

1. 用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。

2. 浏览器根据输入的URL地址解析出主机名。

3. 浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考DNS查找域名的过程。

4. 拿到ip地址后，浏览器再从URL中解析出端口号。

5. 拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是三次握手。传送门：[完整的tcp链接](https://www.cnblogs.com/xsilence/p/6034361.html)。

6. 浏览器向服务器发送一条HTTP请求报文。

7. 服务器向浏览器返回一条HTTP响应报文。

8. 关闭连接（四次挥手） 浏览器解析文档。

如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。

以上步骤简述了浏览器从输入url到最后页面呈现的大致过程，但这并不很具体，比如浏览器请求报文类型是什么，会遇到哪些错误场景、浏览器又是如何解析响应报文等等都没具体描述。


Q3 你刚刚说了三次握手，四次挥手，那你描述一下？

## Q4 刚刚Q2中说的CSS和JS的位置会影响页面效率，为什么？

   如果js放在html页面的前端在渲染的时候，会因为处理流程造成渲染阻塞，导致放在后面的css无法将html页面进行渲染，也就会造成白屏

>解决方案

根本原因是客户端渲染的无力，因此最简单的方法是在服务器端，使用模板引擎渲染所有页面。同时

1减少文件加载体积，如html压缩，js压缩

2加快js执行速度 比如常见的无限滚动的页面，可以使用js先渲染一个屏幕范围内的东西

3提供一些友好的交互，比如提供一些假的滚动条

4使用本地存储处理静态文件。


## Q5 现在有一个函数A和函数B，请你实现B继承A


1. 原型继承

```javascript
function Parent () {
  this.name = 'Parent'
  this.sex = 'boy'
}
function Child () {
  this.name = 'child'
}
// 将子类的原型对象指向父类的实例
Child.prototype = new Parent()
//优：继承了父类的模板，又继承了父类的原型对象
//缺：1.无法实现多继承(因为已经指定了原型对象了)
//   2.创建子类时，无法向父类构造函数传参数
```
2. 构造函数继承
```javascript
function Parent (name) {
  this.name = name
}
function Child () {
  //用.call 来改变 Parent 构造函数内的指向
  Parent.call(this, 'child')
}
//优：解决了原型链继承中子类实例共享父类引用对象的问题，实现多继承，创建子类实例时，可以向父类传递参数
//缺：构造继承只能继承父类的实例属性和方法，不能继承父类原型的属性和方法
```
3. 组合继承

组合继承就是将原型链继承与构造函数继承组合在一起。

使用原型链继承来保证子类能继承到父类原型中的属性和方法
使用构造继承来保证子类能继承到父类的实例属性和方法

4. 寄生组合继承
5. 6.ES6提到的class继承：使用extends与super


Q6 刚刚你在Q5中说的几种继承的方式，分别说说他们的优缺点

Q7 说说CSS中几种垂直水平居中的方式

Q8 Q7中说的flex布局，垂直水平居中必须知道宽度吗？

Q9 描述一下this

## Q10 说一下浏览器的缓存机制

浏览器缓存有强制缓存与协商缓存
1. 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;

2. 协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。

* 缓存中header的参数：

1. 强制缓存

Expires：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。

**Cache-Control：**当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

cache-control除了该字段外，还有下面几个比较常用的设置值：

**-no-cache：**不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。

**-no-store：**直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。

**-public：**可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

**-private：**只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

2. **协商缓存**

Last-Modify/If-Modify-Since：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存

**Etag：**web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

**If-None-Match：**当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定是否命中协商缓存；


> ETag和Last-Modified的作用和用法，他们的区别：

1. Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；

2. 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；

3. 在优先级上，服务器校验优先考虑Etag。

>浏览器缓存过程

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求

3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；；

4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

> 常见问题

用户行为对浏览器缓存的影响

> 解决方案

点击刷新按钮或者按F5

浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match,这就意味着服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200.

用户按Ctrl+F5（强制刷新）

浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是200.

地址栏回车

浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

## Q11 ETag是这个字符串是怎么生成的？



Q12 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？

Q13 你觉得你做过的你觉得最值得炫耀的项目 ？

## 14解释下浮动和它的工作原理？清除浮动的技巧

浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

浮动元素引起的问题和解决办法？

浮动元素引起的问题：

父元素的高度无法被撑开，影响与父元素同级的元素
与浮动元素同级的非浮动元素（内联元素）会跟随其后
若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：
```css
.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}
.clearfix{display: inline-block;} /* for IE/Mac */
```

清除浮动的几种方法：

1，额外标签法，

2，使用after伪类

3，设置`overflow`为`hidden`或者auto

## 15用过媒体查询，针对移动端的布局吗？

## 16使用CSS 预处理器吗？喜欢那个？

## 17、CSS3有哪些新特性？

## 18、经常遇到的CSS的兼容性有哪些？原因，解决方法是什么？

## 19、介绍一下CSS的盒子模型？

## 20、对WEB标准以及W3C的理解与认识？

## 21、XHTML和HTML有什么区别？

## 22、Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?

## 23、 行内元素有哪些?块级元素有哪些?CSS的盒模型?

## 24、CSS引入的方式有哪些? link和@import的区别是?

## 25、 CSS选择符有哪些?哪些属性可以继承?优先级 算法 如何计算?内联和important哪个优先级高?


# 杭州 有赞 前端 一面 1h 20min

## 1. 栈和堆的理解

1、栈：栈用于维护函数调用的上下文，离开栈函数调用就会无法实现。栈通常在用户空间的最高地址处分配，通常有数兆字节。

2、堆:堆用来容纳应用程序动态分配的内存区域，我们使用malloc 或者new分配内存时，得到的内存来自堆里。堆通常存于栈的下方（低地址方向），堆一般比栈大很多，可以有几十至数百兆字节的容量。

栈是由高地址向低地址增长。

堆是由低地址向高地址增长。

上方例子得知，当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是传值与传址的区别。

因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。



## 1. 进程和线程

进程是资源分配的最小单位，线程是CPU调度的最小单位，这种解释太过抽象

进程只能有一个，但是线程可以有多个；

做个简单的比喻：
1. 进程=火车，线程=车厢线程在进程下行进（单纯的车厢无法运行）
2. 一个进程可以包含多个线程（一辆火车可以有多个车厢）
3. 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
4. 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
5. 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
6. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
7. 进程可以拓展到多机，进程最适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
8. 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）
－"互斥锁"进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”


## 2. JS是单线程还是多线程

单线程

## 3. TCP和UDP的区别？

1. （基于连接vs无连接）tcp是面向连接的（三次握手；四次挥手）；udp不是面向连接的
2. （重量级vs轻量级）tcp是一个重量级的协议；udp则是轻量级的协议。一个tcp数据报的报头大小最少20字节，udp数据报的包头固定8个字节
3. （可靠性）tcp交付保证：如果消息在传输中丢失，那么它将重发；udp没有交付保证，一个数据包在运输过程中可能丢失。
4. （有序性）消息到达网络的另一端可能是无序的，tcp协议将为你拍好序。Udp不提供任何有序性的保证。
5. （速度）tcp慢，适合传输大量数据；udp快，适合传输少量数据。
6. （流量控制和拥塞控制）TCP有流量控制和拥塞控制，udp没有。
7.  tcp面向字节流，udp面向报文
8.  tcp只能单播，不能发送广播和组播；udp可以广播和组播。
9.  Tcp应用：邮件传输 udp应用：qq聊天、qq视频

## 4. HTTP状态码？

* 1**	信息，服务器收到请求，需要请求者继续执行操作
* 2**	成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误

* 常见的
* 200	OK	请求成功。一般用于GET与POST请求
* 301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
* 302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
* 401	Unauthorized	请求要求用户的身份认证
* 500	Internal Server Error	服务器内部错误，无法完成请求
## 5. HTTPS 和 HTTP2.0了解吗？HTTPS 如何加密能说一下吗？

* HTTP特定就是明文传输，因此传输过程中会出现信息被盗取的情况，然而为了解决这个HTTP明文传输过程的信息丢失，为了防范这样一类攻击，，提出了新的方案即 HTTPS。

* HTTPS：其原理是在HTTP和TCP之间建立了一个中间层，当HTTP和TCP通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给TCP, 响应的，TCP必须将数据包解密，才能传给上面的HTTP。这个中间层也叫安全层。安全层的核心就是对数据加解密。

* HTTP加密是使用：对称加密和非对称加密

* 对称加密是最简单的方式，指的是加密和解密用的是同样的密钥。

* 1. 对称加密：首先，浏览器会发送给服务器发送一个随机数和加密方法列表，然后服务器回发一个随机数和加密方法列表
* 接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号
* 2. 非对称加密：服务器手里有两把钥匙，一把是公钥，也就是说每个人都能拿到，是公开的，另一把是私钥，这把私钥只有服务器自己知道。
* 现在两者拥有相同的client_random、server_random和加密方法。然后浏览器用公钥将client_random和server_random加密，生成与服务器通信的暗号。
这时候由于是非对称加密，公钥加密过的数据只能用私钥解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。
* 3. 对称加密和非对称加密的结合：

1. 浏览器向服务器发送client_random和加密方法列表。
2. 服务器接收到，返回server_random、加密方法以及公钥。
3. 浏览器接收，接着生成另一个随机数pre_random, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)
4. 服务器用私钥解密这个被加密后的pre_random。

现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。
然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。
这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而拿不到pre_random，也就无法生成最终的密钥了。



## 6. 事件循环机制

js 是单线程的语言，在代码执行时，通过将不同函数的执行下文压入执行栈中来保证代码的有序执行，在执行同步代码的时候遇到到了异步代码，js 引擎并不会一致等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务，当异步任务执行完毕后再将异步事件回调加入到与当前执行栈不同的另一个任务队列等待执行

任务队列可分为宏任务和微任务，当前执行栈中的函数之心完毕后会先判断为任务队列中是否有任务可以执行，如果有就将微任务队列的任务依次压入执行性栈中，当微任务执行完毕后再去判断宏任务中的队列，同时开启新的一轮事件循环

浏览器中事件循环是依靠浏览器完成的异步操作

nodejs 中底层使用 libuv 库实现多线程

以前版本的 nodejs 和浏览器的事件循环还是很不一样的，浏览器中的微任务会在每个相应宏任务中执行，而 nodejs 中微任务是在每个阶段之间执行的，当 nodejs 版本大于 11 后，nodejs 和浏览器表现一致

## 7.  css、less、sass的区别

CSS全称Cascading Style Sheets （层叠样式表）是一门历史悠久的标记性语言，同 HTML 一道，被广泛应用于万维网（World Wide Web）中。HTML 主要负责文档结构的定义，CSS 负责文档表现形式或样式的定义

Less全称Leaner Style Sheets 是一门向后兼容的 CSS 扩展语言，是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。Less 可以运行在 Node 或浏览器端

它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能

## 1.  call、apply区别

## 2.  ES6知道吗？Map、weakMap用过吗？

3.  Vue的 源码 看过吗？双向数据绑定用什么？

4.  Vue生命周期说一下

5.  Vue两个子组件通讯有什么方式？

## 6.  如何优化首屏渲染提高速度，有哪些方法？



## 7.  CDN知道吗？

## 8.  为什么选择 前端 ？

因为自己比较喜欢计算机视觉方向的东西，使用视觉展示数据背后的逻辑

## 9.  平时怎么规划时间？

## 10. 手写一个节流。

* 一段时间内只做一件事情，实际应用，表单的提交：典型的案例就是鼠标不断点击的触发，规定在n秒多次点击只有一次生效

```javascript
//节流函数实现
function thro(func,waittime){
  let timerOut//判断
  return function(){
    if(!timerOut){
      timerOut=setTimeout(function(){
        func();
        timerOut=null
      },waittime)
    }
  }
}

function handle(){
  console.log(Math.random())
}

document.getElementById('button').onclick=thro(handle,2000)

```

## 11. 代码题。

将一天24小时按每半小划分成48段，我们用一个位图表示选中的时间区间，例如`110000000000000000000000000000000000000000000000`，

表示第一个半小时和第二个半小时被选中了，其余时间段都没有被选中，也就是对应00:00~01:00这个时间区间。一个位图中可能有多个不连续的

时间区间被选中，例如`110010000000000000000000000000000000000000000000`，表示00:00-1:00和02:00-02:30这两个时间区间被选中了。

要求：写一个函数timeBitmapToRanges，将上述规则描述的时间位图转换成一个选中时间区间的数组。

示例输入：`"110010000000000000000000000000000000000000000000"`
示例输出：`["00:00~01:00", "02:00~02:30"]`

# 重点关注的模拟


## 有了解echarts本身吗？

## 不用echarts类的工具，怎么绘制图表？

## svg了解吗



## object.defineProperty本身有什么限制？

当一个对象已存在某属性，重新定义该属性（如果允许）时，若未指定属性描述器的enumerable或configurable，则其默认值为原有属性描述器的对应的enumerable或configurable值。

## object.breeze()内部是怎么实现的？

## es6了解吗

* es6更新了let、const；箭头函数，promise，扩展运算符（...），解构赋值，模板字符串和标签函数，symbol，for of（遍历对象的值）它结合了foreach的简洁与中断循环的能力，class类

## let和const和var的区别

## 什么是块级作用域

在es5中，函数只能在顶层作用域或者函数作用域声明，不能再块级作用域声明，但是浏览器并没有遵守这个规则，为了兼容还是支持在块级作用域之中声明函数，不会报错。

es6引入了块级作用域，明确允许在块级作用域之中声明函数，es6规定，在函数声明语句的行为类似let在块级作用域之外不可引用

```javascript
var flag
var demo
demo()//报错
flag=true
if(flag){
  function demo(){
    console.log('aaa')
  }else{
    function demo(){
      console.log('bbb');
    }
  }
}
```

## 除了函数还有哪些块级作用域

一次for循环有几个块

class内部是怎么实现的？

js基本数据类型

js引用类型

原型链了解吗？

可以用原型链实现class吗

## 哪些方法判断值的类型

1. typeof 
2. instanceof
3. constructor：当一个函数F被定义时，JS引擎会为F添加prototype原型，然后在prototype上添加一个constructor属性，并让其指向F的引用，F利用原型对象的constructor属性引用了自身，当F作为构造函数创建对象时，原型上的constructor属性被遗传到了新创建的对象上，从原型链角度讲，构造函数F就是新对象的类型。这样做的意义是，让对象诞生以后，就具有可追溯的数据类型。
4. Object.prototype.toString()

typeof和instanceof有什么区别

* 最重要的区别就是typeof在对对象、数组、null返回的值都是object

* 在javascript中，判断一个变量的类型可以用typeof

　　(1) 数字类型、typeof返回的值是number。比如说：typeof(1)，返回值是number

　　(2) 字符串类型，typeof返回的值是string。比如typeof(“123”返回值时string)

　　(3) 布尔类型，typeof返回的值是boolean。比如typeof(true)返回值时boolean

　　(4) 对象、数组、null返回的值是object。比如typeof(window)，typeof(document)，typeof(null)返回的值都是object

　　(5) 函数类型，返回的值是function。比如：typeof(eval)，typeof(Date)返回的值都是function。

　　(6) 不存在的变量、函数或者undefined，将返回undefined。比如：typeof(abc)、typeof(undefined)都返回undefined

* 而ECMAScript引入了另一个Java运算符instanceof来解决这个问题。Instanceof运算符与typeof运算符相似，用于识别正在处理的对象的类型。与typeof方法不同的是，instanceof方法要求开发者明确地确认对象为某特定类型

## instanceof的底层实现机制

* ①用于判断某个实例是否属于某构造函数

* ②在继承关系中用来判断一个实例是否属于它的父类型或者祖先类型的实例

说白了，只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false
```javascript
function instance_of(L, R) {     // L 表示instanceof左边，R 表示instanceof右边
    let O = R.prototype;         // 取 R 的显示原型
    L = L.__proto__;             // 取 L 的隐式原型
    while (true) {               // 循环执行，直到 O 严格等于 L
         if (L === null) return false;
         if (O === L) return true;
         L = L.__proto__;        // 获取祖类型的__proto__
    }
}
```

## css有哪些方法？

## 怎么实现垂直水平居中

1. 利用绝对定位，（1设置四个方向值都为0，将margin设置为auto，）（2.利用top与left设置为50%，然后再用margin负值来调整中心点）
2. 如果是宽度高度不定，可以利用（1.绝对定位，然后top与left都为50%，translate设置为-50%）（或者使用flex布局，通过align-items与justify-content都设置为center）

## position的值
1. absolute 绝对定位，相对于static定位以外的第一个父元素进行定位
2. relative 相对定位
3. flex弹性布局
4. fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。
5. static：没有定位，元素正常出现在流中

## 绝对定位怎么实现水平居中

1. 四个方向值都为0，然后margin：0 auto
2. CSS3的兴起，使得有了更好的解决方法，就是使用transform代替margin. transform中translate偏移的百分比值是相对于自身大小的，

## 流式布局知道哪些

flex用过哪些属性

flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex
容器，它的所有子元素都会成为它的项目。

一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。
我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还
可以使用flex-wrap来规定当一行排列不下时的换行方式。

对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，
项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。

flex实现三列布局，左右定宽，中间自适应

* 首先我想到的是float——浮动布局
> 使用浮动，先渲染左右两个元素，分别让他们左右浮动，然后再渲染中间元素，设置它的margin左右边距分别为左右两个元素的宽度。


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <div style="width:300px; float:left; background:#6FF">左侧的内容 固定宽度</div>
    <div style="width:200px; float:right; background-color:#960">右侧的内容 固定宽度</div>
    <div style="margin-left:300px;margin-right:200px; background-color:#9F3;">中间内容，自适应宽度</div>
</body>
</html>
```

* 其次我想到了position——定位
> 使用定位方式，不需要先渲染中间元素，只要把左右两个元素分别使用定位，left:0;right:0;中间元素设置margin左右边距为左右两个元素的宽度即可。
css的选择器和对应的优先级

* 第三、使用双飞翼布局

> 使用双飞翼布局与其他方式不同，它最先渲染的是中间元素，然后才渲染两边元素（注意，这一点与float布局方式正好相反哟），先将三个元素都设置为向左浮动，然后使用负边距将左右两个元素覆盖到中间元素的左右两边，形成羽翼。

* 第四，CSS3的flex布局方法
> 该方式的思想是设置一个弹性容器包裹三个元素，并将这个容器设置为水平排列（flex-flow:row）,左右两边元素设置固定宽度，中间元素设置为flex:1;



css前后设置了两个样式，应用哪些？

css的一个动画效果是

响应式具体是怎么实现的呢

字体大小自适应怎么做

rem和em的区别

有接触 算法 和数据结构吗？你觉得最有意思的 算法 有哪些？具体是怎么实现的？

排序 算法 有哪些？说一下归并 算法

手撕归并 算法 ？？？后面让我任写一个 排序 算法

## 为什么用let定义变量

新语法的出现，不仅使得我们更容易的理解JS，而且减少很多奇奇怪怪的问题出现。块级声明，可以很有效的避免了变量污染这个问题。

## js本身的 排序 api

* Arrays.sort并不是单一的排序，而是插入排序，快速排序，归并排序三种排序的组合，为此我画了个流程图：

[https://www.iteye.com/topic/1138374](https://www.iteye.com/topic/1138374)

数组本身有哪些api

## 说一下filter、map、forEach、every、some

>filter:它创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，在初始化数组中大于5的数组

> map：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值

> foreach:forEach()：该方法对数组的每个元素执行一次给定的函数。arr.forEach(callback(currentValue [, index [, array]])[, thisArg])

>every：判断数组中都满足条件才返回真，复奏为假

> some:只要有真便返回为真
## 手写深度拷贝，并且把对象的属性改成驼峰类型
```javascript
// 实现对象深拷贝 & key下划线转驼峰 
( a_bbb => aBbb、a_d_s => aDS ) 
const testData = {     
  a_bbb: 123,     
  a_g: [1, 2, 3, 4],    
  a_d: {         
    s: 2,         
    s_d: 3     },     
    a_f: [1, 2, 3, 
    {         
      a_g: 5     }],     
    a_d_s: 1 
}  

```
js新增了其他的数据类型吗


说一下csrf

## get和post有什么区别？

最直观的是语义上的区别，往细了说： 
1. 从缓存角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 post 请求不会 从编码角度，get 请求只能进行 URL 编码，只能收到 ASCII 字符，而 POST 没有限制。 
2. 从参数角度，get 请求一般会放到 URL 中，因此不安全，post 请求放在请求体中，更适合传输敏感信息 从幂等性角度，get 是幂等性的，而 post 不是（幂等性是指执行相同的操作，结果也是相同的） 
3. 从 TCP 的角度，get 请求会吧请求报文一次性的发出去，而 Post 会分为两个 TCP 数据包，首先发送 header 部分，如果服务器响应 100，然后发 boy（火狐浏览器除外，她的 post 请求只发一个 TCP 包）

## tcp三次握手说一下

1. 第一次握手是让服务端知道客户端具有发送能力，
2. 第二次握手是让客户端知道服务端具有接受和发送的能力，但此时服务端并不知道客户端是否收到了自己发送的消息，
3. 所以第三次握手起到了这个作用，经过了三次握手后服务端和客户端都确认了双方的接收和发送能力 

http基于什么实现的

## http2.0有了解吗

> http2特点
1. 多路复用：相同域名多个请求，共享同一个TCP连接，降低了延迟

2. 请求优先级：给每个request设置优先级

3. 二进制传输；之前是用纯文本传输

4. 数据流：数据包不是按顺序发送，对数据包做标记。每个请求或回应的所有数据包成为一个数据流，

5. 服务端推送：可以主动向客户端发送消息。

6. 头部压缩：减少包的大小跟数量

7. HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了 HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！http1 keep alive 串行传输

https了解吗

https握手过程

http缓存说一下

强制缓存怎么设置

http头部字段有哪些

有什么想问我的？
