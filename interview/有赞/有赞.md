一轮电话面试，
## 缓存，


react16新特性，
前端路由服务端配置，
## ES6.promise，
## 异步，
## React优化，
# 受控组件，
* 在随后的用户输入中，能够控制表单中输入元素的组件被称为受控组件，**即每个状态更改都有一个相关联的处理程序**。例如，我们使用下面的 handleChange 函数将输入框的值转换成大写：

* 非受控组件：非受控组件是在内部存储其自身状态的组件，当需要时，可以使用 ref 查询 DOM 并查找其当前值。这有点像传统的 HTML。
在下面的 UserProfile 组件中，我们通过 ref 引用name输入框：
## await async generator 对比，
## redux异步， 
## 数组的方法
1. slice():slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
* end 可选
提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。
2. slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。
如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。
如果 end 被省略，则 slice 会一直提取到原数组末尾。
如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。
3. map():该方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。你不该使用map: A)你不打算使用返回的新数组，或/且 B) 你没有从回调函数中返回值。
4. forEach()：该方法对数组的每个元素执行一次给定的函数。arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
5. concat()：两个或者多个数组的链接
6. splice():**该方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。**，分别是三个函数，第一个start从第几个元素开始，第二个deleteCount是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素，第三个：要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。

7. fliter()，该方法创建一个新数组, 其包含所有回调函数callback函数实现的测试的所有元素。 
8. //map将返回值组装成一个数组
9. //filter返回的也是一个数组，但是返回的数组结构与原数组结构一致，可以说返回的数组是基于原数组的
## for of与for in
for…in 用于遍历所有的可枚举属性，功能类似于 Object.keys()，但是遍历不到 constructor、length 这样的不可枚举属性。

缺点：

数组的键名为数字，但是 for…in 循环是以字符串作为键名"0",“1”,“2”

for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。

for…of for…of 是 ES6 新增的遍历方式，它提供了统一的遍历机制。所有实现了[Symbol.iterator]接口的对象都可以被遍历。for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、Generator 对象，以及字符串

for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()和for ... of

## 问了数据类型
* 基础数据类型：null是object、undefined、number、boolean、string、es6的symbool与bigint (ES10)其他都是他本身
* 复杂数据类型（说里面详细的类型）：function这个类型是funcation、array、object这两个类型都是object
* 
## 说一下typeof判断的值
> 基础数据类型除了null是Object，剩下的都是本身，复杂数据类型除了function是function都是Object，
> 再说一下null为什么是Object:为什么会出现这种情况呢？
> 因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。
> 为了避免这种问题，我们可以通过 Object.prototype.toString.call(xx)进行判断类型
> 例如
> console.log(Object.prototype.toString.call(function(){}));//[object Function]
> console.log(Object.prototype.toString.call([]));//[object Array]
> console.log(Object.prototype.toString.call(new Date));//[object Date]
### 判断一个对象得类型可以使用typeof、instanceof
* typeof判断类型的缺点是，因为这个判断一个对象是否是想要的对象，是不可能得，因为null 的结果也是 object，数组的结果也是 object，
1. typeof NaN是什么


NaN是number

1.  判断这个对象是数组的方法
Array.isArray(), instanceof, Object.prototype.toString().call()
11.  apply, call, bind的的区别
apply第二个参数是数组，call的第二个参数后是数组的解构，bind返回的是一个function，其他两个返回的是对象
12. ES6的新特性
let const , [...arr]解构，`${}`, for in for of, Promise，箭头函数（有补充的下面说）
13. Promise除了 .then .catch .all .race 还有什么
么比了，考虑了20秒，说不清楚
14. async awit 的优势
当时说的是 await 就是 generator 加上 Promise 的语法糖，没有一大堆的Promise.then的链式调用，简洁明了，面试官问还有么，考虑了10秒左右， 想不到
15. ES6中把箭头函数和普通函数进行对比
this(这个着重问了)，没有arguments，匿名函数没有new (不全可以补充)
16. css中的grid的属性




二轮视频coding，在线编程，有赞前端必不可少环节，编程题涉及 深克隆相关，代码不仅要实现功能，还要优雅，合理控制时间。

PS：考察原始类型和对象类型在内存不同形式、对象key遍历、字符串和数组互转，toUpperCase(),hasOwnProperty(),递归等，
为了面试而出的一道题，实际工作中意义不大。
const testData = {    a_bbb: 123,    a_g: [1, 2, 3, 4],    a_d: {        s: 2,        s_d: 3    },    a_f: [1, 2, 3, {        a_g: 5    }],    a_d_s: 1}/** * 将一个json数据的所有key从下划线改为驼峰 *  * @param {object | array} value 待处理对象或数组 * @returns {object | array} 处理后的对象或数组 */function mapKeysToCamelCase(data) {//写代码}