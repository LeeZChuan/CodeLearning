- [一轮电话面试，](#一轮电话面试)
  - [缓存，](#缓存)
  - [react16新特性，](#react16新特性)
  - [前端路由服务端配置，](#前端路由服务端配置)
  - [ES6.promise，](#es6promise)
  - [异步，](#异步)
  - [React优化，](#react优化)
- [受控组件，](#受控组件)
  - [await async generator 对比，](#await-async-generator-对比)
  - [redux异步，](#redux异步)
  - [数组的方法](#数组的方法)
  - [for of与for in](#for-of与for-in)
  - [问了数据类型](#问了数据类型)
  - [说一下typeof判断的值](#说一下typeof判断的值)
    - [判断一个对象得类型可以使用typeof、instanceof,如果想要准确判断请用object原型链上的tostring.call方法进行判断](#判断一个对象得类型可以使用typeofinstanceof如果想要准确判断请用object原型链上的tostringcall方法进行判断)
  - [typeof NaN是什么](#typeof-nan是什么)
  - [判断这个对象是数组的方法](#判断这个对象是数组的方法)
  - [apply, call, bind的的区别](#apply-call-bind的的区别)
  - [ES6的新特性](#es6的新特性)
  - [Promise除了 .then .catch .all .race 还有什么](#promise除了-then-catch-all-race-还有什么)
  - [async awit 的优势](#async-awit-的优势)
  - [ES6中把箭头函数和普通函数进行对比](#es6中把箭头函数和普通函数进行对比)
  - [css中的grid的属性](#css中的grid的属性)
- [有赞社招一面](#有赞社招一面)
  - [Q2 说说从输入URL到看到页面发生的全过程，越详细越好。](#q2-说说从输入url到看到页面发生的全过程越详细越好)
  - [Q3 你刚刚说了三次握手，四次挥手，那你描述一下？](#q3-你刚刚说了三次握手四次挥手那你描述一下)
  - [Q4 刚刚Q2中说的CSS和JS的位置会影响页面效率，为什么？](#q4-刚刚q2中说的css和js的位置会影响页面效率为什么)
  - [Q5 现在有一个函数A和函数B，请你实现B继承A](#q5-现在有一个函数a和函数b请你实现b继承a)
  - [Q6 刚刚你在Q5中说的几种继承的方式，分别说说他们的优缺点](#q6-刚刚你在q5中说的几种继承的方式分别说说他们的优缺点)
  - [Q7 说说CSS中几种垂直水平居中的方式](#q7-说说css中几种垂直水平居中的方式)
  - [Q8 Q7中说的flex布局，垂直水平居中必须知道宽度吗？](#q8-q7中说的flex布局垂直水平居中必须知道宽度吗)
  - [Q10 说一下浏览器的缓存机制](#q10-说一下浏览器的缓存机制)
  - [Q11 ETag是这个字符串是怎么生成的？](#q11-etag是这个字符串是怎么生成的)
  - [14解释下浮动和它的工作原理？清除浮动的技巧](#14解释下浮动和它的工作原理清除浮动的技巧)
  - [15用过媒体查询，针对移动端的布局吗？](#15用过媒体查询针对移动端的布局吗)
  - [16使用CSS 预处理器吗？喜欢那个？](#16使用css-预处理器吗喜欢那个)
  - [17、CSS3有哪些新特性？](#17css3有哪些新特性)
  - [18、经常遇到的CSS的兼容性有哪些？原因，解决方法是什么？](#18经常遇到的css的兼容性有哪些原因解决方法是什么)
  - [19、介绍一下CSS的盒子模型？](#19介绍一下css的盒子模型)
  - [20、对WEB标准以及W3C的理解与认识？](#20对web标准以及w3c的理解与认识)
  - [21、XHTML和HTML有什么区别？](#21xhtml和html有什么区别)
  - [22、Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?](#22doctype-严格模式与混杂模式-如何触发这两种模式区分它们有何意义)
  - [23、 行内元素有哪些?块级元素有哪些?CSS的盒模型?](#23-行内元素有哪些块级元素有哪些css的盒模型)
  - [24、CSS引入的方式有哪些? link和@import的区别是?](#24css引入的方式有哪些-link和import的区别是)
  - [25、 CSS选择符有哪些?哪些属性可以继承?优先级 算法 如何计算?内联和important哪个优先级高?](#25-css选择符有哪些哪些属性可以继承优先级-算法-如何计算内联和important哪个优先级高)
- [杭州 有赞 前端 一面 1h 20min](#杭州-有赞-前端-一面-1h-20min)
  - [1. 栈和堆的理解](#1-栈和堆的理解)
  - [1. 进程和线程](#1-进程和线程)
  - [2. JS是单线程还是多线程](#2-js是单线程还是多线程)
  - [3. TCP和UDP的区别？](#3-tcp和udp的区别)
  - [4. HTTP状态码？](#4-http状态码)
  - [5. HTTPS 和 HTTP2.0了解吗？HTTPS 如何加密能说一下吗？](#5-https-和-http20了解吗https-如何加密能说一下吗)
  - [6. 事件循环机制（event loop）](#6-事件循环机制event-loop)
  - [7.  css、less、sass的区别](#7--csslesssass的区别)
  - [1.  call、apply区别](#1--callapply区别)
  - [2.  ES6知道吗？Map、weakMap用过吗？](#2--es6知道吗mapweakmap用过吗)
  - [6.  如何优化首屏渲染提高速度，有哪些方法？](#6--如何优化首屏渲染提高速度有哪些方法)
  - [7.  CDN知道吗？](#7--cdn知道吗)
  - [8.  为什么选择 前端 ？](#8--为什么选择-前端-)
  - [9.  平时怎么规划时间？](#9--平时怎么规划时间)
  - [10. 手写一个节流。](#10-手写一个节流)
  - [11. 代码题。](#11-代码题)
- [重点关注的模拟](#重点关注的模拟)
  - [有了解echarts本身吗？](#有了解echarts本身吗)
  - [不用echarts类的工具，怎么绘制图表？](#不用echarts类的工具怎么绘制图表)
  - [svg了解吗](#svg了解吗)
  - [object.defineProperty本身有什么限制？](#objectdefineproperty本身有什么限制)
  - [object.breeze()内部是怎么实现的？](#objectbreeze内部是怎么实现的)
  - [es6了解吗](#es6了解吗)
  - [let和const和var的区别](#let和const和var的区别)
  - [什么是块级作用域](#什么是块级作用域)
  - [除了函数还有哪些块级作用域](#除了函数还有哪些块级作用域)
  - [可以用原型链实现class吗](#可以用原型链实现class吗)
  - [哪些方法判断值的类型](#哪些方法判断值的类型)
  - [instanceof的底层实现机制](#instanceof的底层实现机制)
  - [css有哪些方法？](#css有哪些方法)
  - [怎么实现垂直水平居中](#怎么实现垂直水平居中)
  - [position的值](#position的值)
  - [绝对定位怎么实现水平居中](#绝对定位怎么实现水平居中)
  - [flex布局知道哪些（弹性布局）](#flex布局知道哪些弹性布局)
  - [如何实现三列布局，左右定宽，中间自适应](#如何实现三列布局左右定宽中间自适应)
  - [为什么用let定义变量](#为什么用let定义变量)
  - [js本身的 排序 api](#js本身的-排序-api)
  - [说一下filter、map、forEach、every、some](#说一下filtermapforeacheverysome)
  - [手写深度拷贝，并且把对象的属性改成驼峰类型](#手写深度拷贝并且把对象的属性改成驼峰类型)
  - [js新增了其他的数据类型吗](#js新增了其他的数据类型吗)
  - [get和post有什么区别？](#get和post有什么区别)
  - [tcp三次握手说一下](#tcp三次握手说一下)
  - [http基于什么实现的](#http基于什么实现的)
  - [http2.0有了解吗](#http20有了解吗)
  - [https了解吗](#https了解吗)
  - [https握手过程](#https握手过程)
  - [http缓存说一下](#http缓存说一下)
  - [强制缓存怎么设置](#强制缓存怎么设置)
  - [http头部字段有哪些](#http头部字段有哪些)
  - [缓存位置](#缓存位置)
    - [什么情况下会遇到跨域，描述一下，前端常见的处理跨域的几种方式](#什么情况下会遇到跨域描述一下前端常见的处理跨域的几种方式)
    - [闭包是什么，有什么特性，对页面有什么影响](#闭包是什么有什么特性对页面有什么影响)
    - [HTTP 状态码](#http-状态码)


# 一轮电话面试，
## 缓存，
## react16新特性，
## 前端路由服务端配置，
## ES6.promise，

为了解决回调地狱的问题，之后社区提出了 Promise 的解决方案，ES6 又将其写进了语言标准，采用 Promise 的实现方式在一定程度上解决了回调地狱的问题

## 异步，
## React优化，
# 受控组件，
* 在随后的用户输入中，能够控制表单中输入元素的组件被称为受控组件，**即每个状态更改都有一个相关联的处理程序**。

* 非受控组件：非受控组件是在内部存储其自身状态的组件，当需要时，可以使用 ref 查询 DOM 并查找其当前值。这有点像传统的 HTML。

## await async generator 对比，

(http://vhblog.ygjie.icu/zh/essay/25/#async-await)[http://vhblog.ygjie.icu/zh/essay/25/#async-await]

## redux异步， 

## 数组的方法
1. slice():slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
* end 可选
提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。
2. slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。
如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。
如果 end 被省略，则 slice 会一直提取到原数组末尾。
如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。
3. map():该方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。因为map生成一个新数组，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用forEach或者for-of替代。你不该使用map: A)你不打算使用返回的新数组，或/且 B) 你没有从回调函数中返回值。
4. forEach()：该方法对数组的每个元素执行一次给定的函数。arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
5. concat()：两个或者多个数组的链接
6. splice():**该方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。**，分别是三个函数，第一个start从第几个元素开始，第二个deleteCount是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素，第三个：要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。

7. fliter()，该方法创建一个新数组, 其包含所有回调函数callback函数实现的测试的所有元素。 
8. //map将返回值组装成一个数组
9. //filter返回的也是一个数组，但是返回的数组结构与原数组结构一致，可以说返回的数组是基于原数组的

## for of与for in
for…in 用于遍历所有的可枚举属性，功能类似于 Object.keys()，但是遍历不到 constructor、length 这样的不可枚举属性。

缺点：

数组的键名为数字，但是 for…in 循环是以字符串作为键名"0",“1”,“2”

for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。

for…of for…of 是 ES6 新增的遍历方式，它提供了统一的遍历机制。所有实现了[Symbol.iterator]接口的对象都可以被遍历。for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、Generator 对象，以及字符串

for ... in是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用Array.prototype.forEach()和for ... of

## 问了数据类型

* 基础数据类型：null、undefined、number、boolean、string、es6的symbool与bigint (ES10)其他都是他本身
  * 复杂数据类型（说里面详细的类型）：function这个类型是funcation、array、object这两个类型都是object
  
## 说一下typeof判断的值

> 基础数据类型除了null是Object，剩下的都是本身，复杂数据类型除了function是function都是Object，
> 再说一下null为什么是Object:为什么会出现这种情况呢？
> 因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。
> 为了避免这种问题，我们可以通过 Object.prototype.toString.call(xx)进行判断类型
> 例如
> console.log(Object.prototype.toString.call(function(){}));//[object Function]
> console.log(Object.prototype.toString.call([]));//[object Array]
> console.log(Object.prototype.toString.call(new Date));//[object Date]


### 判断一个对象得类型可以使用typeof、instanceof,如果想要准确判断请用object原型链上的tostring.call方法进行判断

* typeof判断类型的缺点是，因为这个判断一个对象是否是想要的对象，是不可能得，因为null 的结果也是 object，数组的结果也是 object，

1. typeof 
2. instanceof
3. constructor：当一个函数F被定义时，JS引擎会为F添加prototype原型，然后在prototype上添加一个constructor属性，并让其指向F的引用，F利用原型对象的constructor属性引用了自身，当F作为构造函数创建对象时，原型上的constructor属性被遗传到了新创建的对象上，从原型链角度讲，构造函数F就是新对象的类型。这样做的意义是，让对象诞生以后，就具有可追溯的数据类型。
4. Object.prototype.toString()


## typeof NaN是什么

NaN是number

##  判断这个对象是数组的方法

* Array.isArray()如果是true那就是数组, 
* instanceof,instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
* Object.prototype.toString().call()


##  apply, call, bind的的区别

* call和apply几乎没区别，唯一的区别是传参列表不同

apply第二个参数是数组，call的第二个参数后是数组的解构，bind返回的是一个function，其他两个返回的是对象


call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：

call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 obj.myFun.call(db,'成都', ... ,'string' )。

apply 的所有参数都必须放在一个数组里面传进去 obj.myFun.apply(db,['成都', ..., 'string' ])。

bind 除了返回是函数以外，它 的参数和 call 一样。

当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！

##  ES6的新特性

let const , [...arr]解构，`${}`, for in for of, Promise，箭头函数,

## Promise除了 .then .catch .all .race 还有什么


* resolve,reject

## async awit 的优势

当时说的是 await 就是 generator 加上 Promise 的语法糖，没有一大堆的Promise.then的链式调用，简洁明了，面试官问还有么，考虑了10秒左右， 想不到

async/await 的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。

当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。

## ES6中把箭头函数和普通函数进行对比

this(这个着重问了)，没有arguments，匿名函数没有new (不全可以补充)

## css中的grid的属性

网格布局（Grid）

二轮视频coding，在线编程，有赞前端必不可少环节，编程题涉及 深克隆相关，代码不仅要实现功能，还要优雅，合理控制时间。

PS：考察原始类型和对象类型在内存不同形式、对象key遍历、字符串和数组互转，toUpperCase(),hasOwnProperty(),递归等，
为了面试而出的一道题，实际工作中意义不大。
const testData = {    a_bbb: 123,    a_g: [1, 2, 3, 4],    a_d: {        s: 2,        s_d: 3    },    a_f: [1, 2, 3, {        a_g: 5    }],    a_d_s: 1}/** * 将一个json数据的所有key从下划线改为驼峰 *  * @param {object | array} value 待处理对象或数组 * @returns {object | array} 处理后的对象或数组 */function mapKeysToCamelCase(data) {//写代码}


# 有赞社招一面

## Q2 说说从输入URL到看到页面发生的全过程，越详细越好。


首先，我们假设输入的url的请求为最简单的Http请求，以GET请求为例，大致分以下几个步骤：

1. 用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。

2. 浏览器根据输入的URL地址解析出主机名。

3. 浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考DNS查找域名的过程。

4. 拿到ip地址后，浏览器再从URL中解析出端口号。

5. 拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是三次握手。传送门：[完整的tcp链接](https://www.cnblogs.com/xsilence/p/6034361.html)。

6. 浏览器向服务器发送一条HTTP请求报文。

7. 服务器向浏览器返回一条HTTP响应报文。

8. 关闭连接（四次挥手） 浏览器解析文档。

如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。

以上步骤简述了浏览器从输入url到最后页面呈现的大致过程，但这并不很具体，比如浏览器请求报文类型是什么，会遇到哪些错误场景、浏览器又是如何解析响应报文等等都没具体描述。


## Q3 你刚刚说了三次握手，四次挥手，那你描述一下？

* 三次握手 

第一次握手是让服务端知道客户端具有发送能力，
第二次握手是让客户端知道服务端具有接受和发送的能力，但此时服务端并不知道客户端是否收到了自己发送的消息，
所以第三次握手起到了这个作用，经过了三次握手后服务端和客户端都确认了双方的接收和发送能力 

不是两次是因为无法确认客户端的接受能力，大于等于三次都可以，只是再多用处不大，第三次握手是可以携带数据的，前两次不可以，因为有人想攻击服务器，在第一次握手中放了大量数据，那么服务端必定会消耗更多的时间和内存去处理这些数据，大大增加了服务端被攻击的风险 第一次握手，客户端处于 close 状态，服务端处理 listening 状态，客户端给服务端发送了一个 SYN 报文并指明了客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态 第二次握手，服务端接收到 SYN 报文后，会以自己的 SYN 报文作为应答，并且也指定了自己的初始化序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务端处于 SYN_REVD 状态 第三次握手，当客户端接收到 SYN 报文后，会发送一个 ACK 报文，也把 ISN + 1 作为 ACK 的值，表示客户端接收到了服务端的 SYN 报文，此时客户端处于 establish 的状态，服务端接收到 ACK 报文后也处于 established 状态，此时双方成功建立起链接 

* 四次挥手 

为什么链接需要三次而断开需要四次：当服务端接收到客户端的 FIN 报文后，发送的 ACK 报文还是用来应答，并不表示服务端也希望立即关闭连接，只有当服务端把所有的报文都发送完了，才会发送 FIN 报文，告诉客户端可以断开连接了，因此这就是需要四次挥手的原因 

1. 第一次挥手，在挥手之前，两端都处于 established 的状态，客户端发送一个 FiN 报文，用来关闭客户端到服务端的数据传输，此时客户端处于 FIN_WAIT_1 状态。 


2. 第二次挥手，当服务端收到 FIN 报文后，会发送 ACK 报文，并把客户端的序列号值加 1 作为 ACK 报文的序列号，表明已经收到客户端的报文了，此时服务端处于 close_wait 状态 


3. 第三次挥手，如果服务端同意关闭连接，则会向客户端发送一个 FIN 报文，并指定一个序列号，此时服务端处于 LAST_ACK 的状态 


4. 第四次挥手，当客户端收到 ACK 后，处于 FIN_WAIT_2 状态，待收到 FIN 报文时发送一个 ACK 报文作为应答，并且把服务端的序列号值+1 作为自己的 ACK 报文的序列号值，是客户端处于 TIME_WAIT 状态，等待一段时间后会进入 closed 状态，当服务端接收到 ACK 值后，也会变为 closed 状态，此时连接正式关闭

## Q4 刚刚Q2中说的CSS和JS的位置会影响页面效率，为什么？

   如果js放在html页面的前端在渲染的时候，会因为处理流程造成渲染阻塞，导致放在后面的css无法将html页面进行渲染，也就会造成白屏

>解决方案

根本原因是客户端渲染的无力，因此最简单的方法是在服务器端，使用模板引擎渲染所有页面。同时

1减少文件加载体积，如html压缩，js压缩

2加快js执行速度 比如常见的无限滚动的页面，可以使用js先渲染一个屏幕范围内的东西

3提供一些友好的交互，比如提供一些假的滚动条

4使用本地存储处理静态文件。


## Q5 现在有一个函数A和函数B，请你实现B继承A


1. 原型继承

```javascript
function Parent () {
  this.name = 'Parent'
  this.sex = 'boy'
}
function Child () {
  this.name = 'child'
}
// 将子类的原型对象指向父类的实例
Child.prototype = new Parent()
//优：继承了父类的模板，又继承了父类的原型对象
//缺：1.无法实现多继承(因为已经指定了原型对象了)
//   2.创建子类时，无法向父类构造函数传参数
```
2. 构造函数继承
```javascript
function Parent (name) {
  this.name = name
}
function Child () {
  //用.call 来改变 Parent 构造函数内的指向
  Parent.call(this, 'child')
}
//优：解决了原型链继承中子类实例共享父类引用对象的问题，实现多继承，创建子类实例时，可以向父类传递参数
//缺：构造继承只能继承父类的实例属性和方法，不能继承父类原型的属性和方法
```
3. 组合继承

组合继承就是将原型链继承与构造函数继承组合在一起。

使用原型链继承来保证子类能继承到父类原型中的属性和方法
使用构造继承来保证子类能继承到父类的实例属性和方法

4. 寄生组合继承
5. ES6提到的class继承：使用extends与super


## Q6 刚刚你在Q5中说的几种继承的方式，分别说说他们的优缺点

## Q7 说说CSS中几种垂直水平居中的方式

对于宽高固定的：
1. 使用margin：auto
2. 四个方向都为0，然后margin设置为auto
3. 使用绝对定位，top、left都设置为50%，然后margin负值为宽高的一半来调整
4. 使用绝对定位，top、left设置为50%，然后使用transform中的translate（-50%，-50%）（高宽可以未知）
5. 使用弹性布局，然后水平位置的justify-content设置为center，align-items设置为center（高宽可以未知）

## Q8 Q7中说的flex布局，垂直水平居中必须知道宽度吗？

不需要

Q9 描述一下this

## Q10 说一下浏览器的缓存机制

浏览器缓存有强制缓存与协商缓存
1. 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;

2. 协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。

* 缓存中header的参数：

1. 强制缓存

Expires：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。

**Cache-Control：**当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

cache-control除了该字段外，还有下面几个比较常用的设置值：

**-no-cache：**不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。

**-no-store：**直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。

**-public：**可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

**-private：**只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

2. **协商缓存**

Last-Modify/If-Modify-Since：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存

**Etag：**web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

**If-None-Match：**当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定是否命中协商缓存；


> ETag和Last-Modified的作用和用法，他们的区别：

1. Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；

2. 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；

3. 在优先级上，服务器校验优先考虑Etag。

>浏览器缓存过程

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求

3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；；

4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

> 常见问题

用户行为对浏览器缓存的影响

> 解决方案

点击刷新按钮或者按F5

浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match,这就意味着服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200.

用户按Ctrl+F5（强制刷新）

浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是200.

地址栏回车

浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

## Q11 ETag是这个字符串是怎么生成的？



Q12 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？

Q13 你觉得你做过的你觉得最值得炫耀的项目 ？

## 14解释下浮动和它的工作原理？清除浮动的技巧

浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

浮动元素引起的问题和解决办法？

浮动元素引起的问题：

父元素的高度无法被撑开，影响与父元素同级的元素
与浮动元素同级的非浮动元素（内联元素）会跟随其后
若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：
```css
.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}
.clearfix{display: inline-block;} /* for IE/Mac */
```

清除浮动的几种方法：

1，额外标签法，

2，使用after伪类

3，设置`overflow`为`hidden`或者auto

## 15用过媒体查询，针对移动端的布局吗？

## 16使用CSS 预处理器吗？喜欢那个？

## 17、CSS3有哪些新特性？

## 18、经常遇到的CSS的兼容性有哪些？原因，解决方法是什么？

## 19、介绍一下CSS的盒子模型？

css 盒模型描述了以文档树中的元素而生成的矩阵框，并根据排版模式进行布局，每个盒子都有一个内容区域以及周围可选的 padding，border，margin,css 盒模型负责计算块级元素占用多少空间，边框是否重叠，边距是否合并，盒子的尺寸

盒模型有以下规则：

块级元素大小由 width，height，padding，margin,border 共同决定
如果没有指定 height，块级元素的高度等于其包含的子元素的告诉加上 padding(在没有浮动的情况下)
如果没有指定 width，非浮动元素的宽度等于其父元素的宽度减去父元素的 padding
元素的 height 是由内容的 height 来计算的。
元素的 width 是由内容的 width 来计算的。
默认情况下，padding 和 border 不是元素 width 和 height 的组成部分
盒模型又分为标准盒模型和 ie 盒模型

盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。

标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，
* 所对应的范围不同。标准盒模型的 width 和 height 属性的范围只包含了 content，
* 而 IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。

一般来说，我们可以通过修改元素的 box-sizing 属性来改变元素的盒模型

::: tip 在 ie8+浏览器中使用哪个盒模型可以由 box-sizing（CSS 新增的属性）控制，默认值为 content-box，即标准盒模型；

如果将 box-sizing 设为 border-box 则用的是 IE 盒模型。如果在 ie6，7，8 中 DOCTYPE 缺失会将盒子模型解释为 IE 盒子模型。若在页面中声明了 DOCTYPE 类型，所有的浏览器都会把盒模型解释为 W3C 盒模型 :::

## 20、对WEB标准以及W3C的理解与认识？

## 21、XHTML和HTML有什么区别？

## 22、Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?

## 23、 行内元素有哪些?块级元素有哪些?CSS的盒模型?

## 24、CSS引入的方式有哪些? link和@import的区别是?

## 25、 CSS选择符有哪些?哪些属性可以继承?优先级 算法 如何计算?内联和important哪个优先级高?


# 杭州 有赞 前端 一面 1h 20min

## 1. 栈和堆的理解

1、栈：栈用于维护函数调用的上下文，离开栈函数调用就会无法实现。栈通常在用户空间的最高地址处分配，通常有数兆字节。

2、堆:堆用来容纳应用程序动态分配的内存区域，我们使用malloc 或者new分配内存时，得到的内存来自堆里。堆通常存于栈的下方（低地址方向），堆一般比栈大很多，可以有几十至数百兆字节的容量。

栈是由高地址向低地址增长。

堆是由低地址向高地址增长。

上方例子得知，当我改变arr2中的数据时，arr1中数据也发生了变化，当改变str1的数据值时，arr1却没有发生改变。为什么？这就是传值与传址的区别。

因为arr1是数组，属于引用类型，所以它赋予给arr2的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象的值。str1得到的是一个基本类型的赋值，因此，str1仅仅是从arr1堆内存中获取了一个数值，并直接保存在栈中。arr1、arr2都指向同一块堆内存，arr2修改的堆内存的时候，也就会影响到arr1，str1是直接在栈中修改，并且不能影响到arr1堆内存中的数据。



## 1. 进程和线程

进程是资源分配的最小单位，线程是CPU调度的最小单位，这种解释太过抽象

进程只能有一个，但是线程可以有多个；

做个简单的比喻：
1. 进程=火车，线程=车厢线程在进程下行进（单纯的车厢无法运行）
2. 一个进程可以包含多个线程（一辆火车可以有多个车厢）
3. 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
4. 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
5. 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
6. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
7. 进程可以拓展到多机，进程最适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
8. 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）
－"互斥锁"进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”


## 2. JS是单线程还是多线程

单线程

## 3. TCP和UDP的区别？

1. （基于连接vs无连接）tcp是面向连接的（三次握手；四次挥手）；udp不是面向连接的
2. （重量级vs轻量级）tcp是一个重量级的协议；udp则是轻量级的协议。一个tcp数据报的报头大小最少20字节，udp数据报的包头固定8个字节
3. （可靠性）tcp交付保证：如果消息在传输中丢失，那么它将重发；udp没有交付保证，一个数据包在运输过程中可能丢失。
4. （有序性）消息到达网络的另一端可能是无序的，tcp协议将为你拍好序。Udp不提供任何有序性的保证。
5. （速度）tcp慢，适合传输大量数据；udp快，适合传输少量数据。
6. （流量控制和拥塞控制）TCP有流量控制和拥塞控制，udp没有。
7.  tcp面向字节流，udp面向报文
8.  tcp只能单播，不能发送广播和组播；udp可以广播和组播。
9.  Tcp应用：邮件传输 udp应用：qq聊天、qq视频

## 4. HTTP状态码？

* 1**	信息，服务器收到请求，需要请求者继续执行操作
* 2**	成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误

* 常见的
* 200	OK	请求成功。一般用于GET与POST请求
* 301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
* 302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
* 401	Unauthorized	请求要求用户的身份认证
* 500	Internal Server Error	服务器内部错误，无法完成请求
## 5. HTTPS 和 HTTP2.0了解吗？HTTPS 如何加密能说一下吗？

* HTTP特定就是明文传输，因此传输过程中会出现信息被盗取的情况，然而为了解决这个HTTP明文传输过程的信息丢失，为了防范这样一类攻击，，提出了新的方案即 HTTPS。

* HTTPS：其原理是在HTTP和TCP之间建立了一个中间层，当HTTP和TCP通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给TCP, 响应的，TCP必须将数据包解密，才能传给上面的HTTP。这个中间层也叫安全层。安全层的核心就是对数据加解密。

* HTTP加密是使用：对称加密和非对称加密

* 对称加密是最简单的方式，指的是加密和解密用的是同样的密钥。

* 1. 对称加密：首先，浏览器会发送给服务器发送一个随机数和加密方法列表，然后服务器回发一个随机数和加密方法列表
* 接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号
* 2. 非对称加密：服务器手里有两把钥匙，一把是公钥，也就是说每个人都能拿到，是公开的，另一把是私钥，这把私钥只有服务器自己知道。
* 现在两者拥有相同的client_random、server_random和加密方法。然后浏览器用公钥将client_random和server_random加密，生成与服务器通信的暗号。
这时候由于是非对称加密，公钥加密过的数据只能用私钥解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。
* 3. 对称加密和非对称加密的结合：

1. 浏览器向服务器发送client_random和加密方法列表。
2. 服务器接收到，返回server_random、加密方法以及公钥。
3. 浏览器接收，接着生成另一个随机数pre_random, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)
4. 服务器用私钥解密这个被加密后的pre_random。

现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。
然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。
这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而拿不到pre_random，也就无法生成最终的密钥了。



## 6. 事件循环机制（event loop）

浏览器中的事件循环 
JS 本身是单线程的，它依靠事件循环机制完成的异步操作和多线程

大体有三个部分组成：

1. 调用栈call stack
2. 消息队列message queque
3. 微任务队列microtask queque

* 对于所有执行属性，当前执行流程结束他就会弹出调用栈，

* 但对于fetch，事件回调，settimeout，setinterval会入队到消息队列中，消息会在调用栈清空的情况下执行，这也就是为什么settimeout中的时间是延迟的最小参数的原因

* 使用promise、async、await的异步操作都会加入到微任务队列中，他会在调用栈情况的情况下立即执行，
* 所以在这里如果出现消息队列与微任务队列同时出现的情况下，先是微任务队列先执行完毕后，再执行消息队列的任务

## 7.  css、less、sass的区别

CSS全称Cascading Style Sheets （层叠样式表）是一门历史悠久的标记性语言，同 HTML 一道，被广泛应用于万维网（World Wide Web）中。HTML 主要负责文档结构的定义，CSS 负责文档表现形式或样式的定义

Less全称Leaner Style Sheets 是一门向后兼容的 CSS 扩展语言，是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。Less 可以运行在 Node 或浏览器端

它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能

## 1.  call、apply区别

call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：

call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 obj.myFun.call(db,'成都', ... ,'string' )。

apply 的所有参数都必须放在一个数组里面传进去 obj.myFun.apply(db,['成都', ..., 'string' ])。

bind 除了返回是函数以外，它 的参数和 call 一样。

当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！

## 2.  ES6知道吗？Map、weakMap用过吗？


## 6.  如何优化首屏渲染提高速度，有哪些方法？



## 7.  CDN知道吗？

## 8.  为什么选择 前端 ？

因为自己比较喜欢计算机视觉方向的东西，使用视觉展示数据背后的逻辑

## 9.  平时怎么规划时间？

## 10. 手写一个节流。

* 一段时间内只做一件事情，实际应用，表单的提交：典型的案例就是鼠标不断点击的触发，规定在n秒多次点击只有一次生效

```javascript
//节流函数实现
function thro(func,waittime){
  let timerOut//判断
  return function(){
    if(!timerOut){
      timerOut=setTimeout(function(){
        func();
        timerOut=null
      },waittime)
    }
  }
}

function handle(){
  console.log(Math.random())
}

document.getElementById('button').onclick=thro(handle,2000)

```

## 11. 代码题。

将一天24小时按每半小划分成48段，我们用一个位图表示选中的时间区间，例如`110000000000000000000000000000000000000000000000`，

表示第一个半小时和第二个半小时被选中了，其余时间段都没有被选中，也就是对应00:00~01:00这个时间区间。一个位图中可能有多个不连续的

时间区间被选中，例如`110010000000000000000000000000000000000000000000`，表示00:00-1:00和02:00-02:30这两个时间区间被选中了。

要求：写一个函数timeBitmapToRanges，将上述规则描述的时间位图转换成一个选中时间区间的数组。

示例输入：`"110010000000000000000000000000000000000000000000"`
示例输出：`["00:00~01:00", "02:00~02:30"]`

# 重点关注的模拟


## 有了解echarts本身吗？

## 不用echarts类的工具，怎么绘制图表？


使用svg进行绘制图表

## svg了解吗

SVG 指可伸缩矢量图形 (Scalable Vector Graphics)
SVG 用来定义用于网络的基于矢量的图形
SVG 使用 XML 格式定义图形
SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失
SVG 是万维网联盟的标准
SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体


## object.defineProperty本身有什么限制？

当一个对象已存在某属性，重新定义该属性（如果允许）时，若未指定属性描述器的enumerable或configurable，则其默认值为原有属性描述器的对应的enumerable或configurable值。

## object.breeze()内部是怎么实现的？

## es6了解吗

* es6更新了let、const；箭头函数，promise，扩展运算符（...），解构赋值，模板字符串和标签函数，symbol，for of（遍历对象的值）它结合了foreach的简洁与中断循环的能力，class类

## let和const和var的区别

## 什么是块级作用域

在es5中，函数只能在顶层作用域或者函数作用域声明，不能再块级作用域声明，但是浏览器并没有遵守这个规则，为了兼容还是支持在块级作用域之中声明函数，不会报错。

es6引入了块级作用域，明确允许在块级作用域之中声明函数，es6规定，在函数声明语句的行为类似let在块级作用域之外不可引用

```javascript
var flag
var demo
demo()//报错
flag=true
if(flag){
  function demo(){
    console.log('aaa')
  }else{
    function demo(){
      console.log('bbb');
    }
  }
}
```

## 除了函数还有哪些块级作用域

一次for循环有几个块

class内部是怎么实现的？

js基本数据类型

js引用类型

原型链了解吗？

## 可以用原型链实现class吗

## 哪些方法判断值的类型

1. typeof 
2. instanceof
3. constructor：当一个函数F被定义时，JS引擎会为F添加prototype原型，然后在prototype上添加一个constructor属性，并让其指向F的引用，F利用原型对象的constructor属性引用了自身，当F作为构造函数创建对象时，原型上的constructor属性被遗传到了新创建的对象上，从原型链角度讲，构造函数F就是新对象的类型。这样做的意义是，让对象诞生以后，就具有可追溯的数据类型。
4. Object.prototype.toString()

typeof和instanceof有什么区别

* 最重要的区别就是typeof在对对象、数组、null返回的值都是object

* 在javascript中，判断一个变量的类型可以用typeof

　　(1) 数字类型、typeof返回的值是number。比如说：typeof(1)，返回值是number

　　(2) 字符串类型，typeof返回的值是string。比如typeof(“123”返回值时string)

　　(3) 布尔类型，typeof返回的值是boolean。比如typeof(true)返回值时boolean

　　(4) 对象、数组、null返回的值是object。比如typeof(window)，typeof(document)，typeof(null)返回的值都是object

　　(5) 函数类型，返回的值是function。比如：typeof(eval)，typeof(Date)返回的值都是function。

　　(6) 不存在的变量、函数或者undefined，将返回undefined。比如：typeof(abc)、typeof(undefined)都返回undefined

* 而ECMAScript引入了另一个Java运算符instanceof来解决这个问题。Instanceof运算符与typeof运算符相似，用于识别正在处理的对象的类型。与typeof方法不同的是，instanceof方法要求开发者明确地确认对象为某特定类型

## instanceof的底层实现机制

* ①用于判断某个实例是否属于某构造函数

* ②在继承关系中用来判断一个实例是否属于它的父类型或者祖先类型的实例

说白了，只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false
```javascript
function instance_of(L, R) {     // L 表示instanceof左边，R 表示instanceof右边
    let O = R.prototype;         // 取 R 的显示原型
    L = L.__proto__;             // 取 L 的隐式原型
    while (true) {               // 循环执行，直到 O 严格等于 L
         if (L === null) return false;
         if (O === L) return true;
         L = L.__proto__;        // 获取祖类型的__proto__
    }
}
```

## css有哪些方法？

## 怎么实现垂直水平居中

1. 利用绝对定位，（1设置四个方向值都为0，将margin设置为auto，）（2.利用top与left设置为50%，然后再用margin负值来调整中心点）
2. 如果是宽度高度不定，可以利用（1.绝对定位，然后top与left都为50%，translate设置为-50%）（或者使用flex布局，通过align-items与justify-content都设置为center）

## position的值
1. absolute 绝对定位，相对于static定位以外的第一个父元素进行定位
2. relative 相对定位
3. flex弹性布局
4. fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。
5. static：没有定位，元素正常出现在流中

## 绝对定位怎么实现水平居中

1. 四个方向值都为0，然后margin：0 auto
2. CSS3的兴起，使得有了更好的解决方法，就是使用transform代替margin. transform中translate偏移的百分比值是相对于自身大小的，

## flex布局知道哪些（弹性布局）

flex用过哪些属性

flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex
容器，它的所有子元素都会成为它的项目。

一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。
我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还
可以使用flex-wrap来规定当一行排列不下时的换行方式。

对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，
项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。

## 如何实现三列布局，左右定宽，中间自适应

* 首先我想到的是float——浮动布局
> 使用浮动，先渲染左右两个元素，分别让他们左右浮动，然后再渲染中间元素，设置它的margin左右边距分别为左右两个元素的宽度。


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <div style="width:300px; float:left; background:#6FF">左侧的内容 固定宽度</div>
    <div style="width:200px; float:right; background-color:#960">右侧的内容 固定宽度</div>
    <div style="margin-left:300px;margin-right:200px; background-color:#9F3;">中间内容，自适应宽度</div>
</body>
</html>
```

* 其次我想到了position——定位
> 使用定位方式，不需要先渲染中间元素，只要把左右两个元素分别使用定位，left:0;right:0;中间元素设置margin左右边距为左右两个元素的宽度即可。
css的选择器和对应的优先级

* 第三、使用双飞翼布局

> 使用双飞翼布局与其他方式不同，它最先渲染的是中间元素，然后才渲染两边元素（注意，这一点与float布局方式正好相反哟），先将三个元素都设置为向左浮动，然后使用负边距将左右两个元素覆盖到中间元素的左右两边，形成羽翼。

* 第四，CSS3的flex布局方法
> 该方式的思想是设置一个弹性容器包裹三个元素，并将这个容器设置为水平排列（flex-flow:row）,左右两边元素设置固定宽度，中间元素设置为flex:1;



css前后设置了两个样式，应用哪些？

css的一个动画效果是

响应式具体是怎么实现的呢

字体大小自适应怎么做

rem和em的区别

有接触 算法 和数据结构吗？你觉得最有意思的 算法 有哪些？具体是怎么实现的？

排序 算法 有哪些？说一下归并 算法

手撕归并 算法 ？？？后面让我任写一个 排序 算法

## 为什么用let定义变量

新语法的出现，不仅使得我们更容易的理解JS，而且减少很多奇奇怪怪的问题出现。块级声明，可以很有效的避免了变量污染这个问题。

## js本身的 排序 api

* Arrays.sort并不是单一的排序，而是插入排序，快速排序，归并排序三种排序的组合，为此我画了个流程图：

[https://www.iteye.com/topic/1138374](https://www.iteye.com/topic/1138374)

数组本身有哪些api

## 说一下filter、map、forEach、every、some

>filter:它创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，在初始化数组中大于5的数组

> map：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值

> foreach:forEach()：该方法对数组的每个元素执行一次给定的函数。arr.forEach(callback(currentValue [, index [, array]])[, thisArg])

>every：判断数组中都满足条件才返回真，复奏为假

> some:只要有真便返回为真
## 手写深度拷贝，并且把对象的属性改成驼峰类型
```javascript
// 实现对象深拷贝 & key下划线转驼峰 
( a_bbb => aBbb、a_d_s => aDS ) 
const testData = {     
  a_bbb: 123,     
  a_g: [1, 2, 3, 4],    
  a_d: {         
    s: 2,         
    s_d: 3     },     
    a_f: [1, 2, 3, 
    {         
      a_g: 5     }],     
    a_d_s: 1 
}  

```
## js新增了其他的数据类型吗


说一下csrf

## get和post有什么区别？

最直观的是语义上的区别，往细了说： 
1. 从缓存角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 post 请求不会 从编码角度，get 请求只能进行 URL 编码，只能收到 ASCII 字符，而 POST 没有限制。 
2. 从参数角度，get 请求一般会放到 URL 中，因此不安全，post 请求放在请求体中，更适合传输敏感信息 从幂等性角度，get 是幂等性的，而 post 不是（幂等性是指执行相同的操作，结果也是相同的） 
3. 从 TCP 的角度，get 请求会吧请求报文一次性的发出去，而 Post 会分为两个 TCP 数据包，首先发送 header 部分，如果服务器响应 100，然后发 boy（火狐浏览器除外，她的 post 请求只发一个 TCP 包）

## tcp三次握手说一下

1. 第一次握手是让服务端知道客户端具有发送能力，
2. 第二次握手是让客户端知道服务端具有接受和发送的能力，但此时服务端并不知道客户端是否收到了自己发送的消息，
3. 所以第三次握手起到了这个作用，经过了三次握手后服务端和客户端都确认了双方的接收和发送能力 

## http基于什么实现的

HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：

## http2.0有了解吗

> http2特点
1. 多路复用：相同域名多个请求，共享同一个TCP连接，降低了延迟

2. 请求优先级：给每个request设置优先级

3. 二进制传输；之前是用纯文本传输

4. 数据流：数据包不是按顺序发送，对数据包做标记。每个请求或回应的所有数据包成为一个数据流，

5. 服务端推送：可以主动向客户端发送消息。

6. 头部压缩：减少包的大小跟数量

7. HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了 HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！http1 keep alive 串行传输

## https了解吗

* 谈到 HTTPS, 就不得不谈到与之相对的 HTTP。HTTP 的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过 WIFI 路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的中间人攻击。

* HTTPS 并不是一个新的协议, 而是一个加强版的 HTTP。其原理是在 HTTP 和 TCP 之间建立了一个中间层，当 HTTP 和 TCP 通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给 TCP, 响应的，TCP 必须将数据包解密，才能传给上面的 HTTP。这个中间层也叫安全层。安全层的核心就是对数据加解密。

* 概念 
* 首先需要理解对称加密和非对称加密的概念，然后讨论两者应用后的效果如何。 对称加密是最简单的方式，指的是加密和解密用的是同样的密钥。 而对于非对称加密，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密 加解密过程 接着我们来谈谈浏览器和服务器进行协商加解密的过程。 


1. 首先，浏览器会给服务器发送一个随机数 client_random 和一个加密的方法列表。 
2. 服务器接收后给浏览器返回另一个随机数 server_random 和加密方法。
3.  现在，两者拥有三样相同的凭证: client_random、server_random 和加密方法。 接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号

* 非对称加密
* 浏览器把 client_random 和加密方法列表传过来，服务器接收到，把 server_random、加密方法和公钥传给浏览器。 
* 现在两者拥有相同的 client_random、server_random 和加密方法。然后浏览器用公钥将 client_random 和 server_random 加密，生成与服务器通信的暗号。
* 这时候由于是非对称加密，公钥加密过的数据只能用私钥解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。



## https握手过程

## http缓存说一下

> 浏览器缓存两种机制：过期机制、验证机制 

1. 过期机制：指的是缓存副本的有效期。 一个缓存的副本必须满足以下条件，浏览器会认为它是有效的，足够新的 含有完整的过期时间控制头信息（HTTP 协议报头），并且仍在有效期内 浏览器已经使用过这个缓存的副本，并且会在一个会话中已经检查过新鲜度(即服务器上的资源是否发生改变) 满足以上两种情况的一种，浏览器会直接从缓存中获取副本进行渲染 
2. 校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签 Etag(Entity Tag),它可以用来作为浏览器再次请求过程中的校验标识，如果发现校验标识不匹配，说明资源已经被修改或者过期，浏览器需要重新获取资源内容

> 浏览器缓存的实现方式主要有两种：HTTP 和 ServiceWorker

> 其中HTTP支持的缓存策略有两种：强缓存和协商缓存



> 协商缓存：Last-Modified 和 If-Modified-Since


> 服务端要判断缓存有没有过期，只能将双方的资源进行对比。若浏览器直接把资源文件发送给服务端进行比对的话，网络开销太大，而且也会失去缓存的意义，所以显然是不可取的。有一种简单的判断方法，那就是通过响应头部字段 Last-Modified 和请求头部字段 If-Modified-Since 比对双方资源的修改时间 具体工作流程如下：

1. 浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，该字段表示这个资源在服务端上的最近修改时间；
2. 当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的修改时间，这个请求头叫 If-Modified-Since；
3. 服务端再次收到请求，根据请求头 If-Modified-Since 的值，判断相关资源是否有变化，如果没有，则返回 304 Not Modified，并且不返回资源内容，浏览器使用资源缓存值；否则正常返回资源内容，且更新 Last-Modified 响应头内容。
  
* 这种方式虽然能判断缓存是否失效，但也存在两个问题: 精度问题，Last-Modified 的时间精度为秒，如果在 1 秒内发生修改，那么缓存判断可能会失效 准度问题，考虑这样一种情况，如果一个文件被修改，然后又被还原，内容并没有发生变化，在这种情况下，浏览器的缓存还可以继续使用，但因为修改时间发生变化，也会重新返回重复的内容

> 协商缓存：ETag 和 If-None-Match
> 为了解决精度问题和准度问题，HTTP 提供了另一种不依赖于修改时间，而依赖于文件哈希值的精确判断缓存的方式，那就是响应头部字段 ETag 和请求头部字段 If-None-Match。

> ServiceWorker 
> ServiceWorker 是浏览器在后台独立于网页运行的脚本，也可以这样理解，它是浏览器和服务端之间的代理服务器。ServiceWorker 非常强大，可以实现包括推送通知和后台同步等功能，更多功能还在进一步扩展，但其最主要的功能是实现离线缓存 # 使用限制


## 强制缓存怎么设置

* Expires 
* HTTP/1.0 中可以使用响应头部字段 Expires 来设置缓存时间，它对应一个未来的时间戳。客户端第一次请求时，服务端会在响应头部添加 Expires 字段，当浏览器再次发送请求时，先会对比当前时间和 Expires 对应的时间，如果当前时间早于 Expires 时间，那么直接使用缓存；反之，需要再次发送请求 Expires:Sat, 10 Oct 2020 00:00:00 GMT
 1上述 Expires 信息告诉浏览器：在 2020.10.10 日之前，可以直接使用该请求的缓存。但是使用 Expires 响应头时容易产生一个问题，那就是服务端和浏览器的时间很可能不同，因此这个缓存过期时间容易出现偏差。同样的，客户端也可以通过修改系统时间来继续使用缓存或提前让缓存失效 
 
 * 为了解决这个问题，HTTP/1.1 提出了 Cache-Control 响应头部字段 Cache-Control 它的常用值有下面几个： no-cache，表示使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新； no-store，禁止浏览器以及所有中间缓存存储响应内容； public，公有缓存，表示可以被代理服务器缓存，可以被多个用户共享； private，私有缓存，不能被代理服务器缓存，不可以被多个用户共享； max-age，以秒为单位的数值，表示缓存的有效时间； must-revalidate，当缓存过期时，需要去服务端校验缓存的有效性。 这几个值可以组合使用，比如像下面这样： cache-control: public, max-age=31536000
    :告诉浏览器该缓存为公有缓存，有效期 1 年



## http头部字段有哪些

1、  Accept：告诉WEB服务器自己接受什么介质类型，/ 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。
2、  Accept-Charset： 浏览器申明自己接收的字符集
Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）
Accept-Language：浏览器申明自己接收的语言
语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。
3、 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。
4、 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。
5、 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。

##  缓存位置 
前面我们已经提到，当强缓存命中或者协商缓存中服务器返回 304 的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢 浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：
 1.  Service Worker 
 2.  Memory Cache （内存缓存）
 3.  Disk Cache （磁盘缓存）
 4.  Push Cache（推送缓存）

### 什么情况下会遇到跨域，描述一下，前端常见的处理跨域的几种方式

浏览器遵循同源政策(scheme(协议)、host(主机)和 port(端口)都相同则为同源)。
非同源站点有这样一些限制: 不能读取和修改对方的 DOM 不读访问对方的 Cookie、IndexDB 和 LocalStorage 限制 XMLHttpRequest 请求。(后面的话题着重围绕这个) 当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为跨域请求。 跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。那这个拦截是如何发生呢？ 首先要知道的是，浏览器是多进程的，以 Chrome 为例，进程组成如下：

广义上：
1.  资源跳转： A链接、重定向、表单提交
2.  资源嵌入： **link、script、img、frame**等dom标签，还有样式中background:url()、@font-face()等文件外链
3.  脚本请求： js发起的ajax请求、dom和js对象的跨域操作等

跨域解决方案
1. 通过jsonp跨域

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。

核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。


2. document.domain + iframe跨域
3. location.hash + iframe
4. window.name + iframe跨域
5. postMessage跨域
6. 跨域资源共享（CORS）

ORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。

1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin

2、带cookie跨域请求：前后端都需要进行设置

【前端设置】根据xhr.withCredentials字段判断是否带有cookie
【服务端设置】服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

7、 nginx代理跨域

在webpack.config.js中利用 WebpackDevServer 配置本地代理，详情配置查看devServer

如下简单配置案例，这样 `http://localhost:8080/api/getUser.php` 的请求就是后端的接口 `http://192.168.25.20:8088/getUser.php`


8、 nodejs中间件代理跨域
9、 WebSocket协议跨域

Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 服务器与 客户端都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

###  闭包是什么，有什么特性，对页面有什么影响

* 闭包是什么？

> 闭包是指有权访问另一个函数作用域中变量的函数

* 怎么创建闭包 ?在函数内部嵌套使用函数

```javascript
function fn() {
    for (var i = 0; i < 2; i++) {
        (function() {
            var variate = i;
            setTimeout(function() {
                console.log("setTimeout执行后:" + variate);
            }, 1000);
        })(); //闭包,立即执行函数,匿名函数
    }
    console.log(i); //2
    console.log(variate); //variate is not defined
}
fn();

```

* 为什么用闭包

> 因为在闭包内部保持了对外部活动对象的访问,但外部的变量却无法直接访问内部,避免了全局污染;
可以当做私有成员,弥补了因js语法带来的面向对象编程的不足;
可以长久的在内存中保存一个自己想要保存的变量.

* 闭包的缺点
> 可能导致内存占用过多,因为闭包携带了自身的函数作用域
闭包只能取得外部包含函数中得最后一个值

### HTTP 状态码 

http 状态码为三位数，被分为 5 类： 
1xx 表示目前是协议的中间状态，还需要后续操作 
2xxx 表示成功状态 
3xx 是重定向状态，资源位置发生变动，需要重新请求 
4xx 是请求报文有误 
5xx 是服务端发生错误 
常见的状态码有这些： 
200 表示成功的状态码 
204 表示请求成功但响应头后没有 body 数据 
206 表示部分内容，使用场景为 http 分块下载和断点续传，当然也会带上相应的响应头部字段 Content-Range 
301 永久重定向，
302 临时重定向 
304 表示命中协商缓存 
400 笼统的提示一下，并不知道哪里出错了 
403 表示服务器禁止访问 
404 表示未在服务器上找到资源 
405 表示请求方法不被允许 
406 表示资源无法满足客户端的条件 
408 表示服务器等待时间过长 
409 表示多个请求发生了冲突 
413 表示请求体数据过大 
414 表示请求行里的 URL 太大 
429 表示客户端发送的请求过多 
431 表示请求字段内容太大 
500 表示服务器出错了，但不知道出了什么错 
501 表示客户端请求的功能还不支持 
502 表示服务器本身正常，但访问时出错了，具体什么错误不知道 
503 表示服务器当前很忙，暂时无法响应服务



// =====================================================
// 欢迎参加有赞前端 Coding 面试
// =====================================================
// 界面介绍：
//   上方设置按钮可以切换语言、字体大小、主题
//   右侧控制台可以显示代码执行结果，可用于编码过程中的 DEBUG
// =====================================================
// Coding 须知：
//   本次 Coding 时间限制为 25 分钟
//   题目难度大致自上向下递增，请量力答题
// =====================================================



// 
// - 实现 debounce
// 

function debounce(fn, delay) {
    let setTime;
    return function () {
        if(setTime)
        {
            clearTimeout(setTime);
        }
        
        setTime = setTimeout(function () {
            fn();
        }, delay)
    }

}

const a = {
    count: 1,
    log: debounce(function () {
        console.log('debouce count:', this.count++)
    }, 50)
}

a.log() // 'debouce count: 1'
a.log()
setTimeout(() => {
    a.log() // 'debouce count: 2'
}, 150)


/**
 * 比较两个版本号的大小，如果 v1 版本比 v2 高，就返回 1，相等为 0，低于为 -1
 * @param {string} v1
 * @param {string} v2
 * @returns {number}
 */

// 示例：
// compareVersion('2.0.1', '2.0.5') => -1
// compareVersion('2.0.1', '2.0.0.1') => 1

function compareVersion(v1, v2) {

}

// console.log('compareVersion:', compareVersion('2.0.1', '2.0.5'))
// console.log('compareVersion:', compareVersion('2.0.1', '2.0.0.10'))
// console.log('compareVersion:', compareVersion('2.0.0.0.5', '2.0.0.0.5'))


/**
 * 实现 getValue 函数，安全的获取目标对象指定 path 的值
 * @params {object | array} value 指定对象
 * @params {string} path
 */

const object = { 'a': [{ 'b': { 'c': 3 } }] }; // path: 'a[0].b.c'
const array = [{ "a": { b: [1] } }]; // path: '[0].a.b[0]'

function getValue(obj, path) {


}

// console.log('getValue:', getValue(object, 'a[0].b.c'))
// console.log('getValue:', getValue(array, '[0].a.b[0]'))
// console.log('getValue:', getValue(array, '[0].a.d'))