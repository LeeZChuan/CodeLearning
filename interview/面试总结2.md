2022年5-7月面试总结

##  上海碳衡科技一面

### 1. 聊聊可视化的技术选型是怎么样的

> 可视化技术栈可以考虑是否使用svg或者canvas底层组件作为

### 2. 聊聊es8新特性有哪些

> 1.Object.values/Object.entries
> object.entries能够把对象的属性以数组形式返回，
object.values能够提取对象的属性值并以数组形式返回

> 但是，他们对 对象数组其实没有太大效果，可以自己试验一下
个人认为，在没有枚举类型的情况下，其实用for in更为实用。

> 2.String.prototype.padStart / String.prototype.padEnd
> 3.Object.getOwnPropertyDescriptors
> 4.异步函数async/await

### 3. 斐波那契数列有哪些实现方式

> 解法一：通项公式(O(1))由于这个斐波那契数列是有通项公式的那么实现这个通项公式就可以实现该数列

```js
function fibonacci(n){
    var sum = 0
    for(let i = 1; i <= n; i += 1) {
        sum += fib(i)
    }
    return sum

    function fib(n) {
      const SQRT_FIVE = Math.sqrt(5);
      return Math.round(1/SQRT_FIVE * (Math.pow(0.5 + SQRT_FIVE/2, n) - Math.pow(0.5 - SQRT_FIVE/2, n)));
    }
}
```
> 解法二：递归求解（O(1.618^n)）其中只有在ES6规范中，有一个尾调用优化，能够实现高效的尾递归方案
```js
function recurFib(n) {
  if (n < 2) {
    return n;
   }
  else {
    return recurFib(n-1) + recurFib(n-2);
   }
 }

  alert(recurFib(10));//将显示55
```
> 解法三：动态规划（O（n））
```js
 function fibonacci(n) {
    let n1 = 1,
        n2 = 1,
        sum = 1
    for(let i = 3; i <= n; i += 1) {
        sum = n1 + n2
        n1 = n2
        n2 = sum
    }
    return sum
}
  alert(fibonacci(10));//将显示55
  ```
> 解法四：矩阵快速幂(O(logn)）

### 4. 说说树与图有什么异同点

树：1.带有层次结构的图 2.树是含有根节点的 3.树是没有环的图 4.树不是一个递归的数据结构

图：1、图表中每个节点可以有任意数量的边，边可以是单向和双向的。2、图表中没有名为root的根节点的概念。3、图表可以有循环和自循环4、图表中，没有预定义数量的边，它取决于图表。5、图是网络模型结构。

### 5. 给你一棵公司节点的树，然后给你树中的一个用户id，让你返回一个该用户的父亲节点的数组信息，如何实现

> 给树的结构添加一个标签，用于标识查找该查找的子节点是否在该分支上，如果在那么设置为true否则设置为false
> 用空间换时间

### 6. webpack的构建流程

从启动构建到输出结果一系列过程：

（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。

（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。

（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。

（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。

（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。

（6）输出完成：输出所有的chunk到文件系统。

注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。

### 6. Webpack的path和public path区别

在webpack模块化开发的过程中，发现webpack.config.js配置文件的输出路径总有一个path与publicPath

官方解释：

官方解释

publicPath: The output.path from the view of the Javascript / HTML page.
从JS/HTML页面来看的输出路径
我的理解

output.path 储存你所有输出文件的本地文件目录。（绝对路径）

> 举个例子：
> path.join(__dirname, “build/”) 
> webpack将会把所有的文件输出到localdisk/path-to-your-project/build/

> output.publicPath你上传所有打包文件的位置（相对于服务器根目录）

1. path：用来存放打包后文件的输出目录
2. publicPath：指定资源文件引用的目录

### 7. 聊聊如果有16个矩形，但是theme主题颜色只有10个，那么如何实现，给剩下6个颜色进行填充



### 8. 聊聊你知道的排序算法

### 9. 你知道react吗？聊聊react吧？react与vue的区别有哪些

16.3版本之前的：
React的生命周期从广义上分为三个阶段：挂载、渲染、卸载

因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。
16.3的React的生命周期图:

![16.3生命周期](./pic/16.3.webp)

组件挂载是，先触发的是构造函数constructor，然后是将要挂载钩子(componentWillMount)，然后触发render渲染钩子，最后是组件挂载完毕的钩子（componentDieMount）

React 16之后有三个生命周期被废弃：

componentWillMount
componentWillReceiveProps
componentWillUpdate
因为这些生命周期方法容易被误解和滥用。

React 16.8+的生命周期分为三个阶段，分别是挂载阶段、更新阶段、卸载阶段。

> 挂载阶段

1. constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this
2. getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState)，这是个静态方法,当我们接收到新的属性想去修改state，可以使用getDerivedStateFromProps
3. render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
4. componentDidMount: 组件装载之后调用，此时可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅。

> 更新阶段
1. getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState)，有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能
render: 更新阶段也会触发此生命周期
2. getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState)，这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用
3. componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot)，该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至getSnapshotBeforeUpdate，然后在 componentDidUpdate中统一触发回调或更新状态。

> 卸载阶段
1. componentWillUnmount: 当组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。

![16.8生命周期](./pic/16.8.png)

react与vue的区别有哪些：
相同点：都支持ssr，都有vdom，组件化开发，实现webcomponents规范，数据驱动等
不同点：vue是双向数据流（当然为了实现单向数据流方便管理组件状态，vuex便出现了），react是单向数据流。vue的vdom是追踪每个组件的依赖关系，不会渲染整个组件树，react每当该状态被改变时，全部子组件都会render

### 10.  聊聊js如何实现私有变量？

1. 闭包定义局部变量
2. 使用ES6扩展的类型symbol类型定义：先来解释下symbol类型；Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突；类似与UUID的用法。

```js
var Pclass = (function(){
    const a = Symbol('a');
    const m = Symbol('m');
    class  Pclass {
        constructor(){
            this[a] = 'a这是私有变量';
            this.b = '变量B-外部可访问';
            this[m] = function(){
                console.log('私有方法');
            }
        }
        getA(){
            console.log(this[a]);
        }
        getM(){
            console.log(this[m]);
        }
    }
    return Pclass
}())

let pc = new Pclass() 
console.log(pc)   //打印 Pclass {b: "变量B-外部可访问", Symbol(a): "这是私有变量", Symbol(m): ƒ}

```

3. 使用ES6扩展的类型WeakMap类型定义：先来解释下WeakMap类型, 该类型数据是一个键-值（key-val）对的集合，只不过他的键（key）是一个引用，不同于一般的键-值。WeakMap 的使用如下。

```js
const wm = new WeakMap();
const a = {}, b = {};
wm.set(a, '这是a对象键的值');
wm.set(b, '这是b对象键的值');
console.log(wm.get(a)) //打印 这是a对象键的值
console.log(wm.get(b)) //打印 这是b对象键的值
```
解释了WeakMap类型数据，那下面来写一个基于WeakMap类型的私有变量，私有属性吧。
```js
var Pclass = (function(){
    const aa = new WeakMap();
    const mt = new WeakMap();
    class  Pclass {
        constructor(){
            this.b = 'b这是公有变量';
            aa.set(this, '私有变量aa')
            mt.set(this, function(){
                console.log('私有方法mt')
            })
        }
        getA(){
            console.log(aa.get(this));
        }
        getM(){
            console.log(mt.get(this));
        }
    }
    return Pclass
}())
let pc = new Pclass() 
console.log(pc) // Pclass {b: "b这是公有变量"}
```
同上述代码我们可以发现 只要不把 aa = new WeakMap(); m = new WeakMap()这两个集合对外开放 外部是无法访问到定义的私有变量a，和私有方法m， 因为他们的真实属性名称是a, m 这两个引用，而且是唯一的。


### 11.  谈谈你自己的规划吧？你对自己有什么计划？

## 上海碳衡科技二轮面试

### 0.typescript解决了什么痛点呢？

1. 在JS 有的基础类型，它都有；JS 没有的基础类型，他也有。
2. 增强代码的可读性。
3. 增强代码的可维护性
4. 高生产力，包容性，高覆盖性，高支持性

### 1.聊聊vue的核心逻辑是什么？

1. 发布订阅者模式

数据驱动——双向绑定

其实就是发布订阅者模式的变形
2. 代理模式

### 聊聊现实生活中的代理模式是什么样的

### 聊聊正向代理反向代理是什么？

1. 正向代理是客户端和其他所有服务器的代理者，而反向代理是客户端和所要代理的服务器之间的代理。
2. 举例：一般的正向代理，比如翻墙，任何可以连接到该代理服务器的软件，就可以通过代理访问任何其他的服务器，然后把数据返回给客户端，这里的代理服务器只对客户端负责。
3. 反向代理，如果他反向代理了两个服务，那么之后客户端访问者两个服务器的时候，该代理服务器才会给他代理，也就是说，这里的代理服务器只对代理服务器所代理的服务器负责
4. 总结：一个对客户端负责，一个对所代理的服务器负责

### 2.介绍一下你的工作内容，以及遇到的问题，如何解决的

### 3.公司主要的业务内容
