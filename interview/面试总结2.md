2022年5-7月面试总结

##  上海碳衡科技一面

### 1. 聊聊可视化的技术选型是怎么样的

> 可视化技术栈可以考虑是否使用svg或者canvas底层组件作为

### 2. 聊聊es8新特性有哪些

> 1.Object.values/Object.entries
> object.entries能够把对象的属性以数组形式返回，
object.values能够提取对象的属性值并以数组形式返回

> 但是，他们对 对象数组其实没有太大效果，可以自己试验一下
个人认为，在没有枚举类型的情况下，其实用for in更为实用。

> 2.String.prototype.padStart / String.prototype.padEnd
> 3.Object.getOwnPropertyDescriptors
> 4.异步函数async/await

### 3. 斐波那契数列有哪些实现方式

> 解法一：通项公式(O(1))由于这个斐波那契数列是有通项公式的那么实现这个通项公式就可以实现该数列

```js
function fibonacci(n){
    var sum = 0
    for(let i = 1; i <= n; i += 1) {
        sum += fib(i)
    }
    return sum

    function fib(n) {
      const SQRT_FIVE = Math.sqrt(5);
      return Math.round(1/SQRT_FIVE * (Math.pow(0.5 + SQRT_FIVE/2, n) - Math.pow(0.5 - SQRT_FIVE/2, n)));
    }
}
```
> 解法二：递归求解（O(1.618^n)）其中只有在ES6规范中，有一个尾调用优化，能够实现高效的尾递归方案
```js
function recurFib(n) {
  if (n < 2) {
    return n;
   }
  else {
    return recurFib(n-1) + recurFib(n-2);
   }
 }

  alert(recurFib(10));//将显示55
```
> 解法三：动态规划（O（n））
```js
 function fibonacci(n) {
    let n1 = 1,
        n2 = 1,
        sum = 1
    for(let i = 3; i <= n; i += 1) {
        sum = n1 + n2
        n1 = n2
        n2 = sum
    }
    return sum
}
  alert(fibonacci(10));//将显示55
  ```
> 解法四：矩阵快速幂(O(logn)）

### 4. 说说树与图有什么异同点

树：1.带有层次结构的图 2.树是含有根节点的 3.树是没有环的图 4.树不是一个递归的数据结构

图：1、图表中每个节点可以有任意数量的边，边可以是单向和双向的。2、图表中没有名为root的根节点的概念。3、图表可以有循环和自循环4、图表中，没有预定义数量的边，它取决于图表。5、图是网络模型结构。

### 5. 给你一棵公司节点的树，然后给你树中的一个用户id，让你返回一个该用户的父亲节点的数组信息，如何实现

> 给树的结构添加一个标签，用于标识查找该查找的子节点是否在该分支上，如果在那么设置为true否则设置为false
> 用空间换时间

### 6. Webpack的path和public path区别

### 7. 聊聊如果有16个矩形，但是theme主题颜色只有10个，那么如何实现，给剩下6个颜色进行填充

### 8. 聊聊你知道的排序算法

### 9. 你知道react吗？聊聊react吧？react与vue的区别有哪些

16.3版本之前的：
React的生命周期从广义上分为三个阶段：挂载、渲染、卸载

因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。
16.3的React的生命周期图:

![16.3生命周期](./pic/16.3.webp)

组件挂载是，先触发的是构造函数constructor，然后是将要挂载钩子(componentWillMount)，然后触发render渲染钩子，最后是组件挂载完毕的钩子（componentDieMount）

React 16之后有三个生命周期被废弃：

componentWillMount
componentWillReceiveProps
componentWillUpdate
因为这些生命周期方法容易被误解和滥用。

React 16.8+的生命周期分为三个阶段，分别是挂载阶段、更新阶段、卸载阶段。

> 挂载阶段

1. constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this
2. getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState)，这是个静态方法,当我们接收到新的属性想去修改state，可以使用getDerivedStateFromProps
3. render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
4. componentDidMount: 组件装载之后调用，此时可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅。

> 更新阶段
1. getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState)，有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能
render: 更新阶段也会触发此生命周期
2. getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState)，这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用
3. componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot)，该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至getSnapshotBeforeUpdate，然后在 componentDidUpdate中统一触发回调或更新状态。

> 卸载阶段
1. componentWillUnmount: 当组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。

![16.8生命周期](./pic/16.8.png)

react与vue的区别有哪些：
相同点：都支持ssr，都有vdom，组件化开发，实现webcomponents规范，数据驱动等
不同点：vue是双向数据流（当然为了实现单向数据流方便管理组件状态，vuex便出现了），react是单向数据流。vue的vdom是追踪每个组件的依赖关系，不会渲染整个组件树，react每当该状态被改变时，全部子组件都会render

### 10.  聊聊js如何实现私有变量？

1. 闭包定义局部变量
2. 使用ES6扩展的类型symbol类型定义：先来解释下symbol类型；Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突；类似与UUID的用法。

```js
var Pclass = (function(){
    const a = Symbol('a');
    const m = Symbol('m');
    class  Pclass {
        constructor(){
            this[a] = 'a这是私有变量';
            this.b = '变量B-外部可访问';
            this[m] = function(){
                console.log('私有方法');
            }
        }
        getA(){
            console.log(this[a]);
        }
        getM(){
            console.log(this[m]);
        }
    }
    return Pclass
}())

let pc = new Pclass() 
console.log(pc)   //打印 Pclass {b: "变量B-外部可访问", Symbol(a): "这是私有变量", Symbol(m): ƒ}

```

3. 使用ES6扩展的类型WeakMap类型定义：先来解释下WeakMap类型, 该类型数据是一个键-值（key-val）对的集合，只不过他的键（key）是一个引用，不同于一般的键-值。WeakMap 的使用如下。

```js
const wm = new WeakMap();
const a = {}, b = {};
wm.set(a, '这是a对象键的值');
wm.set(b, '这是b对象键的值');
console.log(wm.get(a)) //打印 这是a对象键的值
console.log(wm.get(b)) //打印 这是b对象键的值
```
解释了WeakMap类型数据，那下面来写一个基于WeakMap类型的私有变量，私有属性吧。
```js
var Pclass = (function(){
    const aa = new WeakMap();
    const mt = new WeakMap();
    class  Pclass {
        constructor(){
            this.b = 'b这是公有变量';
            aa.set(this, '私有变量aa')
            mt.set(this, function(){
                console.log('私有方法mt')
            })
        }
        getA(){
            console.log(aa.get(this));
        }
        getM(){
            console.log(mt.get(this));
        }
    }
    return Pclass
}())
let pc = new Pclass() 
console.log(pc) // Pclass {b: "b这是公有变量"}
```
同上述代码我们可以发现 只要不把 aa = new WeakMap(); m = new WeakMap()这两个集合对外开放 外部是无法访问到定义的私有变量a，和私有方法m， 因为他们的真实属性名称是a, m 这两个引用，而且是唯一的。


### 11.  谈谈你自己的规划吧？你对自己有什么计划？