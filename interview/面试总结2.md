- [上海碳衡科技一面](#上海碳衡科技一面)
  - [1. 聊聊可视化的技术选型是怎么样的](#1-聊聊可视化的技术选型是怎么样的)
  - [2. 聊聊es8新特性有哪些](#2-聊聊es8新特性有哪些)
  - [3. 斐波那契数列有哪些实现方式](#3-斐波那契数列有哪些实现方式)
  - [4. 说说树与图有什么异同点](#4-说说树与图有什么异同点)
  - [5. 给你一棵公司节点的树，然后给你树中的一个用户id，让你返回一个该用户的父亲节点的数组信息，如何实现](#5-给你一棵公司节点的树然后给你树中的一个用户id让你返回一个该用户的父亲节点的数组信息如何实现)
  - [6. webpack的构建流程](#6-webpack的构建流程)
  - [6. Webpack的path和public path区别](#6-webpack的path和public-path区别)
  - [7. 聊聊如果有16个矩形，但是theme主题颜色只有10个，那么如何实现，给剩下6个颜色进行填充](#7-聊聊如果有16个矩形但是theme主题颜色只有10个那么如何实现给剩下6个颜色进行填充)
  - [8. 聊聊你知道的排序算法](#8-聊聊你知道的排序算法)
  - [9. 你知道react吗？聊聊react吧？react与vue的区别有哪些](#9-你知道react吗聊聊react吧react与vue的区别有哪些)
  - [](#)
  - [10.  聊聊js如何实现私有变量？](#10--聊聊js如何实现私有变量)
  - [11.  谈谈你自己的规划吧？你对自己有什么计划？](#11--谈谈你自己的规划吧你对自己有什么计划)
- [上海碳衡科技二轮面试](#上海碳衡科技二轮面试)
  - [0.typescript解决了什么痛点呢？](#0typescript解决了什么痛点呢)
  - [1.聊聊vue的核心逻辑是什么？](#1聊聊vue的核心逻辑是什么)
  - [聊聊现实生活中的代理模式是什么样的](#聊聊现实生活中的代理模式是什么样的)
  - [聊聊正向代理反向代理是什么？](#聊聊正向代理反向代理是什么)
  - [2.介绍一下你的工作内容，以及遇到的问题，如何解决的](#2介绍一下你的工作内容以及遇到的问题如何解决的)
  - [3.公司主要的业务内容](#3公司主要的业务内容)
  - [雾角科技有限公司](#雾角科技有限公司)
  - [1.看一下这段代码是怎么输出的](#1看一下这段代码是怎么输出的)
  - [2.leetcode](#2leetcode)
  - [3.不使用Math函数实现开更号](#3不使用math函数实现开更号)
  - [4.聊聊useContext还有如何实现细粒度的数据更新](#4聊聊usecontext还有如何实现细粒度的数据更新)
  - [5.useEffect的逻辑聊聊把](#5useeffect的逻辑聊聊把)
  - [5.对于一个监听的对象useEffect，其对象上挂载的数据发生了变化，那么监听这个对象的组件会不会更新呢？](#5对于一个监听的对象useeffect其对象上挂载的数据发生了变化那么监听这个对象的组件会不会更新呢)
  - [5.知道mobx？吗](#5知道mobx吗)
  - [useCallback 记忆函数与useMemo 记忆组件](#usecallback-记忆函数与usememo-记忆组件)
  - [6.聊聊vue底层的数据绑定把。](#6聊聊vue底层的数据绑定把)
  - [7.autoRun知道吗？聊聊autoRun](#7autorun知道吗聊聊autorun)
  - [聊聊可视化有哪些库？能介绍一下吗](#聊聊可视化有哪些库能介绍一下吗)
  - [给你一个1个亿的数据绘制散点图，如何性能优化](#给你一个1个亿的数据绘制散点图如何性能优化)
  - [知道G2吗？ 了解图形语法吗？](#知道g2吗-了解图形语法吗)
  - [讲讲zrender，逐帧渲染如何实现的？](#讲讲zrender逐帧渲染如何实现的)
  - [璇星科技一面](#璇星科技一面)
    - [1.介绍一下你的项目以及你所遇到的挑战](#1介绍一下你的项目以及你所遇到的挑战)
    - [2.react了解的多吗？聊聊你对react的理解](#2react了解的多吗聊聊你对react的理解)
    - [3.介绍一下css中的flex布局把](#3介绍一下css中的flex布局把)
    - [4. 上下定高 中间自适应_上下高度固定（100px），中间自适应如何实现](#4-上下定高-中间自适应_上下高度固定100px中间自适应如何实现)
    - [5.typescript你熟悉吗？介绍一下？](#5typescript你熟悉吗介绍一下)
    - [6.typescript类型判断是什么？](#6typescript类型判断是什么)
    - [7.请问下面这个类型typescript如何定义](#7请问下面这个类型typescript如何定义)
    - [8.聊聊自己的规划把](#8聊聊自己的规划把)
  - [抖音电商面试一轮](#抖音电商面试一轮)


2022年5-7月面试总结


学习链接：https://juejin.cn/post/6844904084512718861

##  上海碳衡科技一面

### 1. 聊聊可视化的技术选型是怎么样的

> 可视化技术栈可以考虑是否使用svg或者canvas底层组件作为

### 2. 聊聊es8新特性有哪些

> 1.Object.values/Object.entries
> object.entries能够把对象的属性以数组形式返回，
object.values能够提取对象的属性值并以数组形式返回

> 但是，他们对 对象数组其实没有太大效果，可以自己试验一下
个人认为，在没有枚举类型的情况下，其实用for in更为实用。

> 2.String.prototype.padStart / String.prototype.padEnd
> 3.Object.getOwnPropertyDescriptors
> 4.异步函数async/await

### 3. 斐波那契数列有哪些实现方式

> 解法一：通项公式(O(1))由于这个斐波那契数列是有通项公式的那么实现这个通项公式就可以实现该数列

```js
function fibonacci(n){
    var sum = 0
    for(let i = 1; i <= n; i += 1) {
        sum += fib(i)
    }
    return sum

    function fib(n) {
      const SQRT_FIVE = Math.sqrt(5);
      return Math.round(1/SQRT_FIVE * (Math.pow(0.5 + SQRT_FIVE/2, n) - Math.pow(0.5 - SQRT_FIVE/2, n)));
    }
}
```
> 解法二：递归求解（O(1.618^n)）其中只有在ES6规范中，有一个尾调用优化，能够实现高效的尾递归方案
```js
function recurFib(n) {
  if (n < 2) {
    return n;
   }
  else {
    return recurFib(n-1) + recurFib(n-2);
   }
 }

  alert(recurFib(10));//将显示55
```
> 解法三：动态规划（O（n））
```js
 function fibonacci(n) {
    let n1 = 1,
        n2 = 1,
        sum = 1
    for(let i = 3; i <= n; i += 1) {
        sum = n1 + n2
        n1 = n2
        n2 = sum
    }
    return sum
}
  alert(fibonacci(10));//将显示55
  ```
> 解法四：矩阵快速幂(O(logn)）

### 4. 说说树与图有什么异同点

树：1.带有层次结构的图 2.树是含有根节点的 3.树是没有环的图 4.树不是一个递归的数据结构

图：1、图表中每个节点可以有任意数量的边，边可以是单向和双向的。2、图表中没有名为root的根节点的概念。3、图表可以有循环和自循环4、图表中，没有预定义数量的边，它取决于图表。5、图是网络模型结构。

### 5. 给你一棵公司节点的树，然后给你树中的一个用户id，让你返回一个该用户的父亲节点的数组信息，如何实现

> 给树的结构添加一个标签，用于标识查找该查找的子节点是否在该分支上，如果在那么设置为true否则设置为false
> 用空间换时间

### 6. webpack的构建流程

从启动构建到输出结果一系列过程：

（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。

（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。

（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。

（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。

（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。

（6）输出完成：输出所有的chunk到文件系统。

注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。

### 6. Webpack的path和public path区别

在webpack模块化开发的过程中，发现webpack.config.js配置文件的输出路径总有一个path与publicPath

官方解释：

官方解释

publicPath: The output.path from the view of the Javascript / HTML page.
从JS/HTML页面来看的输出路径
我的理解

output.path 储存你所有输出文件的本地文件目录。（绝对路径）

> 举个例子：
> path.join(__dirname, “build/”) 
> webpack将会把所有的文件输出到localdisk/path-to-your-project/build/

> output.publicPath你上传所有打包文件的位置（相对于服务器根目录）

1. path：用来存放打包后文件的输出目录
2. publicPath：指定资源文件引用的目录

### 7. 聊聊如果有16个矩形，但是theme主题颜色只有10个，那么如何实现，给剩下6个颜色进行填充



### 8. 聊聊你知道的排序算法

### 9. 你知道react吗？聊聊react吧？react与vue的区别有哪些

16.3版本之前的：
React的生命周期从广义上分为三个阶段：挂载、渲染、卸载

因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。
16.3的React的生命周期图:

![16.3生命周期](./pic/16.3.webp)

组件挂载是，先触发的是构造函数constructor，然后是将要挂载钩子(componentWillMount)，然后触发render渲染钩子，最后是组件挂载完毕的钩子（componentDieMount）

React 16之后有三个生命周期被废弃：

componentWillMount
componentWillReceiveProps
componentWillUpdate
因为这些生命周期方法容易被误解和滥用。

React 16.8+的生命周期分为三个阶段，分别是挂载阶段、更新阶段、卸载阶段。

> 挂载阶段

1. constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this
2. getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState)，这是个静态方法,当我们接收到新的属性想去修改state，可以使用getDerivedStateFromProps
3. render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
4. componentDidMount: 组件装载之后调用，此时可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅。

> 更新阶段
1. getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState)，有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能
render: 更新阶段也会触发此生命周期
2. getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState)，这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用
3. componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot)，该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至getSnapshotBeforeUpdate，然后在 componentDidUpdate中统一触发回调或更新状态。

> 卸载阶段
1. componentWillUnmount: 当组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作。

![16.8生命周期](./pic/16.8.png)

react与vue的区别有哪些：
相同点：都支持ssr，都有vdom，组件化开发，实现webcomponents规范，数据驱动等
不同点：vue是双向数据流（当然为了实现单向数据流方便管理组件状态，vuex便出现了），react是单向数据流。vue的vdom是追踪每个组件的依赖关系，不会渲染整个组件树，react每当该状态被改变时，全部子组件都会render


### 
### 10.  聊聊js如何实现私有变量？

1. 闭包定义局部变量
2. 使用ES6扩展的类型symbol类型定义：先来解释下symbol类型；Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突；类似与UUID的用法。

```js
var Pclass = (function(){
    const a = Symbol('a');
    const m = Symbol('m');
    class  Pclass {
        constructor(){
            this[a] = 'a这是私有变量';
            this.b = '变量B-外部可访问';
            this[m] = function(){
                console.log('私有方法');
            }
        }
        getA(){
            console.log(this[a]);
        }
        getM(){
            console.log(this[m]);
        }
    }
    return Pclass
}())

let pc = new Pclass() 
console.log(pc)   //打印 Pclass {b: "变量B-外部可访问", Symbol(a): "这是私有变量", Symbol(m): ƒ}

```

3. 使用ES6扩展的类型WeakMap类型定义：先来解释下WeakMap类型, 该类型数据是一个键-值（key-val）对的集合，只不过他的键（key）是一个引用，不同于一般的键-值。WeakMap 的使用如下。

```js
const wm = new WeakMap();
const a = {}, b = {};
wm.set(a, '这是a对象键的值');
wm.set(b, '这是b对象键的值');
console.log(wm.get(a)) //打印 这是a对象键的值
console.log(wm.get(b)) //打印 这是b对象键的值
```
解释了WeakMap类型数据，那下面来写一个基于WeakMap类型的私有变量，私有属性吧。
```js
var Pclass = (function(){
    const aa = new WeakMap();
    const mt = new WeakMap();
    class  Pclass {
        constructor(){
            this.b = 'b这是公有变量';
            aa.set(this, '私有变量aa')
            mt.set(this, function(){
                console.log('私有方法mt')
            })
        }
        getA(){
            console.log(aa.get(this));
        }
        getM(){
            console.log(mt.get(this));
        }
    }
    return Pclass
}())
let pc = new Pclass() 
console.log(pc) // Pclass {b: "b这是公有变量"}
```
同上述代码我们可以发现 只要不把 aa = new WeakMap(); m = new WeakMap()这两个集合对外开放 外部是无法访问到定义的私有变量a，和私有方法m， 因为他们的真实属性名称是a, m 这两个引用，而且是唯一的。


### 11.  谈谈你自己的规划吧？你对自己有什么计划？

## 上海碳衡科技二轮面试


### 0.typescript解决了什么痛点呢？

1. 在JS 有的基础类型，它都有；JS 没有的基础类型，他也有。
2. 增强代码的可读性。
3. 增强代码的可维护性
4. 高生产力，包容性，高覆盖性，高支持性

### 1.聊聊vue的核心逻辑是什么？
* 虚拟dom
* 数据驱动视图
* 组件式开发
1. 发布订阅者模式

数据驱动——双向绑定

其实就是发布订阅者模式的变形
2. 代理模式

### 聊聊现实生活中的代理模式是什么样的

### 聊聊正向代理反向代理是什么？

1. 正向代理是客户端和其他所有服务器的代理者，而反向代理是客户端和所要代理的服务器之间的代理。
2. 举例：一般的正向代理，比如翻墙，任何可以连接到该代理服务器的软件，就可以通过代理访问任何其他的服务器，然后把数据返回给客户端，这里的代理服务器只对客户端负责。
3. 反向代理，如果他反向代理了两个服务，那么之后客户端访问者两个服务器的时候，该代理服务器才会给他代理，也就是说，这里的代理服务器只对代理服务器所代理的服务器负责
4. 总结：一个对客户端负责，一个对所代理的服务器负责

### 2.介绍一下你的工作内容，以及遇到的问题，如何解决的

### 3.公司主要的业务内容

### 雾角科技有限公司

### 1.看一下这段代码是怎么输出的

```js
setTimeout(_ => console.log(4))

new Promise(resolve => {
  resolve()
  console.log(1)
}).then(_ => {
  console.log(3)
  Promise.resolve().then(_ => {
    console.log('X')
  }).then(_ => {
    Promise.resolve().then(_ => {
      console.log('Y')
    })
  })
})

console.log(2) 
```
答案：1,2,3,X,Y,4

### 2.leetcode
https://leetcode-cn.com/problems/unique-paths/

### 3.不使用Math函数实现开更号

```js
function sqrt(n, float = 0.0001) {
    if (n < 0) {
        return -1;
    } else {
        let result = 0;
        while (result * result < n) {
            result = result + float;
        }
        return result;
    }
}

function sqrt(n, float = 0.0001) {
    if (n < 0) {
        return -1;
    } else {
        let max = n;
        let low = 0;
        let mid = (low + max) / 2;
        do {
            if (mid * mid > n) {
                max = mid;
            } else {
                low = mid;
            }
            mid = (max + low) / 2;
        } while (Math.abs(mid * mid - n) > float)
        return mid;
    }
}
```

### 4.聊聊useContext还有如何实现细粒度的数据更新

### 5.useEffect的逻辑聊聊把

第二个参数，第二个参数一般情况下不要使用引用类型！因为如果是{}这种空对象就会造成死循环

### 5.对于一个监听的对象useEffect，其对象上挂载的数据发生了变化，那么监听这个对象的组件会不会更新呢？
不会更新，因为
如果useEffect第二个参数监听的是这个对象本身，那么这个组件是不会发生更新的，因为其引用地址没有发生变化，所以需要实现其监听对象挂载的数据，可以考虑对这个对象进行浅拷贝（对于引用类型的解构赋值就是浅拷贝），就可以实现监听这个对象的组件可以被更新。

### 5.知道mobx？吗

MobX是一个简单、可扩展、久经沙场的状态管理解决方案。这篇教程将会花十分钟指导你所有关于MobX的重要概念。MobX是一个独立的库，但大多数人还是将它和React配合使用，这篇教程也是会关注在两者的结合上。

### useCallback 记忆函数与useMemo 记忆组件

useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。
```js
useCallback(fn, inputs) is equivalent to useMemo(() =fn, inputs)
```


```js
function App() {
  const memoizedHandleClick = useCallback(() ={
    console.log('Click happened')
  }, []); // 空数组代表无论什么情况下该函数都不会发生改变
  return <SomeComponent onClick={memoizedHandleClick}>Click Me</SomeComponent>;
}
```
所以前面使用 useCallback 的例子可以使用 useMemo 进行改写：

```js
function App() {
  const memoizedHandleClick = useMemo(() =() ={
    console.log('Click happened')
  }, []); // 空数组代表无论什么情况下该函数都不会发生改变
  return <SomeComponent onClick={memoizedHandleClick}>Click Me</SomeComponent>;
}
```

唯一的区别是：useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你。所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。

所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。


### 6.聊聊vue底层的数据绑定把。

> vue2.0 使用的是object.getownProperty
> Object.defineProperty如何实现双向绑定
dom元素与属性进行绑定，相当于对dom元素添加watch，检测数据变化，变化时，调用set方法，修改对象（modal），当对象值发生改变是，调用get方法，重新给dom赋值。


```js
var testObject = {
   _year: 2019,
   version: 1,
};
Object.defineProperty(testObject, 'year', {
   /configurable: true,
   /enumerable: true,
   get: function () {
       return this._year;
   },
   set: function (newYear) {
       this._year = newYear;
       this.version = newYear - 2019;
   }
});
```
> vue3.0 使用的是proxy进行数据双向绑定

### 7.autoRun知道吗？聊聊autoRun

### 聊聊可视化有哪些库？能介绍一下吗

### 给你一个1个亿的数据绘制散点图，如何性能优化

### 知道G2吗？ 了解图形语法吗？ 

### 讲讲zrender，逐帧渲染如何实现的？

### 璇星科技一面

#### 1.介绍一下你的项目以及你所遇到的挑战
#### 2.react了解的多吗？聊聊你对react的理解

#### 3.介绍一下css中的flex布局把

flex布局的配置项就是

1. 主轴方向flex-direction有row与column然后是正向逆向

2. 然后是主轴对齐方式（justify-content属性）justify-content: flex-start | flex-end | center | space-between | space-around;

3. 交叉轴对齐方式（align-items属性） align-items: flex-start | flex-end | center | baseline | stretch;
4. align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
   
二、项目的属性

1. order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
2. flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
3. flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
4. flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
5. flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
6. align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

#### 4. 上下定高 中间自适应_上下高度固定（100px），中间自适应如何实现
1. 绝对定位
```html
<div class="top-center-bottom">
        <div class="top"></div>
        <div class="center"></div>
        <div class="bottom"></div>
</div>
```

```css
.top-center-bottom>div{
  position:absolute;
}
.top-center-bottom .top{
  /* 顶部 */
  top:0;
  height:100px;
  width:100%;
  background:red;
}
.top-center-bottom .bottom{
  /* 底部 */
  bottom:0;
  height:100px;
  width:100%;
  background:red;
}
.top-center-bottom .center{
  bottom:100px;
  top:100px;
  width:100%;
  background:green;
}
```

2. 使用flexbox：
```css
 html, body, .top-center-bottom{
  height:100%;
}
.top-center-bottom{
   display:flex;
   flex-direction:column;
}
.top-center-bottom .top{
  height:100px;
  background:red;
}
 .top-center-bottom .bottom{
  height:100px;
  background:red;
  }
 .top-center-bottom .center{
  flex:1;
  background:green;
}
```

3. 使用table布局

```css
html,body, .top-center-bottom{
        height:100%;
        width: 100%;
    } 
    .top-center-bottom{
        display:table;
    }
    .top-center-bottom>div{
        display: table-row;
    }
    .top-center-bottom .top{
        height: 100px;
        background: red;
    }
    .top-center-bottom .bottom{
        height: 100px;
        background: red;
    }
    .top-center-bottom .center{
        background: green;
    } 

```


#### 5.typescript你熟悉吗？介绍一下？


#### 6.typescript类型判断是什么？

#### 7.请问下面这个类型typescript如何定义

typescript如何及定义number，string

option类型对象：{
  type："string"
  value：string
}
{
   type:"number"
   value:number
}


#### 8.聊聊自己的规划把


### 抖音电商面试一轮

1. 介绍一下你的项目把，聊聊你遇到的那些问题比较有意思，或者有挑战的事情


2. typescript有什么优势，介绍一下


3. 看得懂这个是什么吗？function identity<T,U>

给你一个接口
interface myarr{
  name:string,
  value:number,
  id:number,
}

function identity<T:myarr,U:'name'|'value'>
就会返回一个新的接口
newarr{
  name:string,
  value:number
}
ts里的in符号关键字判断当前有没有那个属性
你也写一个funtion MYARR<>

4. 跨域有哪些，介绍一下，捡几个深入聊聊

跨域：是浏览器的安全策略，url：http，https ip地址端口号，有一个对不上就认为是跨域，
浏览器安全策略为了保护自己，
前端：jsonp，script标签，iframe
只有我们使用js代码fetch，xhl，websokter才会出现跨域
后端：nginx静态代理，projects代理解决跨域在vue的config配置
header头respone返还给你，
每次跨域数据都是请求到的，但是浏览器给你拦截了
option的请求


5. 知道css的var()吗？用来作什么的


6. 了解flex吗？说说flex
7. flex:0 1 auto有什么用
8. 
9.  说说BFC？你怎么理解bfc
10. 说说那些方式可以触发bfc
11. 前端换肤的N种方案，聊聊具体细节如何实现的
    1. 换类（换根目录的几种方式）
    2. 换肤的时候做一遍刷新
    3. 路由传参控制传入什么css，驱动css更新
12. 聊聊js的new关键字，new一个对象他的过程是什么

* let obj={};
* 
13. 了解es6到es5的语法转换怎么实现的，babel的打包逻辑是什么样的
14. 说说你了解的js类型有哪些？
15. js的typeof返回那些数据类型
16. typof（null）是什么，为什么
17. 说说0.1+0.2不等于0.3为什么，如何实现让其相等
18. 说说如何不用math库实现开更号
19. 说说promise.all手写一个

```js
Promise.all = function(promiseArr) {
    let index = 0, result = []
    return new Promise((resolve, reject) => {
        promiseArr.forEach((p, i) => {
            Promise.resolve(p).then(val => {
                index++
                result[i] = val
                if (index === promiseArr.length) {
                    resolve(result)
                }
            }, err => {
                reject(err)
            })
        })
    })
}
```

20. 回文的判断，双指针递归
21. 